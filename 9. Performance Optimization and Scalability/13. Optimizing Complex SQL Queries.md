# Comprehensive Query Optimization Guide

## Introduction

Are your queries working as hard as they should, or are they costing you valuable performance? By replacing subqueries, leveraging indexes, and optimizing joins, you can streamline database operations. These small changes can lead to faster queries, cleaner code, and more efficient systems.

In this guide, we'll demonstrate query optimization techniques, such as rewriting queries, adding indexes, and adjusting joins.

---

## Table of Contents

1. [Rewriting Queries for Simplicity](#1-rewriting-queries-for-simplicity)
2. [Using Indexes Effectively](#2-using-indexes-effectively)
3. [Avoiding Temporary Tables - Use CTEs](#3-avoiding-temporary-tables---use-ctes)
4. [Optimizing Joins](#4-optimizing-joins)
5. [Technology Stack Examples](#5-technology-stack-examples)
6. [Summary](#summary)

---

## 1. Rewriting Queries for Simplicity

Rewriting queries for simplicity is one technique for optimizing your queries. This enhances performance and reduces server strain, providing users with a smoother experience.

### Understanding Subqueries

**Subqueries** (also known as inner queries or nested queries) are SQL queries embedded within another SQL query. They are used to perform intermediate calculations or fetch specific data needed by the main or outer query.

Subqueries, while functional, require extra computation, whereas a properly structured WHERE clause often achieves the same result more effectively.

### Problem: Inefficient Subquery

An example of inefficiency is a query that uses a subquery to find orders placed after January 1, 2023 by matching order ID values between the orders and sales tables. The subquery is processed separately, which can make the query less efficient compared to direct filtering approaches.

#### T-SQL Example (SQL Server)

```sql
-- ❌ INEFFICIENT: Using subquery
SELECT *
FROM Orders o
WHERE o.OrderID IN (
    SELECT OrderID
    FROM Sales
    WHERE SalesDate > '2023-01-01'
);
```

#### C# with ADO.NET

```csharp
using System;
using System.Data.SqlClient;

public class SubqueryExample
{
    public void GetOrdersWithSubquery(string connectionString)
    {
        using (var connection = new SqlConnection(connectionString))
        {
            var command = new SqlCommand(@"
                SELECT *
                FROM Orders o
                WHERE o.OrderID IN (
                    SELECT OrderID
                    FROM Sales
                    WHERE SalesDate > @StartDate
                )", connection);
            
            command.Parameters.AddWithValue("@StartDate", new DateTime(2023, 1, 1));
            
            connection.Open();
            using (var reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    var orderId = reader.GetInt32(reader.GetOrdinal("OrderID"));
                    Console.WriteLine($"Order ID: {orderId}");
                }
            }
        }
    }
}
```

#### C# with Entity Framework Core

```csharp
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;

public class OrderService
{
    private readonly ApplicationDbContext _context;
    
    public OrderService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // ❌ INEFFICIENT: Subquery approach
    public async Task<List<Order>> GetOrdersWithSubquery()
    {
        var salesOrderIds = await _context.Sales
            .Where(s => s.SalesDate > new DateTime(2023, 1, 1))
            .Select(s => s.OrderID)
            .ToListAsync();
        
        return await _context.Orders
            .Where(o => salesOrderIds.Contains(o.OrderID))
            .ToListAsync();
    }
}
```

#### C# with Dapper

```csharp
using Dapper;
using System;
using System.Data.SqlClient;
using System.Collections.Generic;

public class DapperOrderRepository
{
    private readonly string _connectionString;
    
    public DapperOrderRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    // ❌ INEFFICIENT: Using subquery
    public IEnumerable<Order> GetOrdersWithSubquery()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                SELECT *
                FROM Orders o
                WHERE o.OrderID IN (
                    SELECT OrderID
                    FROM Sales
                    WHERE SalesDate > @StartDate
                )";
            
            return connection.Query<Order>(sql, new { StartDate = new DateTime(2023, 1, 1) });
        }
    }
}
```

### Solution: Direct Filtering with WHERE Clause

To optimize this query, it could be rewritten to directly filter rows in the orders table using the WHERE clause to specify that only orders with a sales date later than January 1, 2023 should be included. Eliminating the need for a subquery improves readability and performance, making the filtering process more efficient.

#### T-SQL Example

```sql
-- ✅ EFFICIENT: Direct filtering
SELECT o.*
FROM Orders o
WHERE o.SalesDate > '2023-01-01';
```

#### C# with ADO.NET

```csharp
public void GetOrdersOptimized(string connectionString)
{
    using (var connection = new SqlConnection(connectionString))
    {
        var command = new SqlCommand(@"
            SELECT o.*
            FROM Orders o
            WHERE o.SalesDate > @StartDate", 
            connection);
        
        command.Parameters.AddWithValue("@StartDate", new DateTime(2023, 1, 1));
        
        connection.Open();
        using (var reader = command.ExecuteReader())
        {
            while (reader.Read())
            {
                var orderId = reader.GetInt32(reader.GetOrdinal("OrderID"));
                var salesDate = reader.GetDateTime(reader.GetOrdinal("SalesDate"));
                Console.WriteLine($"Order ID: {orderId}, Date: {salesDate:yyyy-MM-dd}");
            }
        }
    }
}
```

#### C# with Entity Framework Core

```csharp
// ✅ EFFICIENT: Direct filtering
public async Task<List<Order>> GetOrdersOptimized()
{
    return await _context.Orders
        .Where(o => o.SalesDate > new DateTime(2023, 1, 1))
        .ToListAsync();
}
```

#### C# with Dapper

```csharp
// ✅ EFFICIENT: Direct filtering
public IEnumerable<Order> GetOrdersOptimized()
{
    using (var connection = new SqlConnection(_connectionString))
    {
        var sql = "SELECT o.* FROM Orders o WHERE o.SalesDate > @StartDate";
        return connection.Query<Order>(sql, new { StartDate = new DateTime(2023, 1, 1) });
    }
}
```

---

## 2. Using Indexes Effectively

Making sure that you are using indexes effectively is another technique to optimize your queries. For example, creating an index on the product name column of a products table optimizes how the database handles queries involving this column.

### Creating an Index

Enabling direct searches with the CREATE INDEX statement significantly accelerates searches and avoids scanning the entire table, enhancing query performance.

#### T-SQL Example

```sql
-- Create an index on ProductName column
CREATE INDEX IDX_ProductName ON Products(ProductName);

-- Now queries searching by ProductName will be faster
SELECT ProductID, ProductName, Price
FROM Products
WHERE ProductName = 'Laptop';

-- Create a composite index for multiple columns
CREATE INDEX IDX_Category_Price ON Products(Category, Price);

-- Queries filtering by both columns benefit
SELECT ProductID, ProductName, Price
FROM Products
WHERE Category = 'Electronics' AND Price > 500;
```

#### C# with ADO.NET

```csharp
public class IndexManagement
{
    public void CreateProductIndexes(string connectionString)
    {
        using (var connection = new SqlConnection(connectionString))
        {
            connection.Open();
            
            // Create single column index
            var createIndexCommand = new SqlCommand(
                "CREATE INDEX IDX_ProductName ON Products(ProductName)", 
                connection);
            createIndexCommand.ExecuteNonQuery();
            
            // Create composite index
            var createCompositeIndex = new SqlCommand(
                "CREATE INDEX IDX_Category_Price ON Products(Category, Price)", 
                connection);
            createCompositeIndex.ExecuteNonQuery();
            
            Console.WriteLine("Indexes created successfully");
        }
    }
    
    public void QueryWithIndex(string connectionString, string productName)
    {
        using (var connection = new SqlConnection(connectionString))
        {
            var command = new SqlCommand(@"
                SELECT ProductID, ProductName, Price
                FROM Products
                WHERE ProductName = @ProductName", 
                connection);
            
            command.Parameters.AddWithValue("@ProductName", productName);
            
            connection.Open();
            using (var reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    var id = reader.GetInt32(0);
                    var name = reader.GetString(1);
                    var price = reader.GetDecimal(2);
                    Console.WriteLine($"{id}: {name} - ${price}");
                }
            }
        }
    }
}
```

#### C# with Entity Framework Core

```csharp
using Microsoft.EntityFrameworkCore;

public class ApplicationDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Create index using Fluent API
        modelBuilder.Entity<Product>()
            .HasIndex(p => p.ProductName)
            .HasDatabaseName("IDX_ProductName");
        
        // Create composite index
        modelBuilder.Entity<Product>()
            .HasIndex(p => new { p.Category, p.Price })
            .HasDatabaseName("IDX_Category_Price");
    }
}

// Or using Data Annotations
public class Product
{
    public int ProductID { get; set; }
    
    [Microsoft.EntityFrameworkCore.Index(nameof(ProductName))]
    public string ProductName { get; set; }
    
    public string Category { get; set; }
    public decimal Price { get; set; }
}

// Querying with indexed column
public class ProductService
{
    private readonly ApplicationDbContext _context;
    
    public async Task<Product> GetProductByName(string productName)
    {
        return await _context.Products
            .FirstOrDefaultAsync(p => p.ProductName == productName);
    }
    
    public async Task<List<Product>> GetProductsByCategoryAndPrice(
        string category, decimal minPrice)
    {
        return await _context.Products
            .Where(p => p.Category == category && p.Price > minPrice)
            .ToListAsync();
    }
}
```

#### C# with Dapper

```csharp
public class DapperProductRepository
{
    private readonly string _connectionString;
    
    public DapperProductRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void CreateIndexes()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Execute("CREATE INDEX IDX_ProductName ON Products(ProductName)");
            connection.Execute("CREATE INDEX IDX_Category_Price ON Products(Category, Price)");
        }
    }
    
    public Product GetProductByName(string productName)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = "SELECT * FROM Products WHERE ProductName = @ProductName";
            return connection.QueryFirstOrDefault<Product>(sql, new { ProductName = productName });
        }
    }
    
    public IEnumerable<Product> GetProductsByCategoryAndPrice(string category, decimal minPrice)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                SELECT * FROM Products 
                WHERE Category = @Category AND Price > @MinPrice";
            return connection.Query<Product>(sql, new { Category = category, MinPrice = minPrice });
        }
    }
}
```

---

## 3. Avoiding Temporary Tables - Use CTEs

Another method to optimize your queries is avoiding temporary tables when possible. Temporary tables slow down performance by consuming extra memory. To solve this issue, we use common table expressions.

### Understanding CTEs

**Common Table Expressions (CTEs)** are temporary result sets in SQL that you can define within a query and reference multiple times in that same query. They improve code readability and modularity, especially for complex queries, by allowing you to create named reusable subqueries.

### Example: Sales Summary with CTE

This query defines a common table expression named sales summary, using the WITH keyword to calculate the total sales amount from the sales table called total sales. Then, this SELECT statement retrieves the total sales from the CTE in the main query.

The CTE acts as a temporary result set that exists only during the query execution, avoiding the overhead of creating a temporary table and making the query more efficient and readable.

#### T-SQL Example

```sql
-- ❌ INEFFICIENT: Using temporary table
CREATE TABLE #SalesSummary (
    TotalSales DECIMAL(18,2)
);

INSERT INTO #SalesSummary
SELECT SUM(Amount) AS TotalSales
FROM Sales;

SELECT TotalSales
FROM #SalesSummary;

DROP TABLE #SalesSummary;

-- ✅ EFFICIENT: Using CTE
WITH SalesSummary AS (
    SELECT SUM(Amount) AS TotalSales
    FROM Sales
)
SELECT TotalSales
FROM SalesSummary;

-- Advanced: Multiple CTEs
WITH SalesByRegion AS (
    SELECT Region, SUM(Amount) AS RegionTotal
    FROM Sales
    GROUP BY Region
),
TopRegions AS (
    SELECT Region, RegionTotal
    FROM SalesByRegion
    WHERE RegionTotal > 10000
)
SELECT Region, RegionTotal, 
       RegionTotal * 100.0 / (SELECT SUM(RegionTotal) FROM TopRegions) AS PercentageOfTop
FROM TopRegions
ORDER BY RegionTotal DESC;
```

#### C# with ADO.NET

```csharp
public class CTEExamples
{
    public decimal GetTotalSalesWithCTE(string connectionString)
    {
        using (var connection = new SqlConnection(connectionString))
        {
            var command = new SqlCommand(@"
                WITH SalesSummary AS (
                    SELECT SUM(Amount) AS TotalSales
                    FROM Sales
                )
                SELECT TotalSales
                FROM SalesSummary", 
                connection);
            
            connection.Open();
            var result = command.ExecuteScalar();
            return result != DBNull.Value ? Convert.ToDecimal(result) : 0m;
        }
    }
    
    public List<RegionSummary> GetTopRegions(string connectionString, decimal minTotal)
    {
        var results = new List<RegionSummary>();
        
        using (var connection = new SqlConnection(connectionString))
        {
            var command = new SqlCommand(@"
                WITH SalesByRegion AS (
                    SELECT Region, SUM(Amount) AS RegionTotal
                    FROM Sales
                    GROUP BY Region
                ),
                TopRegions AS (
                    SELECT Region, RegionTotal
                    FROM SalesByRegion
                    WHERE RegionTotal > @MinTotal
                )
                SELECT Region, RegionTotal, 
                       RegionTotal * 100.0 / (SELECT SUM(RegionTotal) FROM TopRegions) AS PercentageOfTop
                FROM TopRegions
                ORDER BY RegionTotal DESC", 
                connection);
            
            command.Parameters.AddWithValue("@MinTotal", minTotal);
            
            connection.Open();
            using (var reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    results.Add(new RegionSummary
                    {
                        Region = reader.GetString(0),
                        RegionTotal = reader.GetDecimal(1),
                        PercentageOfTop = reader.GetDecimal(2)
                    });
                }
            }
        }
        
        return results;
    }
}

public class RegionSummary
{
    public string Region { get; set; }
    public decimal RegionTotal { get; set; }
    public decimal PercentageOfTop { get; set; }
}
```

#### C# with Entity Framework Core

```csharp
public class SalesService
{
    private readonly ApplicationDbContext _context;
    
    public SalesService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // EF Core doesn't directly support CTEs, but you can use FromSqlRaw
    public async Task<decimal> GetTotalSalesWithCTE()
    {
        var sql = @"
            WITH SalesSummary AS (
                SELECT SUM(Amount) AS TotalSales
                FROM Sales
            )
            SELECT TotalSales FROM SalesSummary";
        
        var result = await _context.Database
            .SqlQueryRaw<decimal>(sql)
            .FirstOrDefaultAsync();
        
        return result;
    }
    
    // Alternative: Use LINQ (EF Core will optimize)
    public async Task<decimal> GetTotalSalesLinq()
    {
        return await _context.Sales.SumAsync(s => s.Amount);
    }
    
    public async Task<List<RegionSummary>> GetTopRegions(decimal minTotal)
    {
        var sql = @"
            WITH SalesByRegion AS (
                SELECT Region, SUM(Amount) AS RegionTotal
                FROM Sales
                GROUP BY Region
            ),
            TopRegions AS (
                SELECT Region, RegionTotal
                FROM SalesByRegion
                WHERE RegionTotal > @p0
            )
            SELECT Region, RegionTotal, 
                   RegionTotal * 100.0 / (SELECT SUM(RegionTotal) FROM TopRegions) AS PercentageOfTop
            FROM TopRegions
            ORDER BY RegionTotal DESC";
        
        return await _context.Set<RegionSummary>()
            .FromSqlRaw(sql, minTotal)
            .ToListAsync();
    }
}
```

#### C# with Dapper

```csharp
public class DapperSalesRepository
{
    private readonly string _connectionString;
    
    public DapperSalesRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public decimal GetTotalSalesWithCTE()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                WITH SalesSummary AS (
                    SELECT SUM(Amount) AS TotalSales
                    FROM Sales
                )
                SELECT TotalSales FROM SalesSummary";
            
            return connection.QueryFirstOrDefault<decimal>(sql);
        }
    }
    
    public IEnumerable<RegionSummary> GetTopRegions(decimal minTotal)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                WITH SalesByRegion AS (
                    SELECT Region, SUM(Amount) AS RegionTotal
                    FROM Sales
                    GROUP BY Region
                ),
                TopRegions AS (
                    SELECT Region, RegionTotal
                    FROM SalesByRegion
                    WHERE RegionTotal > @MinTotal
                )
                SELECT Region, RegionTotal, 
                       RegionTotal * 100.0 / (SELECT SUM(RegionTotal) FROM TopRegions) AS PercentageOfTop
                FROM TopRegions
                ORDER BY RegionTotal DESC";
            
            return connection.Query<RegionSummary>(sql, new { MinTotal = minTotal });
        }
    }
}
```

---

## 4. Optimizing Joins

Finally, let's examine how to optimize joins, especially when working with large data sets. Joins are essential for combining data from multiple tables, but they can be resource-intensive when dealing with large data sets.

### Example: Filtering Before Joins

This query retrieves data from the CUSTOMERS and ORDERS tables by matching rows where the CUSTOMERID values are equal. It uses aliases C for CUSTOMERS and O for ORDERS to simplify table references, making the query more concise.

The WHERE C.ISACTIVE equals one condition filters active customers before performing the join, reducing the data set size and improving the query's overall efficiency.

#### T-SQL Example

```sql
-- Create indexes for optimal join performance
CREATE INDEX IDX_CustomerID ON Orders(CustomerID);
CREATE INDEX IDX_IsActive_CustomerID ON Customers(IsActive, CustomerID);

-- ✅ OPTIMIZED: Filter before join
SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.IsActive = 1
ORDER BY o.OrderDate DESC;

-- Alternative: Using subquery to pre-filter
SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
FROM (
    SELECT CustomerID, Name
    FROM Customers
    WHERE IsActive = 1
) c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
ORDER BY o.OrderDate DESC;
```

#### C# with ADO.NET

```csharp
public class JoinOptimization
{
    public void CreateJoinIndexes(string connectionString)
    {
        using (var connection = new SqlConnection(connectionString))
        {
            connection.Open();
            
            var createIndexes = new SqlCommand(@"
                CREATE INDEX IDX_CustomerID ON Orders(CustomerID);
                CREATE INDEX IDX_IsActive_CustomerID ON Customers(IsActive, CustomerID);", 
                connection);
            
            createIndexes.ExecuteNonQuery();
            Console.WriteLine("Join indexes created successfully");
        }
    }
    
    public List<CustomerOrder> GetActiveCustomerOrders(string connectionString)
    {
        var results = new List<CustomerOrder>();
        
        using (var connection = new SqlConnection(connectionString))
        {
            var command = new SqlCommand(@"
                SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
                FROM Customers c
                INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                WHERE c.IsActive = @IsActive
                ORDER BY o.OrderDate DESC", 
                connection);
            
            command.Parameters.AddWithValue("@IsActive", 1);
            
            connection.Open();
            using (var reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    results.Add(new CustomerOrder
                    {
                        CustomerID = reader.GetInt32(0),
                        CustomerName = reader.GetString(1),
                        OrderID = reader.GetInt32(2),
                        OrderDate = reader.GetDateTime(3)
                    });
                }
            }
        }
        
        return results;
    }
}

public class CustomerOrder
{
    public int CustomerID { get; set; }
    public string CustomerName { get; set; }
    public int OrderID { get; set; }
    public DateTime OrderDate { get; set; }
}
```

#### C# with Entity Framework Core

```csharp
public class Customer
{
    public int CustomerID { get; set; }
    public string Name { get; set; }
    public bool IsActive { get; set; }
    public ICollection<Order> Orders { get; set; }
}

public class Order
{
    public int OrderID { get; set; }
    public int CustomerID { get; set; }
    public DateTime OrderDate { get; set; }
    public Customer Customer { get; set; }
}

public class ApplicationDbContext : DbContext
{
    public DbSet<Customer> Customers { get; set; }
    public DbSet<Order> Orders { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Define relationship
        modelBuilder.Entity<Order>()
            .HasOne(o => o.Customer)
            .WithMany(c => c.Orders)
            .HasForeignKey(o => o.CustomerID);
        
        // Create indexes
        modelBuilder.Entity<Order>()
            .HasIndex(o => o.CustomerID)
            .HasDatabaseName("IDX_CustomerID");
        
        modelBuilder.Entity<Customer>()
            .HasIndex(c => new { c.IsActive, c.CustomerID })
            .HasDatabaseName("IDX_IsActive_CustomerID");
    }
}

public class OrderService
{
    private readonly ApplicationDbContext _context;
    
    public OrderService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // ✅ OPTIMIZED: EF Core generates efficient JOIN with filtering
    public async Task<List<CustomerOrderDto>> GetActiveCustomerOrders()
    {
        return await _context.Orders
            .Where(o => o.Customer.IsActive)
            .Select(o => new CustomerOrderDto
            {
                CustomerID = o.CustomerID,
                CustomerName = o.Customer.Name,
                OrderID = o.OrderID,
                OrderDate = o.OrderDate
            })
            .OrderByDescending(o => o.OrderDate)
            .ToListAsync();
    }
    
    // Alternative: Using Include
    public async Task<List<Order>> GetActiveCustomerOrdersWithInclude()
    {
        return await _context.Orders
            .Include(o => o.Customer)
            .Where(o => o.Customer.IsActive)
            .OrderByDescending(o => o.OrderDate)
            .ToListAsync();
    }
}

public class CustomerOrderDto
{
    public int CustomerID { get; set; }
    public string CustomerName { get; set; }
    public int OrderID { get; set; }
    public DateTime OrderDate { get; set; }
}
```

#### C# with Dapper

```csharp
public class DapperOrderRepository
{
    private readonly string _connectionString;
    
    public DapperOrderRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void CreateJoinIndexes()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Execute("CREATE INDEX IDX_CustomerID ON Orders(CustomerID)");
            connection.Execute("CREATE INDEX IDX_IsActive_CustomerID ON Customers(IsActive, CustomerID)");
        }
    }
    
    public IEnumerable<CustomerOrder> GetActiveCustomerOrders()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                SELECT c.CustomerID, c.Name AS CustomerName, o.OrderID, o.OrderDate
                FROM Customers c
                INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                WHERE c.IsActive = @IsActive
                ORDER BY o.OrderDate DESC";
            
            return connection.Query<CustomerOrder>(sql, new { IsActive = true });
        }
    }
    
    // Multi-mapping example
    public IEnumerable<Customer> GetActiveCustomersWithOrders()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                SELECT c.*, o.*
                FROM Customers c
                INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                WHERE c.IsActive = @IsActive
                ORDER BY o.OrderDate DESC";
            
            var customerDictionary = new Dictionary<int, Customer>();
            
            return connection.Query<Customer, Order, Customer>(
                sql,
                (customer, order) =>
                {
                    if (!customerDictionary.TryGetValue(customer.CustomerID, out var customerEntry))
                    {
                        customerEntry = customer;
                        customerEntry.Orders = new List<Order>();
                        customerDictionary.Add(customerEntry.CustomerID, customerEntry);
                    }
                    
                    customerEntry.Orders.Add(order);
                    return customerEntry;
                },
                new { IsActive = true },
                splitOn: "OrderID"
            ).Distinct();
        }
    }
}
```

#### Console Application Example with ADO.NET

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main(string[] args)
    {
        var connectionString = "Server=localhost;Database=SalesDB;Integrated Security=true;";
        var optimizer = new QueryOptimizer(connectionString);
        
        // Create indexes
        Console.WriteLine("Creating optimized indexes...");
        optimizer.CreateAllIndexes();
        
        // Demonstrate optimizations
        Console.WriteLine("\n=== Order Statistics ===");
        optimizer.DisplayOrderStatistics(new DateTime(2023, 1, 1));
        
        Console.WriteLine("\n=== Active Customer Orders ===");
        optimizer.DisplayActiveCustomerOrders();
        
        Console.WriteLine("\n=== Products by Category ===");
        optimizer.DisplayProductsByCategory("Electronics", 500);
    }
}

public class QueryOptimizer
{
    private readonly string _connectionString;
    
    public QueryOptimizer(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void CreateAllIndexes()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Open();
            
            var sql = @"
                -- Create indexes if they don't exist
                IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IDX_CustomerID')
                    CREATE INDEX IDX_CustomerID ON Orders(CustomerID);
                
                IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IDX_IsActive_CustomerID')
                    CREATE INDEX IDX_IsActive_CustomerID ON Customers(IsActive, CustomerID);
                
                IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IDX_ProductName')
                    CREATE INDEX IDX_ProductName ON Products(ProductName);
                
                IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IDX_Category_Price')
                    CREATE INDEX IDX_Category_Price ON Products(Category, Price);
                
                IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IDX_OrderDate')
                    CREATE INDEX IDX_OrderDate ON Orders(OrderDate);";
            
            using (var command = new SqlCommand(sql, connection))
            {
                command.ExecuteNonQuery();
                Console.WriteLine("All indexes created successfully!");
            }
        }
    }
    
    public void DisplayOrderStatistics(DateTime startDate)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            // Using CTE for complex aggregation
            var sql = @"
                WITH OrdersByCustomer AS (
                    SELECT 
                        c.CustomerID,
                        c.Name,
                        COUNT(o.OrderID) AS OrderCount,
                        SUM(o.TotalAmount) AS TotalSpent
                    FROM Customers c
                    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                    WHERE c.IsActive = 1 AND o.OrderDate >= @StartDate
                    GROUP BY c.CustomerID, c.Name
                ),
                TopCustomers AS (
                    SELECT CustomerID, Name, OrderCount, TotalSpent
                    FROM OrdersByCustomer
                    WHERE TotalSpent > 1000
                )
                SELECT 
                    COUNT(*) AS TotalCustomers,
                    SUM(OrderCount) AS TotalOrders,
                    SUM(TotalSpent) AS TotalRevenue,
                    AVG(TotalSpent) AS AverageSpent
                FROM TopCustomers";
            
            using (var command = new SqlCommand(sql, connection))
            {
                command.Parameters.AddWithValue("@StartDate", startDate);
                connection.Open();
                
                using (var reader = command.ExecuteReader())
                {
                    if (reader.Read())
                    {
                        Console.WriteLine($"Total Top Customers: {reader.GetInt32(0)}");
                        Console.WriteLine($"Total Orders: {reader.GetInt32(1)}");
                        Console.WriteLine($"Total Revenue: ${reader.GetDecimal(2):N2}");
                        Console.WriteLine($"Average Spent: ${reader.GetDecimal(3):N2}");
                    }
                }
            }
        }
    }
    
    public void DisplayActiveCustomerOrders()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            // Optimized join with filtering
            var sql = @"
                SELECT TOP 10
                    c.CustomerID, c.Name, o.OrderID, o.OrderDate, o.TotalAmount
                FROM Customers c
                INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                WHERE c.IsActive = 1
                ORDER BY o.OrderDate DESC";
            
            using (var command = new SqlCommand(sql, connection))
            {
                connection.Open();
                using (var reader = command.ExecuteReader())
                {
                    Console.WriteLine($"{"Customer",-20} {"Order ID",10} {"Date",12} {"Amount",12}");
                    Console.WriteLine(new string('-', 60));
                    
                    while (reader.Read())
                    {
                        var customerName = reader.GetString(1);
                        var orderId = reader.GetInt32(2);
                        var orderDate = reader.GetDateTime(3);
                        var totalAmount = reader.GetDecimal(4);
                        
                        Console.WriteLine($"{customerName,-20} {orderId,10} {orderDate:yyyy-MM-dd,12} ${totalAmount,11:N2}");
                    }
                }
            }
        }
    }
    
    public void DisplayProductsByCategory(string category, decimal minPrice)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            // Using composite index
            var sql = @"
                SELECT ProductID, ProductName, Category, Price
                FROM Products
                WHERE Category = @Category AND Price > @MinPrice
                ORDER BY Price DESC";
            
            using (var command = new SqlCommand(sql, connection))
            {
                command.Parameters.AddWithValue("@Category", category);
                command.Parameters.AddWithValue("@MinPrice", minPrice);
                
                connection.Open();
                using (var reader = command.ExecuteReader())
                {
                    Console.WriteLine($"{"Product",-30} {"Category",-15} {"Price",10}");
                    Console.WriteLine(new string('-', 60));
                    
                    while (reader.Read())
                    {
                        var productName = reader.GetString(1);
                        var productCategory = reader.GetString(2);
                        var price = reader.GetDecimal(3);
                        
                        Console.WriteLine($"{productName,-30} {productCategory,-15} ${price,9:N2}");
                    }
                }
            }
        }
    }
}
```

---

## 5. Technology Stack Examples

### Complete Application Example

Here's a complete example showing all optimization techniques combined across different technology stacks:

#### ASP.NET Core Web API with Multiple Data Access Patterns

```csharp
// Program.cs
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// Register repositories
builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<IProductRepository, ProductRepository>();

var app = builder.Build();
app.MapControllers();
app.Run();

// Models/Customer.cs
public class Customer
{
    public int CustomerID { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public bool IsActive { get; set; }
    public ICollection<Order> Orders { get; set; }
}

// Models/Order.cs
public class Order
{
    public int OrderID { get; set; }
    public int CustomerID { get; set; }
    public DateTime OrderDate { get; set; }
    public decimal TotalAmount { get; set; }
    public Customer Customer { get; set; }
}

// Models/Product.cs
public class Product
{
    public int ProductID { get; set; }
    public string ProductName { get; set; }
    public string Category { get; set; }
    public decimal Price { get; set; }
}

// Data/ApplicationDbContext.cs
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
    
    public DbSet<Customer> Customers { get; set; }
    public DbSet<Order> Orders { get; set; }
    public DbSet<Product> Products { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure relationships
        modelBuilder.Entity<Order>()
            .HasOne(o => o.Customer)
            .WithMany(c => c.Orders)
            .HasForeignKey(o => o.CustomerID);
        
        // Create optimized indexes
        modelBuilder.Entity<Order>()
            .HasIndex(o => o.CustomerID)
            .HasDatabaseName("IDX_CustomerID");
        
        modelBuilder.Entity<Order>()
            .HasIndex(o => o.OrderDate)
            .HasDatabaseName("IDX_OrderDate");
        
        modelBuilder.Entity<Customer>()
            .HasIndex(c => new { c.IsActive, c.CustomerID })
            .HasDatabaseName("IDX_IsActive_CustomerID");
        
        modelBuilder.Entity<Product>()
            .HasIndex(p => p.ProductName)
            .HasDatabaseName("IDX_ProductName");
        
        modelBuilder.Entity<Product>()
            .HasIndex(p => new { p.Category, p.Price })
            .HasDatabaseName("IDX_Category_Price");
    }
}

// Repositories/IOrderRepository.cs
public interface IOrderRepository
{
    Task<List<OrderSummaryDto>> GetActiveCustomerOrdersAsync();
    Task<OrderStatisticsDto> GetOrderStatisticsAsync(DateTime startDate);
}

// Repositories/OrderRepository.cs
public class OrderRepository : IOrderRepository
{
    private readonly ApplicationDbContext _context;
    
    public OrderRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // ✅ Optimized query with filtering and proper joins
    public async Task<List<OrderSummaryDto>> GetActiveCustomerOrdersAsync()
    {
        return await _context.Orders
            .Where(o => o.Customer.IsActive && o.OrderDate >= DateTime.Now.AddYears(-1))
            .Select(o => new OrderSummaryDto
            {
                CustomerID = o.CustomerID,
                CustomerName = o.Customer.Name,
                OrderID = o.OrderID,
                OrderDate = o.OrderDate,
                TotalAmount = o.TotalAmount
            })
            .OrderByDescending(o => o.OrderDate)
            .ToListAsync();
    }
    
    // ✅ Using CTE approach with raw SQL for complex aggregations
    public async Task<OrderStatisticsDto> GetOrderStatisticsAsync(DateTime startDate)
    {
        var sql = @"
            WITH OrdersByCustomer AS (
                SELECT 
                    c.CustomerID,
                    c.Name,
                    COUNT(o.OrderID) AS OrderCount,
                    SUM(o.TotalAmount) AS TotalSpent
                FROM Customers c
                INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                WHERE c.IsActive = 1 AND o.OrderDate >= @StartDate
                GROUP BY c.CustomerID, c.Name
            ),
            TopCustomers AS (
                SELECT 
                    CustomerID,
                    Name,
                    OrderCount,
                    TotalSpent
                FROM OrdersByCustomer
                WHERE TotalSpent > 1000
            )
            SELECT 
                COUNT(*) AS TotalCustomers,
                SUM(OrderCount) AS TotalOrders,
                SUM(TotalSpent) AS TotalRevenue,
                AVG(TotalSpent) AS AverageSpent
            FROM TopCustomers";
        
        return await _context.Database
            .SqlQueryRaw<OrderStatisticsDto>(sql, 
                new SqlParameter("@StartDate", startDate))
            .FirstOrDefaultAsync();
    }
}

// DTOs/OrderSummaryDto.cs
public class OrderSummaryDto
{
    public int CustomerID { get; set; }
    public string CustomerName { get; set; }
    public int OrderID { get; set; }
    public DateTime OrderDate { get; set; }
    public decimal TotalAmount { get; set; }
}

public class OrderStatisticsDto
{
    public int TotalCustomers { get; set; }
    public int TotalOrders { get; set; }
    public decimal TotalRevenue { get; set; }
    public decimal AverageSpent { get; set; }
}

// Repositories/IProductRepository.cs
public interface IProductRepository
{
    Task<Product> GetProductByNameAsync(string productName);
    Task<List<Product>> GetProductsByCategoryAsync(string category, decimal minPrice);
}

// Repositories/ProductRepository.cs (Using Dapper)
public class ProductRepository : IProductRepository
{
    private readonly string _connectionString;
    
    public ProductRepository(IConfiguration configuration)
    {
        _connectionString = configuration.GetConnectionString("DefaultConnection");
    }
    
    // ✅ Optimized with index on ProductName
    public async Task<Product> GetProductByNameAsync(string productName)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = "SELECT * FROM Products WHERE ProductName = @ProductName";
            return await connection.QueryFirstOrDefaultAsync<Product>(
                sql, new { ProductName = productName });
        }
    }
    
    // ✅ Optimized with composite index on Category and Price
    public async Task<List<Product>> GetProductsByCategoryAsync(string category, decimal minPrice)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var sql = @"
                SELECT * FROM Products 
                WHERE Category = @Category AND Price > @MinPrice
                ORDER BY Price DESC";
            
            var results = await connection.QueryAsync<Product>(
                sql, new { Category = category, MinPrice = minPrice });
            
            return results.ToList();
        }
    }
}

// Controllers/OrdersController.cs
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    private readonly IOrderRepository _orderRepository;
    
    public OrdersController(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }
    
    [HttpGet("active-customers")]
    public async Task<ActionResult<List<OrderSummaryDto>>> GetActiveCustomerOrders()
    {
        var orders = await _orderRepository.GetActiveCustomerOrdersAsync();
        return Ok(orders);
    }
    
    [HttpGet("statistics")]
    public async Task<ActionResult<OrderStatisticsDto>> GetOrderStatistics(
        [FromQuery] DateTime? startDate)
    {
        var date = startDate ?? DateTime.Now.AddYears(-1);
        var statistics = await _orderRepository.GetOrderStatisticsAsync(date);
        return Ok(statistics);
    }
}

// Controllers/ProductsController.cs
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _productRepository;
    
    public ProductsController(IProductRepository productRepository)
    {
        _productRepository = productRepository;
    }
    
    [HttpGet("{productName}")]
    public async Task<ActionResult<Product>> GetProductByName(string productName)
    {
        var product = await _productRepository.GetProductByNameAsync(productName);
        
        if (product == null)
            return NotFound();
        
        return Ok(product);
    }
    
    [HttpGet("category/{category}")]
    public async Task<ActionResult<List<Product>>> GetProductsByCategory(
        string category,
        [FromQuery] decimal minPrice = 0)
    {
        var products = await _productRepository.GetProductsByCategoryAsync(category, minPrice);
        return Ok(products);
    }
}