# Asynchronous Tasks with Queues and Background Jobs in .NET

This guide demonstrates how to implement asynchronous task processing using queues and background workers in a .NET application.

## Step 1: Setting Up the Task Queue

The `TaskQueue` class manages a queue for asynchronous task processing using channels.

### C# Implementation

```csharp
using System.Threading.Channels;

public class TaskQueue
{
    private readonly Channel<Func<Task>> _queue;

    public TaskQueue()
    {
        // Create an unbounded queue that can continuously accept items
        _queue = Channel.CreateUnbounded<Func<Task>>();
    }

    // Method to add tasks to the queue
    public async Task EnqueueTask(Func<Task> task)
    {
        await _queue.Writer.WriteAsync(task);
    }

    // Method to read tasks from the queue
    public async Task<Func<Task>> DequeueTask()
    {
        return await _queue.Reader.ReadAsync();
    }

    // Method to check if queue has items to read
    public ChannelReader<Func<Task>> GetReader()
    {
        return _queue.Reader;
    }
}
```

## Step 2: Creating a Background Worker

The `BackgroundWorker` class continuously processes tasks from the task queue.

### C# Implementation

```csharp
public class BackgroundWorker
{
    private readonly TaskQueue _taskQueue;

    public BackgroundWorker(TaskQueue taskQueue)
    {
        _taskQueue = taskQueue;
    }

    // Continuously process tasks from the queue
    public async Task StartProcessing()
    {
        var reader = _taskQueue.GetReader();

        // Keep processing while there are items in the queue
        while (await reader.WaitToReadAsync())
        {
            // Dequeue and execute the task
            var task = await _taskQueue.DequeueTask();
            await task();

            // Optional delay to illustrate processing
            await Task.Delay(100);
        }
    }
}
```

## Step 3: Enqueue and Process Tasks

The main program demonstrates how to use the task queue and background worker.

### C# Implementation

```csharp
class Program
{
    static async Task Main(string[] args)
    {
        // Create a task queue
        var taskQueue = new TaskQueue();

        // Instantiate background worker
        var worker = new BackgroundWorker(taskQueue);

        // Start task processing in the background
        var workerTask = worker.StartProcessing();

        // Enqueue tasks
        for (int i = 1; i <= 10; i++)
        {
            int taskId = i;
            
            await taskQueue.EnqueueTask(async () =>
            {
                Console.WriteLine($"Processing task {taskId}");
                await Task.Delay(500); // Simulate work
                Console.WriteLine($"Completed task {taskId}");
            });

            Console.WriteLine($"Enqueued task {taskId}");
            await Task.Delay(200); // Small delay between enqueuing
        }

        // Wait for all tasks to complete
        await workerTask;
    }
}
```

## Additional Example: T-SQL Job Queue Pattern

While the document focuses on .NET, here's how you might implement a similar pattern using SQL Server for persistent task queuing.

### T-SQL Implementation

```sql
-- Create a task queue table
CREATE TABLE TaskQueue
(
    TaskId INT IDENTITY(1,1) PRIMARY KEY,
    TaskName NVARCHAR(255) NOT NULL,
    TaskPayload NVARCHAR(MAX),
    Status NVARCHAR(50) DEFAULT 'Pending',
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    ProcessedAt DATETIME2 NULL,
    ErrorMessage NVARCHAR(MAX) NULL
);

-- Stored procedure to enqueue a task
CREATE PROCEDURE EnqueueTask
    @TaskName NVARCHAR(255),
    @TaskPayload NVARCHAR(MAX)
AS
BEGIN
    INSERT INTO TaskQueue (TaskName, TaskPayload)
    VALUES (@TaskName, @TaskPayload);
    
    SELECT SCOPE_IDENTITY() AS TaskId;
END;
GO

-- Stored procedure to dequeue and process a task
CREATE PROCEDURE DequeueTask
AS
BEGIN
    DECLARE @TaskId INT;
    DECLARE @TaskName NVARCHAR(255);
    DECLARE @TaskPayload NVARCHAR(MAX);

    -- Get the next pending task (with row locking)
    SELECT TOP 1 
        @TaskId = TaskId,
        @TaskName = TaskName,
        @TaskPayload = TaskPayload
    FROM TaskQueue WITH (UPDLOCK, READPAST)
    WHERE Status = 'Pending'
    ORDER BY CreatedAt;

    -- Mark task as processing
    IF @TaskId IS NOT NULL
    BEGIN
        UPDATE TaskQueue
        SET Status = 'Processing',
            ProcessedAt = GETUTCDATE()
        WHERE TaskId = @TaskId;

        -- Return task details
        SELECT 
            TaskId,
            TaskName,
            TaskPayload
        FROM TaskQueue
        WHERE TaskId = @TaskId;
    END
END;
GO

-- Stored procedure to mark task as completed
CREATE PROCEDURE CompleteTask
    @TaskId INT
AS
BEGIN
    UPDATE TaskQueue
    SET Status = 'Completed'
    WHERE TaskId = @TaskId;
END;
GO

-- Stored procedure to mark task as failed
CREATE PROCEDURE FailTask
    @TaskId INT,
    @ErrorMessage NVARCHAR(MAX)
AS
BEGIN
    UPDATE TaskQueue
    SET Status = 'Failed',
        ErrorMessage = @ErrorMessage
    WHERE TaskId = @TaskId;
END;
GO
```

### C# Integration with SQL Task Queue

```csharp
using System.Data.SqlClient;

public class SqlTaskQueue
{
    private readonly string _connectionString;

    public SqlTaskQueue(string connectionString)
    {
        _connectionString = connectionString;
    }

    public async Task<int> EnqueueTask(string taskName, string taskPayload)
    {
        using var connection = new SqlConnection(_connectionString);
        using var command = new SqlCommand("EnqueueTask", connection);
        
        command.CommandType = System.Data.CommandType.StoredProcedure;
        command.Parameters.AddWithValue("@TaskName", taskName);
        command.Parameters.AddWithValue("@TaskPayload", taskPayload);

        await connection.OpenAsync();
        var taskId = (int)await command.ExecuteScalarAsync();
        
        return taskId;
    }

    public async Task ProcessNextTask()
    {
        using var connection = new SqlConnection(_connectionString);
        using var command = new SqlCommand("DequeueTask", connection);
        
        command.CommandType = System.Data.CommandType.StoredProcedure;

        await connection.OpenAsync();
        using var reader = await command.ExecuteReaderAsync();

        if (await reader.ReadAsync())
        {
            int taskId = reader.GetInt32(0);
            string taskName = reader.GetString(1);
            string taskPayload = reader.GetString(2);

            try
            {
                // Process task here
                Console.WriteLine($"Processing task {taskId}: {taskName}");
                
                // Mark as completed
                await CompleteTask(taskId);
            }
            catch (Exception ex)
            {
                await FailTask(taskId, ex.Message);
            }
        }
    }

    private async Task CompleteTask(int taskId)
    {
        using var connection = new SqlConnection(_connectionString);
        using var command = new SqlCommand("CompleteTask", connection);
        
        command.CommandType = System.Data.CommandType.StoredProcedure;
        command.Parameters.AddWithValue("@TaskId", taskId);

        await connection.OpenAsync();
        await command.ExecuteNonQueryAsync();
    }

    private async Task FailTask(int taskId, string errorMessage)
    {
        using var connection = new SqlConnection(_connectionString);
        using var command = new SqlCommand("FailTask", connection);
        
        command.CommandType = System.Data.CommandType.StoredProcedure;
        command.Parameters.AddWithValue("@TaskId", taskId);
        command.Parameters.AddWithValue("@ErrorMessage", errorMessage);

        await connection.OpenAsync();
        await command.ExecuteNonQueryAsync();
    }
}
```

## Key Concepts

- **Unbounded Queue**: Can continuously accept new items without a size limit
- **Async/Await**: Enables non-blocking asynchronous operations
- **Background Processing**: Tasks are processed independently of the main application flow
- **Channel Pattern**: Thread-safe producer-consumer pattern for task queuing
- **Persistent Queuing**: Using SQL Server for durable task storage across application restarts