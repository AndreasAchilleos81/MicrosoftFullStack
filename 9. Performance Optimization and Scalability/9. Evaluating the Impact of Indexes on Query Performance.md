# Measuring Index Performance: A Comprehensive Guide

## Introduction

Indexes are a powerful tool for improving database performance, but measuring their impact is essential for using them effectively. By analyzing execution time, monitoring resource usage, and reviewing query execution plans, you'll gain the skills to optimize queries and enhance the efficiency of your applications.

This guide covers how to evaluate the effectiveness of indexes by analyzing query performance metrics.

---

## Performance Metrics for Index Evaluation

### 1. Execution Time

**Execution time** refers to the total time it takes for a query to complete. This provides a performance baseline to compare improvements.

#### Key Metrics:
- **CPU Time**: Processor power used
- **Elapsed Time**: Total time taken

---

## SQL Server Examples

### Enabling Timing Statistics

```sql
-- Enable timing statistics for the session
SET STATISTICS TIME ON;
```

Once enabled, you don't need to run it with each query. It will automatically provide execution time details for every query executed after it.

### Baseline Query Example

```sql
-- Query to measure execution time
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';
```

This query retrieves all rows from the Orders table where the order date is between January 1st, 2024 and January 31st, 2024 (inclusive).

**Output will include:**
```
SQL Server parse and compile time:
   CPU time = X ms, elapsed time = Y ms.

SQL Server Execution Times:
   CPU time = X ms, elapsed time = Y ms.
```

### Creating an Index

```sql
-- Create an index on the OrderDate column
CREATE INDEX IX_OrderDate 
ON Orders(OrderDate);
```

This index improves the performance of frequent searches or filters on the `OrderDate` column.

### Rerun the Query

```sql
-- Rerun the same query after creating the index
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';
```

Compare the CPU and elapsed times before and after creating the index. Reduced CPU and memory usage indicates the index is optimizing query execution.

### Disabling Timing Statistics

```sql
-- Disable timing statistics
SET STATISTICS TIME OFF;
```

This ensures future results are not cluttered with additional timing information.

---

## 2. Resource Usage Monitoring

### Analyzing I/O Statistics

```sql
-- Enable I/O statistics
SET STATISTICS IO ON;

-- Run your query
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';

-- Disable I/O statistics
SET STATISTICS IO OFF;
```

**Output includes:**
- **Logical reads**: Number of pages read from cache
- **Physical reads**: Number of pages read from disk
- **Read-ahead reads**: Number of pages read during read-ahead operations

Lower values after indexing indicate better performance.

### Using SQL Server Activity Monitor

1. Open SQL Server Management Studio (SSMS)
2. Right-click on the server instance
3. Select **Activity Monitor**
4. Monitor the following:
   - CPU usage
   - Memory consumption
   - Disk I/O
   - Active queries

---

## 3. Query Execution Plans

### Viewing Execution Plans in SQL Server

```sql
-- Display estimated execution plan
SET SHOWPLAN_ALL ON;
GO

SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';
GO

SET SHOWPLAN_ALL OFF;
GO
```

**Or use the graphical execution plan:**
```sql
-- In SSMS, press Ctrl+M to enable actual execution plan
-- Then run your query
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';
```

### Interpreting Execution Plans

**Efficient Index Usage:**
- **Index Seek**: Database efficiently uses an index to locate specific rows
- **Key Lookup**: Database uses an index to find rows (good)
- **Clustered Index Seek**: Using clustered index efficiently

**Inefficient Patterns:**
- **Table Scan**: Database scans all rows (bad for large tables)
- **Index Scan**: Scanning entire index (may need adjustment)
- **High cost operations**: Look for operations with high percentage costs

---

## MySQL Examples

### Enabling Profiling

```sql
-- Enable profiling
SET profiling = 1;

-- Run your query
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';

-- View profiles
SHOW PROFILES;

-- View detailed profile for a specific query (e.g., query 1)
SHOW PROFILE FOR QUERY 1;

-- Disable profiling
SET profiling = 0;
```

### Creating Index in MySQL

```sql
-- Create an index on OrderDate
CREATE INDEX IX_OrderDate 
ON Orders(OrderDate);

-- Verify index creation
SHOW INDEX FROM Orders;
```

### Analyzing Execution Plan in MySQL

```sql
-- Use EXPLAIN to view execution plan
EXPLAIN SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';
```

**Key columns to examine:**
- **type**: 
  - `const` or `eq_ref` = Very efficient
  - `ref` or `range` = Using index (good)
  - `ALL` = Table scan (bad)
- **key**: Shows which index is being used
- **rows**: Estimated rows examined (lower is better)

### Using MySQL Workbench

1. Execute your query in MySQL Workbench
2. Select the **Execution Plan** tab at the bottom of the results window
3. Review the visual execution plan

**Look for:**
- **Unique Key Lookup**: Database efficiently using an index
- **Full Table Scan**: Database scanning all rows (may need index adjustment)

---

## T-SQL Complete Example

```sql
-- ============================================
-- Complete Performance Testing Script
-- ============================================

-- Create sample table
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY IDENTITY(1,1),
    OrderDate DATE NOT NULL,
    CustomerID INT NOT NULL,
    TotalAmount DECIMAL(10, 2) NOT NULL,
    Status VARCHAR(20)
);
GO

-- Insert sample data (10,000 rows)
DECLARE @Counter INT = 1;
WHILE @Counter <= 10000
BEGIN
    INSERT INTO Orders (OrderDate, CustomerID, TotalAmount, Status)
    VALUES (
        DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 365, '2024-01-01'),
        ABS(CHECKSUM(NEWID())) % 1000 + 1,
        CAST((ABS(CHECKSUM(NEWID())) % 10000) / 100.0 AS DECIMAL(10,2)),
        CASE ABS(CHECKSUM(NEWID())) % 3
            WHEN 0 THEN 'Pending'
            WHEN 1 THEN 'Completed'
            ELSE 'Cancelled'
        END
    );
    SET @Counter = @Counter + 1;
END
GO

-- ============================================
-- BEFORE INDEX - Performance Baseline
-- ============================================

-- Enable statistics
SET STATISTICS TIME ON;
SET STATISTICS IO ON;

-- Run query without index
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';

-- View execution plan
-- (Press Ctrl+M in SSMS before running the query)

-- ============================================
-- CREATE INDEX
-- ============================================

CREATE NONCLUSTERED INDEX IX_OrderDate 
ON Orders(OrderDate);
GO

-- ============================================
-- AFTER INDEX - Performance Comparison
-- ============================================

-- Run the same query with index
SELECT * 
FROM Orders 
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';

-- Disable statistics
SET STATISTICS TIME OFF;
SET STATISTICS IO OFF;

-- ============================================
-- Additional Index Analysis
-- ============================================

-- View index usage statistics
SELECT 
    i.name AS IndexName,
    s.user_seeks AS UserSeeks,
    s.user_scans AS UserScans,
    s.user_lookups AS UserLookups,
    s.user_updates AS UserUpdates
FROM 
    sys.indexes i
INNER JOIN 
    sys.dm_db_index_usage_stats s ON i.object_id = s.object_id AND i.index_id = s.index_id
WHERE 
    OBJECT_NAME(i.object_id) = 'Orders';

-- View index fragmentation
SELECT 
    i.name AS IndexName,
    ps.avg_fragmentation_in_percent,
    ps.page_count
FROM 
    sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID('Orders'), NULL, NULL, 'DETAILED') ps
INNER JOIN 
    sys.indexes i ON ps.object_id = i.object_id AND ps.index_id = i.index_id
WHERE 
    i.name IS NOT NULL;
```

---

## C# Examples

### Using ADO.NET for Performance Testing

```csharp
using System;
using System.Data.SqlClient;
using System.Diagnostics;

namespace IndexPerformanceTesting
{
    class Program
    {
        static string connectionString = "Server=localhost;Database=SalesDB;Trusted_Connection=True;";
        
        static void Main(string[] args)
        {
            Console.WriteLine("=== Index Performance Testing ===\n");
            
            // Test performance before index
            Console.WriteLine("Testing query performance BEFORE index creation:");
            TestQueryPerformance();
            
            // Create index
            Console.WriteLine("\nCreating index...");
            CreateIndex();
            
            // Test performance after index
            Console.WriteLine("\nTesting query performance AFTER index creation:");
            TestQueryPerformance();
            
            Console.WriteLine("\nPress any key to exit...");
            Console.ReadKey();
        }
        
        static void TestQueryPerformance()
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                
                // Enable statistics
                EnableStatistics(connection);
                
                string query = @"
                    SELECT * 
                    FROM Orders 
                    WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31'";
                
                Stopwatch stopwatch = new Stopwatch();
                stopwatch.Start();
                
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        int rowCount = 0;
                        while (reader.Read())
                        {
                            rowCount++;
                        }
                        
                        stopwatch.Stop();
                        
                        Console.WriteLine($"Rows returned: {rowCount}");
                        Console.WriteLine($"Execution time: {stopwatch.ElapsedMilliseconds} ms");
                    }
                }
                
                // Get statistics
                GetStatistics(connection);
                
                // Disable statistics
                DisableStatistics(connection);
            }
        }
        
        static void CreateIndex()
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                
                string createIndexQuery = @"
                    CREATE NONCLUSTERED INDEX IX_OrderDate 
                    ON Orders(OrderDate)";
                
                using (SqlCommand command = new SqlCommand(createIndexQuery, connection))
                {
                    try
                    {
                        command.ExecuteNonQuery();
                        Console.WriteLine("Index IX_OrderDate created successfully.");
                    }
                    catch (SqlException ex)
                    {
                        if (ex.Message.Contains("already exists"))
                        {
                            Console.WriteLine("Index already exists.");
                        }
                        else
                        {
                            Console.WriteLine($"Error creating index: {ex.Message}");
                        }
                    }
                }
            }
        }
        
        static void EnableStatistics(SqlConnection connection)
        {
            ExecuteNonQuery(connection, "SET STATISTICS TIME ON");
            ExecuteNonQuery(connection, "SET STATISTICS IO ON");
        }
        
        static void DisableStatistics(SqlConnection connection)
        {
            ExecuteNonQuery(connection, "SET STATISTICS TIME OFF");
            ExecuteNonQuery(connection, "SET STATISTICS IO OFF");
        }
        
        static void GetStatistics(SqlConnection connection)
        {
            // Statistics are output to SQL Server Messages
            // In production, you would capture these using SqlConnection.InfoMessage event
            connection.InfoMessage += (sender, e) => 
            {
                Console.WriteLine(e.Message);
            };
        }
        
        static void ExecuteNonQuery(SqlConnection connection, string query)
        {
            using (SqlCommand command = new SqlCommand(query, connection))
            {
                command.ExecuteNonQuery();
            }
        }
    }
}
```

### Entity Framework Core Performance Testing

```csharp
using System;
using System.Diagnostics;
using System.Linq;
using Microsoft.EntityFrameworkCore;

namespace EFIndexPerformance
{
    // Entity classes
    public class Order
    {
        public int OrderID { get; set; }
        public DateTime OrderDate { get; set; }
        public int CustomerID { get; set; }
        public decimal TotalAmount { get; set; }
        public string Status { get; set; }
    }
    
    public class SalesContext : DbContext
    {
        public DbSet<Order> Orders { get; set; }
        
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer(
                "Server=localhost;Database=SalesDB;Trusted_Connection=True;");
            
            // Enable detailed query logging
            optionsBuilder.LogTo(Console.WriteLine, Microsoft.Extensions.Logging.LogLevel.Information);
        }
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure index on OrderDate
            modelBuilder.Entity<Order>()
                .HasIndex(o => o.OrderDate)
                .HasDatabaseName("IX_OrderDate");
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("=== EF Core Index Performance Testing ===\n");
            
            // Ensure database is created with indexes
            using (var context = new SalesContext())
            {
                context.Database.EnsureCreated();
            }
            
            // Test query performance
            MeasureQueryPerformance();
            
            // Analyze execution plan
            AnalyzeExecutionPlan();
            
            Console.WriteLine("\nPress any key to exit...");
            Console.ReadKey();
        }
        
        static void MeasureQueryPerformance()
        {
            using (var context = new SalesContext())
            {
                var startDate = new DateTime(2024, 1, 1);
                var endDate = new DateTime(2024, 1, 31);
                
                var stopwatch = new Stopwatch();
                stopwatch.Start();
                
                var orders = context.Orders
                    .Where(o => o.OrderDate >= startDate && o.OrderDate <= endDate)
                    .ToList();
                
                stopwatch.Stop();
                
                Console.WriteLine($"\nQuery Results:");
                Console.WriteLine($"Records returned: {orders.Count}");
                Console.WriteLine($"Execution time: {stopwatch.ElapsedMilliseconds} ms");
                Console.WriteLine($"Memory used: ~{GC.GetTotalMemory(false) / 1024} KB");
            }
        }
        
        static void AnalyzeExecutionPlan()
        {
            using (var context = new SalesContext())
            {
                var startDate = new DateTime(2024, 1, 1);
                var endDate = new DateTime(2024, 1, 31);
                
                // Get the generated SQL query
                var query = context.Orders
                    .Where(o => o.OrderDate >= startDate && o.OrderDate <= endDate);
                
                var sql = query.ToQueryString();
                
                Console.WriteLine("\n=== Generated SQL Query ===");
                Console.WriteLine(sql);
                Console.WriteLine("\nNote: View actual execution plan in SQL Server Management Studio");
            }
        }
    }
}
```

### Advanced Performance Monitoring Class

```csharp
using System;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Collections.Generic;

namespace AdvancedIndexMonitoring
{
    public class IndexPerformanceMonitor
    {
        private readonly string _connectionString;
        
        public IndexPerformanceMonitor(string connectionString)
        {
            _connectionString = connectionString;
        }
        
        public PerformanceMetrics MeasureQuery(string query, Dictionary<string, object> parameters = null)
        {
            var metrics = new PerformanceMetrics();
            
            using (SqlConnection connection = new SqlConnection(_connectionString))
            {
                connection.Open();
                
                // Capture statistics
                connection.InfoMessage += (sender, e) => 
                {
                    metrics.Messages.Add(e.Message);
                };
                
                // Enable statistics
                ExecuteNonQuery(connection, "SET STATISTICS TIME ON");
                ExecuteNonQuery(connection, "SET STATISTICS IO ON");
                
                var stopwatch = Stopwatch.StartNew();
                
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    if (parameters != null)
                    {
                        foreach (var param in parameters)
                        {
                            command.Parameters.AddWithValue(param.Key, param.Value);
                        }
                    }
                    
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            metrics.RowCount++;
                        }
                    }
                }
                
                stopwatch.Stop();
                metrics.ElapsedMilliseconds = stopwatch.ElapsedMilliseconds;
                
                // Disable statistics
                ExecuteNonQuery(connection, "SET STATISTICS TIME OFF");
                ExecuteNonQuery(connection, "SET STATISTICS IO OFF");
            }
            
            return metrics;
        }
        
        public IndexUsageStats GetIndexUsageStats(string tableName)
        {
            var stats = new IndexUsageStats();
            
            using (SqlConnection connection = new SqlConnection(_connectionString))
            {
                connection.Open();
                
                string query = @"
                    SELECT 
                        i.name AS IndexName,
                        s.user_seeks AS UserSeeks,
                        s.user_scans AS UserScans,
                        s.user_lookups AS UserLookups,
                        s.user_updates AS UserUpdates,
                        s.last_user_seek AS LastUserSeek,
                        s.last_user_scan AS LastUserScan
                    FROM sys.indexes i
                    LEFT JOIN sys.dm_db_index_usage_stats s 
                        ON i.object_id = s.object_id AND i.index_id = s.index_id
                    WHERE OBJECT_NAME(i.object_id) = @TableName
                        AND i.name IS NOT NULL";
                
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@TableName", tableName);
                    
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            stats.Indexes.Add(new IndexInfo
                            {
                                Name = reader["IndexName"].ToString(),
                                UserSeeks = reader["UserSeeks"] != DBNull.Value ? (long)reader["UserSeeks"] : 0,
                                UserScans = reader["UserScans"] != DBNull.Value ? (long)reader["UserScans"] : 0,
                                UserLookups = reader["UserLookups"] != DBNull.Value ? (long)reader["UserLookups"] : 0,
                                UserUpdates = reader["UserUpdates"] != DBNull.Value ? (long)reader["UserUpdates"] : 0
                            });
                        }
                    }
                }
            }
            
            return stats;
        }
        
        private void ExecuteNonQuery(SqlConnection connection, string query)
        {
            using (SqlCommand command = new SqlCommand(query, connection))
            {
                command.ExecuteNonQuery();
            }
        }
    }
    
    public class PerformanceMetrics
    {
        public long ElapsedMilliseconds { get; set; }
        public int RowCount { get; set; }
        public List<string> Messages { get; set; } = new List<string>();
        
        public void PrintSummary()
        {
            Console.WriteLine($"Execution Time: {ElapsedMilliseconds} ms");
            Console.WriteLine($"Rows Returned: {RowCount}");
            
            if (Messages.Count > 0)
            {
                Console.WriteLine("\nSQL Server Statistics:");
                foreach (var message in Messages)
                {
                    Console.WriteLine(message);
                }
            }
        }
    }
    
    public class IndexUsageStats
    {
        public List<IndexInfo> Indexes { get; set; } = new List<IndexInfo>();
        
        public void PrintReport()
        {
            Console.WriteLine("\n=== Index Usage Report ===\n");
            
            foreach (var index in Indexes)
            {
                Console.WriteLine($"Index: {index.Name}");
                Console.WriteLine($"  Seeks: {index.UserSeeks}");
                Console.WriteLine($"  Scans: {index.UserScans}");
                Console.WriteLine($"  Lookups: {index.UserLookups}");
                Console.WriteLine($"  Updates: {index.UserUpdates}");
                Console.WriteLine($"  Efficiency: {index.CalculateEfficiency():P2}");
                Console.WriteLine();
            }
        }
    }
    
    public class IndexInfo
    {
        public string Name { get; set; }
        public long UserSeeks { get; set; }
        public long UserScans { get; set; }
        public long UserLookups { get; set; }
        public long UserUpdates { get; set; }
        
        public double CalculateEfficiency()
        {
            long totalReads = UserSeeks + UserScans + UserLookups;
            long totalOperations = totalReads + UserUpdates;
            
            return totalOperations > 0 ? (double)totalReads / totalOperations : 0;
        }
    }
    
    // Usage Example
    class Program
    {
        static void Main(string[] args)
        {
            string connectionString = "Server=localhost;Database=SalesDB;Trusted_Connection=True;";
            var monitor = new IndexPerformanceMonitor(connectionString);
            
            // Measure query performance
            Console.WriteLine("=== Measuring Query Performance ===");
            var metrics = monitor.MeasureQuery(
                "SELECT * FROM Orders WHERE OrderDate BETWEEN @StartDate AND @EndDate",
                new Dictionary<string, object>
                {
                    { "@StartDate", new DateTime(2024, 1, 1) },
                    { "@EndDate", new DateTime(2024, 1, 31) }
                }
            );
            metrics.PrintSummary();
            
            // Get index usage statistics
            var indexStats = monitor.GetIndexUsageStats("Orders");
            indexStats.PrintReport();
        }
    }
}
```

---

## Best Practices Summary

1. **Always measure before and after** creating indexes
2. **Use multiple metrics**: execution time, I/O statistics, CPU usage
3. **Review execution plans** to verify index usage
4. **Monitor regularly** as data volume grows
5. **Consider the cost** of index maintenance vs. query improvement
6. **Drop unused indexes** to reduce overhead
7. **Test with realistic data volumes** for accurate results

## Key Takeaways

- Execution time provides a baseline for performance comparison
- Resource usage (CPU, memory, I/O) indicates optimization effectiveness
- Query execution plans reveal whether indexes are being used efficiently
- Continuous monitoring helps refine indexing strategies over time

```
ctrl + l to clear the Linux command line of mysql

CREATE TABLE ORDERS(
	OrderID INT AUTO_INCREMENT Primary KEY ,
	OrderDate DateTime,
	CustomerID INT,
	TotalAmount DECIMAL
);



DELIMITER $$

CREATE PROCEDURE PopulateOrders()
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= 3000 DO
        INSERT INTO ORDERS (OrderDate, CustomerID, TotalAmount)
        VALUES (
            DATE_ADD('2024-01-01', INTERVAL FLOOR(RAND() * 90) DAY), -- Random date in Quarter 1 2024
            FLOOR(RAND() * 100) + 1, -- Random CustomerID between 1 and 100
            ROUND(RAND() * 1000, 2) -- Random TotalAmount between 0 and 1000
        );
        SET i = i + 1;
    END WHILE;
END $$

DELIMITER ;

CALL PopulateOrders();


Enable time statistics

SET PROFILING = 1;

run query

SHOW PROFILES;

EXPLAIN QUERY ;  

Crete index:
CREATE INDEX idx_order_date ON ORDERS(OrderDate);

Run query

SHOW PROFILES;

EXPLAIN QUERY;


EXPLAIN SELECT * FROM ORDERS WHERE OrderDate BETWEEN '2024-02-01' AND '2024-02-15' AND TotalAmount > 500;
Look for terms like "range" or "ref" in the type column, which indicate index usage.


 DROP INDEX idx_order_date ON ORDERS;


----------------------------------------------------------------------------------------------------

Create two indexes for two columns on the table

CREATE INDEX idx_order_date ON ORDERS(OrderDate);

CREATE INDEX idx_customer_id ON ORDERS(CustomerID);

Create duplicate indexes:

CREATE INDEX idx_order_date_total ON ORDERS(OrderDate, TotalAmount);

CREATE TABLE Products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    price DECIMAL(10,2)
);

CREATE TABLE Customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100)
);

CREATE TABLE Orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);

CREATE TABLE Sales (
    sale_id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT,
    quantity INT,
    FOREIGN KEY (product_id) REFERENCES Products(product_id)
);


INSERT INTO Products (name, price) VALUES 
('Laptop', 1200.00),
('Smartphone', 800.00),
('Headphones', 150.00),
('Tablet', 500.00);

INSERT INTO Customers (name) VALUES 
('Alice Johnson'),
('Bob Smith'),
('Charlie Brown');

INSERT INTO Orders (customer_id, order_date) VALUES 
(1, '2024-01-01'),
(2, '2024-01-02'),
(3, '2024-01-03');

INSERT INTO Sales (product_id, quantity) VALUES 
(1, 2),
(2, 1),
(3, 5),
(4, 3);



SELECT Orders.order_id, Customers.name 
FROM Orders 
JOIN Customers ON Orders.customer_id = Customers.customer_id;

Optimized Query
CREATE INDEX idx_customer_id ON Orders (customer_id);


CREATE TEMPORARY TABLE tempt_sales AS SELECT * FROM Sales WHERE quantity > 3;
SELECT AVG(quantity) FROM tempt_sales;



SELECT * FROM Products WHERE product_id IN(SELECT product_id FROM Sales WHERE quantity > 3);

SELECT Products.* FROM Products JOIN Sales ON Products.product_id = Sales.product_id WHERE Sales.quantity > 3;

```
