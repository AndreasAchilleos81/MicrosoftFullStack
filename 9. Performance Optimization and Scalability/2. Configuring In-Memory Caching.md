# In-Memory Caching with IMemoryCache

## Introduction

In this guide, we'll demonstrate how to configure in-memory caching using `IMemoryCache` in a C# application. In-memory caching is an effective way to store frequently accessed data temporarily in memory, reducing the need for repeated database queries or API calls.

## Setup and Configuration

### Required Package

First, you need to install the `Microsoft.Extensions.Caching.Memory` package:

```bash
dotnet add package Microsoft.Extensions.Caching.Memory
```

### Basic Implementation

```csharp
using Microsoft.Extensions.Caching.Memory;
using System;
using System.Collections.Generic;
using System.Threading;

class Program
{
    static void Main(string[] args)
    {
        // Create an IMemoryCache instance with options
        var cache = new MemoryCache(new MemoryCacheOptions
        {
            SizeLimit = 1024
        });

        // Define the cache key
        string key = "user_profiles";

        // Demonstrate cache operations through iterations
        for (int i = 0; i < 3; i++)
        {
            Console.WriteLine($"\n--- Iteration {i + 1} ---");

            // Try to get data from cache
            if (!cache.TryGetValue(key, out List<string> users))
            {
                // Cache miss - data doesn't exist in cache
                Console.WriteLine("Cache miss! Fetching user profiles from data source...");

                // Simulate fetching data from database or API
                users = FetchUserProfiles();

                // Store data in cache with options
                var cacheEntryOptions = new MemoryCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(30),
                    Size = 1
                };

                cache.Set(key, users, cacheEntryOptions);
                Console.WriteLine("User profiles were added to the cache.");
            }
            else
            {
                // Cache hit - data retrieved from cache
                Console.WriteLine("Cache hit! Retrieved data from the cache.");
            }

            // Display the cached data
            Console.WriteLine($"Cache data: {string.Join(", ", users)}");

            // Check if cache still exists
            if (cache.TryGetValue(key, out _))
            {
                Console.WriteLine("Cache exists.");
            }
            else
            {
                Console.WriteLine("Cache was cleared.");
            }

            // Simulate delay between iterations
            Thread.Sleep(3000);
        }

        // Remove data from cache
        cache.Remove(key);
        Console.WriteLine("\nRemoving the cache data...");
        Console.WriteLine("Cache data removed.");
    }

    // Simulates fetching data from a database or API
    static List<string> FetchUserProfiles()
    {
        return new List<string> { "Alice", "Bob", "Charlie" };
    }
}
```

## Key Concepts

### 1. Cache Configuration

The `MemoryCache` is created with specific options:

```csharp
var cache = new MemoryCache(new MemoryCacheOptions
{
    SizeLimit = 1024  // Maximum size of the cache
});
```

### 2. Cache Key

A unique identifier is used to store and retrieve data:

```csharp
string key = "user_profiles";
```

### 3. Cache Operations

#### Retrieving from Cache

```csharp
if (!cache.TryGetValue(key, out List<string> users))
{
    // Cache miss - data not found
    // Fetch and store data
}
else
{
    // Cache hit - data retrieved successfully
    // Use cached data
}
```

#### Storing in Cache

```csharp
var cacheEntryOptions = new MemoryCacheEntryOptions
{
    AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(30),
    Size = 1
};

cache.Set(key, users, cacheEntryOptions);
```

#### Removing from Cache

```csharp
cache.Remove(key);
```

## Advanced Examples

### Example 1: Service-Based Caching Pattern

```csharp
using Microsoft.Extensions.Caching.Memory;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

public class UserService
{
    private readonly IMemoryCache _cache;
    private readonly IUserRepository _repository;

    public UserService(IMemoryCache cache, IUserRepository repository)
    {
        _cache = cache;
        _repository = repository;
    }

    public async Task<User> GetUserByIdAsync(int userId)
    {
        string cacheKey = $"user_{userId}";

        // Try to get user from cache
        if (!_cache.TryGetValue(cacheKey, out User user))
        {
            // Cache miss - fetch from database
            user = await _repository.GetByIdAsync(userId);

            if (user != null)
            {
                // Set cache options
                var cacheOptions = new MemoryCacheEntryOptions()
                    .SetAbsoluteExpiration(TimeSpan.FromMinutes(10))
                    .SetSlidingExpiration(TimeSpan.FromMinutes(2))
                    .SetPriority(CacheItemPriority.Normal)
                    .SetSize(1);

                // Save to cache
                _cache.Set(cacheKey, user, cacheOptions);
            }
        }

        return user;
    }

    public void InvalidateUserCache(int userId)
    {
        string cacheKey = $"user_{userId}";
        _cache.Remove(cacheKey);
    }
}
```

### Example 2: Cache with Callback on Eviction

```csharp
using Microsoft.Extensions.Caching.Memory;
using System;

public class ProductCacheService
{
    private readonly IMemoryCache _cache;

    public ProductCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public void CacheProduct(Product product)
    {
        string cacheKey = $"product_{product.Id}";

        var cacheOptions = new MemoryCacheEntryOptions()
            .SetAbsoluteExpiration(TimeSpan.FromMinutes(30))
            .RegisterPostEvictionCallback((key, value, reason, state) =>
            {
                Console.WriteLine($"Cache entry '{key}' was evicted. Reason: {reason}");
            });

        _cache.Set(cacheKey, product, cacheOptions);
    }

    public Product GetProduct(int productId)
    {
        string cacheKey = $"product_{productId}";
        
        if (_cache.TryGetValue(cacheKey, out Product product))
        {
            return product;
        }

        return null;
    }
}
```

### Example 3: GetOrCreate Pattern

```csharp
using Microsoft.Extensions.Caching.Memory;
using System;
using System.Threading.Tasks;

public class OrderService
{
    private readonly IMemoryCache _cache;
    private readonly IOrderRepository _repository;

    public OrderService(IMemoryCache cache, IOrderRepository repository)
    {
        _cache = cache;
        _repository = repository;
    }

    public async Task<Order> GetOrderAsync(int orderId)
    {
        string cacheKey = $"order_{orderId}";

        // GetOrCreateAsync automatically handles cache miss
        return await _cache.GetOrCreateAsync(cacheKey, async entry =>
        {
            // Set cache options
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15);
            entry.SetPriority(CacheItemPriority.High);

            // This code only runs on cache miss
            Console.WriteLine($"Cache miss for order {orderId}. Fetching from database...");
            return await _repository.GetOrderByIdAsync(orderId);
        });
    }
}
```

### Example 4: Dependency Injection Setup in ASP.NET Core

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Caching.Memory;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Add memory cache service
        services.AddMemoryCache(options =>
        {
            options.SizeLimit = 1024;
            options.CompactionPercentage = 0.75;
            options.ExpirationScanFrequency = TimeSpan.FromMinutes(5);
        });

        // Register services that use caching
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<UserService>();
        services.AddScoped<ProductCacheService>();
        services.AddScoped<OrderService>();

        services.AddControllers();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseRouting();
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
```

### Example 5: Controller Using Cached Service

```csharp
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly UserService _userService;

    public UsersController(UserService userService)
    {
        _userService = userService;
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetUser(int id)
    {
        var user = await _userService.GetUserByIdAsync(id);

        if (user == null)
            return NotFound();

        return Ok(user);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateUser(int id, [FromBody] User updatedUser)
    {
        // Update user logic here
        
        // Invalidate cache after update
        _userService.InvalidateUserCache(id);

        return Ok();
    }
}
```

## Cache Expiration Options

### Absolute Expiration

```csharp
var options = new MemoryCacheEntryOptions()
    .SetAbsoluteExpiration(TimeSpan.FromMinutes(10));
// Cache expires exactly 10 minutes after creation
```

### Sliding Expiration

```csharp
var options = new MemoryCacheEntryOptions()
    .SetSlidingExpiration(TimeSpan.FromMinutes(5));
// Cache expires 5 minutes after last access
```

### Combined Expiration

```csharp
var options = new MemoryCacheEntryOptions()
    .SetAbsoluteExpiration(TimeSpan.FromHours(1))
    .SetSlidingExpiration(TimeSpan.FromMinutes(10));
// Expires either 1 hour after creation OR 10 minutes after last access
```

## Expected Output

When running the console application, you'll see output similar to:

```
--- Iteration 1 ---
Cache miss! Fetching user profiles from data source...
User profiles were added to the cache.
Cache data: Alice, Bob, Charlie
Cache exists.

--- Iteration 2 ---
Cache hit! Retrieved data from the cache.
Cache data: Alice, Bob, Charlie
Cache exists.

--- Iteration 3 ---
Cache hit! Retrieved data from the cache.
Cache data: Alice, Bob, Charlie
Cache exists.

Removing the cache data...
Cache data removed.
```

## Best Practices

### 1. Use Caching for Static or Rarely Changed Data

Caches are optimal when you don't update data very often. This can be significantly faster than making API calls or retrieving data from a database.

### 2. Set Appropriate Expiration Times

```csharp
// For frequently changing data
.SetAbsoluteExpiration(TimeSpan.FromSeconds(30))

// For relatively static data
.SetAbsoluteExpiration(TimeSpan.FromHours(1))
```

### 3. Consider Cache Size Limits

```csharp
var cache = new MemoryCache(new MemoryCacheOptions
{
    SizeLimit = 1024,
    CompactionPercentage = 0.75  // Remove 25% of cache when limit reached
});
```

### 4. Invalidate Cache on Updates

```csharp
public async Task UpdateUserAsync(User user)
{
    await _repository.UpdateAsync(user);
    
    // Remove from cache to ensure fresh data on next request
    _cache.Remove($"user_{user.Id}");
}
```

## Performance Benefits

In a real-world scenario, caching can greatly improve application performance by:

- **Reducing database load**: Fewer queries to the database
- **Faster response times**: Data retrieved from memory instead of disk
- **Lower API costs**: Fewer external API calls
- **Better scalability**: Handling more requests with the same resources

## When to Use In-Memory Caching

- User session data
- Configuration settings
- Lookup tables and reference data
- Frequently accessed reports or analytics
- API response data that doesn't change often
- Computed results that are expensive to generate

## Conclusion

In-memory caching with `IMemoryCache` is a powerful tool for improving application performance. By storing frequently accessed data in memory temporarily, you can reduce the load on your databases and external services while providing faster response times to users. The key is to identify data that is accessed frequently but doesn't change often, and apply appropriate expiration policies to ensure data freshness.