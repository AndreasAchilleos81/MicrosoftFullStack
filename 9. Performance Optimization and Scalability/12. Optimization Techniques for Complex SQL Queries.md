# Query Optimization Techniques Guide

## Introduction

Are your queries working as hard as they should, or are they costing you valuable performance? By replacing subqueries, leveraging indexes, and optimizing joins, you can streamline database operations. These small changes can lead to faster queries, cleaner code, and more efficient systems.

In this guide, we'll demonstrate query optimization techniques, such as rewriting queries, adding indexes, and adjusting joins.

---

## SQL Query Optimization Techniques

### 1. Rewriting Queries for Simplicity

Rewriting queries enhances performance and reduces server strain, providing users with a smoother experience. In many situations, this involves rewriting or removing subqueries.

#### Understanding Subqueries

**Subqueries** (also known as inner queries or nested queries) are SQL queries embedded within another SQL query. They are used to perform intermediate calculations or fetch specific data needed by the main or outer query.

Subqueries, while functional, require extra computation, whereas a properly structured WHERE clause often achieves the same result more effectively.

#### Problem: Inefficient Subquery

**T-SQL Example:**
```sql
-- Inefficient: Subquery processed separately
SELECT *
FROM Orders o
WHERE o.OrderID IN (
    SELECT OrderID
    FROM Sales
    WHERE SalesDate > '2023-01-01'
);
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT *
        FROM Orders o
        WHERE o.OrderID IN (
            SELECT OrderID
            FROM Sales
            WHERE SalesDate > @StartDate
        )", connection);
    
    command.Parameters.AddWithValue("@StartDate", new DateTime(2023, 1, 1));
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    while (reader.Read())
    {
        var orderId = reader.GetInt32(reader.GetOrdinal("OrderID"));
        Console.WriteLine($"Order ID: {orderId}");
    }
}
```

#### Solution: Direct Filtering with WHERE Clause

**T-SQL Example:**
```sql
-- Efficient: Direct filtering without subquery
SELECT o.*
FROM Orders o
WHERE o.SalesDate > '2023-01-01';
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT o.*
        FROM Orders o
        WHERE o.SalesDate > @StartDate", 
        connection);
    
    command.Parameters.AddWithValue("@StartDate", new DateTime(2023, 1, 1));
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    while (reader.Read())
    {
        var orderId = reader.GetInt32(reader.GetOrdinal("OrderID"));
        var salesDate = reader.GetDateTime(reader.GetOrdinal("SalesDate"));
        Console.WriteLine($"Order ID: {orderId}, Date: {salesDate:yyyy-MM-dd}");
    }
}
```

> **Note:** Eliminating the need for a subquery improves readability and performance, making the filtering process more efficient.

---

### 2. Using Indexes Effectively

Making sure that you are using indexes effectively is another technique to optimize your queries.

#### Creating an Index

**T-SQL Example:**
```sql
-- Create an index on the ProductName column
CREATE INDEX IDX_ProductName ON Products(ProductName);

-- Now queries searching by ProductName will be faster
SELECT *
FROM Products
WHERE ProductName = 'Laptop';
```

**C# Example:**
```csharp
// Create index
using (var connection = new SqlConnection(connectionString))
{
    var createIndexCommand = new SqlCommand(
        "CREATE INDEX IDX_ProductName ON Products(ProductName)", 
        connection);
    
    connection.Open();
    createIndexCommand.ExecuteNonQuery();
    
    Console.WriteLine("Index created successfully on ProductName column");
}

// Execute optimized query using the index
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT *
        FROM Products
        WHERE ProductName = @ProductName", 
        connection);
    
    command.Parameters.AddWithValue("@ProductName", "Laptop");
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    while (reader.Read())
    {
        var productId = reader.GetInt32(reader.GetOrdinal("ProductID"));
        var productName = reader.GetString(reader.GetOrdinal("ProductName"));
        Console.WriteLine($"Product: {productId} - {productName}");
    }
}
```

#### Composite Index Example

**T-SQL Example:**
```sql
-- Create a composite index on multiple columns
CREATE INDEX IDX_Category_Price ON Products(Category, Price);

-- Queries filtering by both columns benefit from this index
SELECT *
FROM Products
WHERE Category = 'Electronics' AND Price > 500;
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    // Create composite index
    var createIndexCommand = new SqlCommand(
        "CREATE INDEX IDX_Category_Price ON Products(Category, Price)", 
        connection);
    connection.Open();
    createIndexCommand.ExecuteNonQuery();
}

// Query using composite index
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT *
        FROM Products
        WHERE Category = @Category AND Price > @MinPrice", 
        connection);
    
    command.Parameters.AddWithValue("@Category", "Electronics");
    command.Parameters.AddWithValue("@MinPrice", 500);
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    while (reader.Read())
    {
        var productName = reader.GetString(reader.GetOrdinal("ProductName"));
        var price = reader.GetDecimal(reader.GetOrdinal("Price"));
        Console.WriteLine($"{productName}: ${price}");
    }
}
```

> **Note:** Enabling direct searches with the CREATE INDEX statement significantly accelerates searches and avoids scanning the entire table, enhancing query performance.

---

### 3. Avoiding Temporary Tables - Use CTEs Instead

Temporary tables slow down performance by consuming extra memory. To solve this issue, we use Common Table Expressions (CTEs).

#### Understanding CTEs

**Common Table Expressions (CTEs)** are temporary result sets in SQL that you can define within a query and reference multiple times in that same query. They improve code readability and modularity, especially for complex queries, by allowing you to create named reusable subqueries.

#### Problem: Using Temporary Tables

**T-SQL Example:**
```sql
-- Inefficient: Using temporary table
CREATE TABLE #SalesSummary (
    TotalSales DECIMAL(18,2)
);

INSERT INTO #SalesSummary
SELECT SUM(Amount) AS TotalSales
FROM Sales;

SELECT TotalSales
FROM #SalesSummary;

DROP TABLE #SalesSummary;
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    connection.Open();
    
    // Create temporary table
    var createTemp = new SqlCommand(@"
        CREATE TABLE #SalesSummary (
            TotalSales DECIMAL(18,2)
        );
        
        INSERT INTO #SalesSummary
        SELECT SUM(Amount) AS TotalSales
        FROM Sales;", connection);
    createTemp.ExecuteNonQuery();
    
    // Query temporary table
    var queryTemp = new SqlCommand(
        "SELECT TotalSales FROM #SalesSummary", 
        connection);
    var totalSales = (decimal)queryTemp.ExecuteScalar();
    
    Console.WriteLine($"Total Sales: ${totalSales:N2}");
    
    // Clean up
    var dropTemp = new SqlCommand("DROP TABLE #SalesSummary", connection);
    dropTemp.ExecuteNonQuery();
}
```

#### Solution: Using Common Table Expressions (CTEs)

**T-SQL Example:**
```sql
-- Efficient: Using CTE
WITH SalesSummary AS (
    SELECT SUM(Amount) AS TotalSales
    FROM Sales
)
SELECT TotalSales
FROM SalesSummary;
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        WITH SalesSummary AS (
            SELECT SUM(Amount) AS TotalSales
            FROM Sales
        )
        SELECT TotalSales
        FROM SalesSummary", 
        connection);
    
    connection.Open();
    var totalSales = (decimal)command.ExecuteScalar();
    
    Console.WriteLine($"Total Sales: ${totalSales:N2}");
}
```

> **Note:** The CTE acts as a temporary result set that exists only during the query execution, avoiding the overhead of creating a temporary table and making the query more efficient and readable.
When to Use CTEs vs Temp Tables:
Use CTEs when:

Referenced only once in the query
Used for code readability/organization
Query is simple and fast
Building recursive queries

Use Temp Tables when:

Referenced multiple times
Expensive computation (aggregations, complex joins)
Need to index the intermediate results
Working with large datasets

#### Advanced CTE Example: Multiple CTEs

**T-SQL Example:**
```sql
-- Using multiple CTEs for complex analysis
WITH SalesByRegion AS (
    SELECT Region, SUM(Amount) AS RegionTotal
    FROM Sales
    GROUP BY Region
),
TopRegions AS (
    SELECT Region, RegionTotal
    FROM SalesByRegion
    WHERE RegionTotal > 10000
)
SELECT Region, RegionTotal, 
       RegionTotal * 100.0 / (SELECT SUM(RegionTotal) FROM TopRegions) AS PercentageOfTop
FROM TopRegions
ORDER BY RegionTotal DESC;
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        WITH SalesByRegion AS (
            SELECT Region, SUM(Amount) AS RegionTotal
            FROM Sales
            GROUP BY Region
        ),
        TopRegions AS (
            SELECT Region, RegionTotal
            FROM SalesByRegion
            WHERE RegionTotal > @MinTotal
        )
        SELECT Region, RegionTotal, 
               RegionTotal * 100.0 / (SELECT SUM(RegionTotal) FROM TopRegions) AS PercentageOfTop
        FROM TopRegions
        ORDER BY RegionTotal DESC", 
        connection);
    
    command.Parameters.AddWithValue("@MinTotal", 10000);
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    Console.WriteLine("Top Performing Regions:");
    Console.WriteLine("Region\t\tTotal Sales\tPercentage");
    Console.WriteLine(new string('-', 50));
    
    while (reader.Read())
    {
        var region = reader.GetString(0);
        var total = reader.GetDecimal(1);
        var percentage = reader.GetDecimal(2);
        Console.WriteLine($"{region}\t${total:N2}\t{percentage:F2}%");
    }
}
```

---

### 4. Optimizing Joins

Joins are essential for combining data from multiple tables, but they can be resource-intensive when dealing with large datasets. Filtering data before joining can significantly improve performance.

#### Problem: Unfiltered Join

**T-SQL Example:**
```sql
-- Less efficient: Join first, filter later
SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.IsActive = 1;
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerID = o.CustomerID
        WHERE c.IsActive = @IsActive", 
        connection);
    
    command.Parameters.AddWithValue("@IsActive", 1);
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    while (reader.Read())
    {
        var customerId = reader.GetInt32(0);
        var name = reader.GetString(1);
        var orderId = reader.GetInt32(2);
        var orderDate = reader.GetDateTime(3);
        
        Console.WriteLine($"Customer: {name} (ID: {customerId}) - Order: {orderId}, Date: {orderDate:yyyy-MM-dd}");
    }
}
```

#### Solution: Filter Before Join (Using Aliases)

**T-SQL Example:**
```sql
-- More efficient: Filter active customers before join
SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.IsActive = 1;

-- Alternative: Using subquery to pre-filter
SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
FROM (
    SELECT CustomerID, Name
    FROM Customers
    WHERE IsActive = 1
) c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID;
```

**C# Example:**
```csharp
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerID = o.CustomerID
        WHERE c.IsActive = @IsActive", 
        connection);
    
    command.Parameters.AddWithValue("@IsActive", 1);
    
    connection.Open();
    
    var orders = new List<(int CustomerId, string CustomerName, int OrderId, DateTime OrderDate)>();
    
    using (var reader = command.ExecuteReader())
    {
        while (reader.Read())
        {
            orders.Add((
                reader.GetInt32(0),
                reader.GetString(1),
                reader.GetInt32(2),
                reader.GetDateTime(3)
            ));
        }
    }
    
    Console.WriteLine($"Retrieved {orders.Count} orders from active customers");
    foreach (var order in orders)
    {
        Console.WriteLine($"{order.CustomerName} - Order #{order.OrderId} on {order.OrderDate:yyyy-MM-dd}");
    }
}
```

> **Note:** The WHERE clause filters active customers before performing the join, reducing the dataset size and improving the query's overall efficiency.

#### Advanced Join Optimization with Indexes

**T-SQL Example:**
```sql
-- Create indexes on join columns
CREATE INDEX IDX_CustomerID ON Orders(CustomerID);
CREATE INDEX IDX_IsActive_CustomerID ON Customers(IsActive, CustomerID);

-- Optimized query with proper indexes
SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate, o.TotalAmount
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.IsActive = 1
ORDER BY o.OrderDate DESC;
```

**C# Example:**
```csharp
// Create indexes for optimal join performance
using (var connection = new SqlConnection(connectionString))
{
    connection.Open();
    
    var createIndexes = new SqlCommand(@"
        CREATE INDEX IDX_CustomerID ON Orders(CustomerID);
        CREATE INDEX IDX_IsActive_CustomerID ON Customers(IsActive, CustomerID);", 
        connection);
    
    createIndexes.ExecuteNonQuery();
    Console.WriteLine("Indexes created for optimized joins");
}

// Execute optimized join query
using (var connection = new SqlConnection(connectionString))
{
    var command = new SqlCommand(@"
        SELECT c.CustomerID, c.Name, o.OrderID, o.OrderDate, o.TotalAmount
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerID = o.CustomerID
        WHERE c.IsActive = @IsActive
        ORDER BY o.OrderDate DESC", 
        connection);
    
    command.Parameters.AddWithValue("@IsActive", 1);
    
    connection.Open();
    var reader = command.ExecuteReader();
    
    var orderCount = 0;
    while (reader.Read())
    {
        var customerName = reader.GetString(1);
        var orderId = reader.GetInt32(2);
        var orderDate = reader.GetDateTime(3);
        var totalAmount = reader.GetDecimal(4);
        
        Console.WriteLine($"{customerName} - Order #{orderId}: ${totalAmount:N2} on {orderDate:yyyy-MM-dd}");
        orderCount++;
    }
    
    Console.WriteLine($"\nTotal orders processed: {orderCount}");
}
```

---

## Complete Optimization Example

Here's a comprehensive example showing all techniques combined:

**T-SQL Example:**
```sql
-- Create necessary indexes
CREATE INDEX IDX_OrderDate ON Orders(OrderDate);
CREATE INDEX IDX_CustomerActive ON Customers(IsActive);
CREATE INDEX IDX_OrderCustomer ON Orders(CustomerID);

-- Optimized query using CTE and filtered joins
WITH ActiveCustomerOrders AS (
    SELECT 
        c.CustomerID,
        c.Name,
        o.OrderID,
        o.OrderDate,
        o.TotalAmount
    FROM Customers c
    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
    WHERE c.IsActive = 1
        AND o.OrderDate >= '2023-01-01'
)
SELECT 
    Name AS CustomerName,
    COUNT(OrderID) AS TotalOrders,
    SUM(TotalAmount) AS TotalSpent,
    AVG(TotalAmount) AS AverageOrderValue
FROM ActiveCustomerOrders
GROUP BY Name
HAVING SUM(TotalAmount) > 1000
ORDER BY TotalSpent DESC;
```

**C# Example:**
```csharp
using System;
using System.Data.SqlClient;
using System.Collections.Generic;

public class QueryOptimization
{
    private readonly string _connectionString;
    
    public QueryOptimization(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public void CreateOptimizedIndexes()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            var command = new SqlCommand(@"
                CREATE INDEX IDX_OrderDate ON Orders(OrderDate);
                CREATE INDEX IDX_CustomerActive ON Customers(IsActive);
                CREATE INDEX IDX_OrderCustomer ON Orders(CustomerID);", 
                connection);
            
            connection.Open();
            command.ExecuteNonQuery();
            Console.WriteLine("All indexes created successfully");
        }
    }
    
    public List<CustomerSummary> GetOptimizedCustomerSummary(DateTime startDate, decimal minSpent)
    {
        var results = new List<CustomerSummary>();
        
        using (var connection = new SqlConnection(_connectionString))
        {
            var command = new SqlCommand(@"
                WITH ActiveCustomerOrders AS (
                    SELECT 
                        c.CustomerID,
                        c.Name,
                        o.OrderID,
                        o.OrderDate,
                        o.TotalAmount
                    FROM Customers c
                    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
                    WHERE c.IsActive = 1
                        AND o.OrderDate >= @StartDate
                )
                SELECT 
                    Name AS CustomerName,
                    COUNT(OrderID) AS TotalOrders,
                    SUM(TotalAmount) AS TotalSpent,
                    AVG(TotalAmount) AS AverageOrderValue
                FROM ActiveCustomerOrders
                GROUP BY Name
                HAVING SUM(TotalAmount) > @MinSpent
                ORDER BY TotalSpent DESC", 
                connection);
            
            command.Parameters.AddWithValue("@StartDate", startDate);
            command.Parameters.AddWithValue("@MinSpent", minSpent);
            
            connection.Open();
            using (var reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    results.Add(new CustomerSummary
                    {
                        CustomerName = reader.GetString(0),
                        TotalOrders = reader.GetInt32(1),
                        TotalSpent = reader.GetDecimal(2),
                        AverageOrderValue = reader.GetDecimal(3)
                    });
                }
            }
        }
        
        return results;
    }
    
    public void DisplayResults()
    {
        CreateOptimizedIndexes();
        
        var startDate = new DateTime(2023, 1, 1);
        var minSpent = 1000m;
        
        var summaries = GetOptimizedCustomerSummary(startDate, minSpent);
        
        Console.WriteLine("\nTop Customer Summary (Optimized Query):");
        Console.WriteLine(new string('=', 80));
        Console.WriteLine($"{"Customer",-30} {"Orders",10} {"Total Spent",15} {"Avg Order",15}");
        Console.WriteLine(new string('-', 80));
        
        foreach (var summary in summaries)
        {
            Console.WriteLine($"{summary.CustomerName,-30} {summary.TotalOrders,10} " +
                            $"${summary.TotalSpent,14:N2} ${summary.AverageOrderValue,14:N2}");
        }
        
        Console.WriteLine(new string('=', 80));
        Console.WriteLine($"Total customers: {summaries.Count}");
    }
}

public class CustomerSummary
{
    public string CustomerName { get; set; }
    public int TotalOrders { get; set; }
    public decimal TotalSpent { get; set; }
    public decimal AverageOrderValue { get; set; }
}
```

---

## Summary

Techniques like these are essential for developers seeking to deliver high-performance solutions. Key takeaways:

1. **Rewrite subqueries** - Use direct WHERE clauses instead of nested subqueries when possible
2. **Create strategic indexes** - Index columns used in WHERE clauses, JOIN conditions, and ORDER BY clauses
3. **Use CTEs instead of temporary tables** - Avoid memory overhead while maintaining code clarity
4. **Optimize joins** - Filter data before joining and ensure join columns are indexed
5. **Combine techniques** - Use multiple optimization strategies together for maximum performance

By applying these query optimization techniques, you can achieve:
- ‚ö° **Faster query execution**
- üìù **Cleaner, more maintainable code**
- üöÄ **More efficient database systems**
- üí∞ **Reduced server costs and resource consumption**