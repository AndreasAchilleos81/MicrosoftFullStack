# Lab: Implementing In-Memory Caching with IMemoryCache

## Introduction

In this lab, we'll be implementing in-memory caching using `IMemoryCache` in a .NET Web API application. We'll configure the cache, store data, and retrieve data using best practices.

## Lab Overview

This hands-on lab covers three main steps:
1. Configure in-memory caching
2. Store data in the cache
3. Retrieve data from the cache

## Prerequisites

- .NET 6.0 or later
- Basic understanding of ASP.NET Core Web API
- Visual Studio, Visual Studio Code, or any preferred IDE

## Step 1: Configure In-Memory Caching

### Adding the Required Library

First, ensure you have a reference to the `Microsoft.Extensions.Caching.Memory` library. This library is built into the .NET framework, so no third-party packages are needed.

### C# Example: Basic Configuration in Program.cs

```csharp
using Microsoft.Extensions.Caching.Memory;

var builder = WebApplication.CreateBuilder(args);

// Add memory cache service to the application
builder.Services.AddMemoryCache();

// Add other services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();

// Application endpoints will be added below

app.Run();
```

**Key Point:** The `builder.Services.AddMemoryCache()` call registers the memory cache service, making it available throughout the application via dependency injection.

## Step 2: Store Data in the Cache

Now we'll set up the code to store data in the cache with specific options.

### C# Example: Storing Data in Cache

```csharp
using Microsoft.Extensions.Caching.Memory;

var builder = WebApplication.CreateBuilder(args);

// Add memory cache
builder.Services.AddMemoryCache();

var app = builder.Build();

// Get reference to IMemoryCache
var cache = app.Services.GetRequiredService<IMemoryCache>();

// Set up cache options
var cacheEntryOptions = new MemoryCacheEntryOptions()
    .SetAbsoluteExpiration(TimeSpan.FromSeconds(60));

// Define cache key
string key = "employeeList";

// Create data to cache
var employees = new List<string> { "Alice", "Bob", "Charlie" };

// Store data in cache with the key and options
cache.Set(key, employees, cacheEntryOptions);

Console.WriteLine("Employee data cached successfully.");

app.Run();
```

### Breaking Down the Code

**1. Cache Reference:**
```csharp
var cache = app.Services.GetRequiredService<IMemoryCache>();
```
This retrieves the `IMemoryCache` instance from the dependency injection container.

**2. Cache Options:**
```csharp
var cacheEntryOptions = new MemoryCacheEntryOptions()
    .SetAbsoluteExpiration(TimeSpan.FromSeconds(60));
```
Sets the cache to expire 60 seconds after creation.

**3. Cache Key:**
```csharp
string key = "employeeList";
```
A unique identifier to reference this cached data.

**4. Data Preparation:**
```csharp
var employees = new List<string> { "Alice", "Bob", "Charlie" };
```
The actual data we want to cache.

**5. Storing in Cache:**
```csharp
cache.Set(key, employees, cacheEntryOptions);
```
Pushes data to the cache using the specified key and options.

## Step 3: Retrieve Data from the Cache

Now we'll create an endpoint to retrieve data from the cache, with fallback logic if the cache misses.

### C# Example: Complete Implementation with GET Endpoint

```csharp
using Microsoft.Extensions.Caching.Memory;

var builder = WebApplication.CreateBuilder(args);

// Add memory cache
builder.Services.AddMemoryCache();

var app = builder.Build();

// Get reference to IMemoryCache
var cache = app.Services.GetRequiredService<IMemoryCache>();

// Set up cache options
var cacheEntryOptions = new MemoryCacheEntryOptions()
    .SetAbsoluteExpiration(TimeSpan.FromSeconds(60));

// Define cache key
string key = "employeeList";

// Create and cache initial data
var employees = new List<string> { "Alice", "Bob", "Charlie" };
cache.Set(key, employees, cacheEntryOptions);

// GET endpoint to retrieve employees
app.MapGet("/", () =>
{
    // Try to get data from cache
    if (!cache.TryGetValue(key, out List<string>? cachedEmployees))
    {
        // Cache miss - data not found in cache
        Console.WriteLine("Cache miss! Fetching employees from data source...");
        
        // Fetch employees from data source (simulated)
        cachedEmployees = FetchEmployees();
        
        // Store in cache for future requests
        cache.Set(key, cachedEmployees, cacheEntryOptions);
    }
    else
    {
        // Cache hit - data retrieved from cache
        Console.WriteLine("Cache hit! Retrieving employees from cache.");
    }
    
    // Return the employee list
    return Results.Ok(cachedEmployees);
});

app.Run();

// Simulated data fetch method
List<string> FetchEmployees()
{
    // In a real-world application, this would query a database or call an API
    return new List<string> { "Alice", "Bob", "Charlie" };
}
```

### Understanding Cache Retrieval

**1. TryGetValue Method:**
```csharp
if (!cache.TryGetValue(key, out List<string>? cachedEmployees))
```
- Attempts to retrieve data from cache using the key
- Returns `false` if data isn't found (cache miss)
- The `!` (exclamation point) negates the result, so the code inside runs on cache miss

**2. Cache Miss Logic:**
```csharp
Console.WriteLine("Cache miss! Fetching employees from data source...");
cachedEmployees = FetchEmployees();
cache.Set(key, cachedEmployees, cacheEntryOptions);
```
- Logs that cache was missed
- Fetches data from the source (database, API, etc.)
- Stores the fetched data in cache for future requests

**3. Cache Hit Logic:**
```csharp
else
{
    Console.WriteLine("Cache hit! Retrieving employees from cache.");
}
```
- If `TryGetValue` succeeds, `cachedEmployees` is already populated
- No need to fetch data or update the cache
- Simply log and return the cached data

## Complete Lab Implementation

### Full Program.cs Example

```csharp
using Microsoft.Extensions.Caching.Memory;

var builder = WebApplication.CreateBuilder(args);

// Step 1: Configure in-memory caching
builder.Services.AddMemoryCache();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Enable Swagger in development
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Get reference to IMemoryCache
var cache = app.Services.GetRequiredService<IMemoryCache>();

// Step 2: Store data in the cache
var cacheEntryOptions = new MemoryCacheEntryOptions()
    .SetAbsoluteExpiration(TimeSpan.FromSeconds(60));

string key = "employeeList";
var employees = new List<string> { "Alice", "Bob", "Charlie" };
cache.Set(key, employees, cacheEntryOptions);

Console.WriteLine("Initial employee data cached.");

// Step 3: Retrieve data from cache
app.MapGet("/employees", () =>
{
    if (!cache.TryGetValue(key, out List<string>? cachedEmployees))
    {
        Console.WriteLine("Cache miss! Fetching employees from data source...");
        cachedEmployees = FetchEmployees();
        cache.Set(key, cachedEmployees, cacheEntryOptions);
    }
    else
    {
        Console.WriteLine("Cache hit! Retrieving employees from cache.");
    }
    
    return Results.Ok(new 
    { 
        employees = cachedEmployees,
        timestamp = DateTime.UtcNow
    });
});

// Additional endpoint to clear cache
app.MapDelete("/employees/cache", () =>
{
    cache.Remove(key);
    Console.WriteLine("Cache cleared.");
    return Results.Ok(new { message = "Cache cleared successfully" });
});

// Additional endpoint to refresh cache
app.MapPost("/employees/cache/refresh", () =>
{
    var freshEmployees = FetchEmployees();
    cache.Set(key, freshEmployees, cacheEntryOptions);
    Console.WriteLine("Cache refreshed.");
    return Results.Ok(new { message = "Cache refreshed successfully", employees = freshEmployees });
});

app.Run();

// Helper method - simulates fetching from database or API
List<string> FetchEmployees()
{
    // In real-world scenario, this would be:
    // - Database query: await dbContext.Employees.ToListAsync()
    // - API call: await httpClient.GetFromJsonAsync<List<string>>("api/employees")
    
    Console.WriteLine("Fetching employees from data source...");
    return new List<string> { "Alice", "Bob", "Charlie" };
}
```

## Testing the Application

### 1. Run the Application

```bash
dotnet run
```

### 2. Test Cache Hit

First request (within 60 seconds):
```bash
GET http://localhost:5000/employees
```

**Expected Console Output:**
```
Initial employee data cached.
Cache hit! Retrieving employees from cache.
```

**Expected Response:**
```json
{
  "employees": ["Alice", "Bob", "Charlie"],
  "timestamp": "2025-10-30T10:30:00Z"
}
```

### 3. Test Cache Miss

Wait for 60+ seconds or clear the cache, then request:
```bash
GET http://localhost:5000/employees
```

**Expected Console Output:**
```
Cache miss! Fetching employees from data source...
Fetching employees from data source...
```

### 4. Test Cache Clear

```bash
DELETE http://localhost:5000/employees/cache
```

**Expected Console Output:**
```
Cache cleared.
```

### 5. Test Cache Refresh

```bash
POST http://localhost:5000/employees/cache/refresh
```

**Expected Console Output:**
```
Fetching employees from data source...
Cache refreshed.
```

## Advanced Patterns

### Pattern 1: Service-Based Caching

```csharp
public class EmployeeService
{
    private readonly IMemoryCache _cache;
    private readonly string _cacheKey = "employeeList";

    public EmployeeService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public async Task<List<string>> GetEmployeesAsync()
    {
        if (!_cache.TryGetValue(_cacheKey, out List<string>? employees))
        {
            employees = await FetchEmployeesFromDatabaseAsync();
            
            var cacheOptions = new MemoryCacheEntryOptions()
                .SetAbsoluteExpiration(TimeSpan.FromMinutes(1));
                
            _cache.Set(_cacheKey, employees, cacheOptions);
        }
        
        return employees ?? new List<string>();
    }

    private async Task<List<string>> FetchEmployeesFromDatabaseAsync()
    {
        // Simulate async database call
        await Task.Delay(100);
        return new List<string> { "Alice", "Bob", "Charlie" };
    }

    public void ClearCache()
    {
        _cache.Remove(_cacheKey);
    }
}

// Register in Program.cs
builder.Services.AddScoped<EmployeeService>();
```

### Pattern 2: Generic Cache Service

```csharp
public class CacheService
{
    private readonly IMemoryCache _cache;

    public CacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public T? GetOrCreate<T>(string key, Func<T> factory, TimeSpan expiration)
    {
        if (!_cache.TryGetValue(key, out T? value))
        {
            value = factory();
            
            var options = new MemoryCacheEntryOptions()
                .SetAbsoluteExpiration(expiration);
                
            _cache.Set(key, value, options);
        }
        
        return value;
    }

    public async Task<T?> GetOrCreateAsync<T>(
        string key, 
        Func<Task<T>> factory, 
        TimeSpan expiration)
    {
        if (!_cache.TryGetValue(key, out T? value))
        {
            value = await factory();
            
            var options = new MemoryCacheEntryOptions()
                .SetAbsoluteExpiration(expiration);
                
            _cache.Set(key, value, options);
        }
        
        return value;
    }

    public void Remove(string key)
    {
        _cache.Remove(key);
    }
}

// Usage
var employees = await cacheService.GetOrCreateAsync(
    "employeeList",
    async () => await FetchEmployeesAsync(),
    TimeSpan.FromMinutes(1)
);
```

## Real-World Considerations

### 1. Database Integration

```csharp
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddMemoryCache();
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

app.MapGet("/employees", async (IMemoryCache cache, ApplicationDbContext db) =>
{
    string key = "employeeList";
    
    if (!cache.TryGetValue(key, out List<Employee>? employees))
    {
        Console.WriteLine("Cache miss! Querying database...");
        
        // Fetch from actual database
        employees = await db.Employees.ToListAsync();
        
        var options = new MemoryCacheEntryOptions()
            .SetAbsoluteExpiration(TimeSpan.FromMinutes(5));
            
        cache.Set(key, employees, options);
    }
    else
    {
        Console.WriteLine("Cache hit! Using cached data.");
    }
    
    return Results.Ok(employees);
});

app.Run();
```

### 2. API Integration

```csharp
app.MapGet("/external-data", async (IMemoryCache cache, IHttpClientFactory httpFactory) =>
{
    string key = "externalData";
    
    if (!cache.TryGetValue(key, out string? data))
    {
        Console.WriteLine("Cache miss! Calling external API...");
        
        var httpClient = httpFactory.CreateClient();
        data = await httpClient.GetStringAsync("https://api.example.com/data");
        
        var options = new MemoryCacheEntryOptions()
            .SetAbsoluteExpiration(TimeSpan.FromMinutes(10));
            
        cache.Set(key, data, options);
    }
    else
    {
        Console.WriteLine("Cache hit! Using cached API response.");
    }
    
    return Results.Ok(data);
});
```

## Performance Benefits

Using in-memory caching provides significant advantages:

### Time Savings
- **Without cache:** Every request queries the database or calls an API (~50-200ms)
- **With cache:** Subsequent requests read from memory (~1-5ms)
- **Performance gain:** 10x to 200x faster response times

### Resource Savings
- Reduces database load and connection usage
- Decreases API calls and associated costs
- Lowers CPU and I/O operations on backend systems
- Improves overall application scalability

## Best Practices

### 1. Choose Appropriate Expiration Times

```csharp
// Frequently changing data
.SetAbsoluteExpiration(TimeSpan.FromSeconds(30))

// Semi-static data
.SetAbsoluteExpiration(TimeSpan.FromMinutes(5))

// Rarely changing data
.SetAbsoluteExpiration(TimeSpan.FromHours(1))
```

### 2. Always Handle Cache Misses

```csharp
if (!cache.TryGetValue(key, out var data))
{
    // Always have fallback logic
    data = FetchFromSource();
    cache.Set(key, data, options);
}
```

### 3. Invalidate Cache on Data Changes

```csharp
app.MapPost("/employees", async (Employee employee, IMemoryCache cache) =>
{
    // Save to database
    await SaveEmployeeAsync(employee);
    
    // Clear cache to ensure fresh data
    cache.Remove("employeeList");
    
    return Results.Created($"/employees/{employee.Id}", employee);
});
```

### 4. Use Descriptive Cache Keys

```csharp
// Good
string key = $"employee_list_department_{departmentId}";

// Bad
string key = "data";
```

## Conclusion

In this lab, you learned how to implement in-memory caching in a .NET Web API application using `IMemoryCache`. By configuring the cache, storing data with appropriate expiration times, and implementing efficient retrieval logic with fallback mechanisms, you can significantly improve your application's performance and reduce load on backend systems. This is essential for building scalable, high-performance web applications that provide excellent user experiences.