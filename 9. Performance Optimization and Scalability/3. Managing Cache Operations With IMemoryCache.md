# Managing Cache Entries with IMemoryCache

## Introduction

Building on foundational concepts, this segment delves into managing cache entries with `IMemoryCache`, a critical step for enhancing performance and ensuring reliable, scalable applications. Through this guide, you'll explore strategies to handle cache limitations, address misses, and maintain efficient operations.

## What is IMemoryCache?

`IMemoryCache` is a caching interface in ASP.NET Core that stores data temporarily in memory for quick access. It enables developers to cache frequently accessed or computationally expensive data in the server's memory, significantly reducing response times and system load.

## Managing Cache Size and Limits

### Defining Cache Size

With `IMemoryCache`, you can define cache size and limits to control how much data your application caches. This ensures your app remains efficient even under heavy use. Managing the amount of data stored in the cache is essential to prevent memory overuse.

### C# Example: Setting Cache Size Limit

```csharp
using Microsoft.Extensions.Caching.Memory;
using System;

public class CacheConfiguration
{
    public IMemoryCache CreateCache()
    {
        // Create cache with size limit
        var cache = new MemoryCache(new MemoryCacheOptions
        {
            SizeLimit = 1024  // Maximum capacity in arbitrary units
        });

        return cache;
    }
}
```

**Important Note:** The size is measured in arbitrary units, representing the number of items or any custom metric you allocate. This configuration ensures the cache doesn't exceed its capacity, helping maintain stable memory usage.

## Handling Cache Misses

### What is a Cache Miss?

A cache miss happens when the requested data isn't found in the cache. When this occurs, the application retrieves the data from the database and adds it to the cache for future use.

### C# Example: Checking for Cache Misses

```csharp
using Microsoft.Extensions.Caching.Memory;
using System.Collections.Generic;
using System.Threading.Tasks;

public class ProductService
{
    private readonly IMemoryCache _cache;
    private readonly ApplicationDbContext _dbContext;

    public ProductService(IMemoryCache cache, ApplicationDbContext dbContext)
    {
        _cache = cache;
        _dbContext = dbContext;
    }

    public async Task<List<Product>> GetProductListAsync()
    {
        string cacheKey = "productList";

        // Check if data is in cache using TryGetValue
        if (!_cache.TryGetValue(cacheKey, out List<Product> products))
        {
            // Cache miss - data not found
            Console.WriteLine("Cache miss! Fetching products from database...");

            // Retrieve data asynchronously from database
            products = await _dbContext.GetProductsAsync();

            // Store data in cache with settings
            var cacheEntryOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10),
                Size = 1  // Contributes to overall size limit
            };

            _cache.Set(cacheKey, products, cacheEntryOptions);
            Console.WriteLine("Products added to cache.");
        }
        else
        {
            // Cache hit - data retrieved from cache
            Console.WriteLine("Cache hit! Using cached products.");
        }

        return products;
    }
}
```

### Key Components of Cache Miss Handling

#### 1. TryGetValue Method

```csharp
if (!_cache.TryGetValue(cacheKey, out List<Product> products))
{
    // Returns false if data isn't found
    // The products variable remains uninitialized
    // Triggers subsequent code to fetch from database
}
```

#### 2. Asynchronous Data Retrieval

```csharp
// Fetch data asynchronously without blocking
products = await _dbContext.GetProductsAsync();
```

This ensures the app can continue handling other tasks without being blocked, making the retrieval process efficient.

#### 3. Storing Data with Settings

```csharp
var cacheEntryOptions = new MemoryCacheEntryOptions
{
    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10),
    Size = 1
};

_cache.Set(cacheKey, products, cacheEntryOptions);
```

## Cache Entry Settings

### Absolute Expiration Relative to Now

This setting defines how long the data will stay in the cache:

```csharp
AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
```

### Size Property

The size property ensures each entry contributes to the overall size limit, maintaining control over memory usage:

```csharp
Size = 1  // Arbitrary unit contributing to SizeLimit
```

Together, these settings help maintain control over memory usage while keeping the cache efficient and well-organized.

## Clearing Cache Entries

Clearing stale or irrelevant cache entries ensures users always interact with accurate data when the cache has become outdated. This is especially important in dynamic applications where information changes frequently.

### C# Example: Removing Cache Entries

```csharp
public class ProductService
{
    private readonly IMemoryCache _cache;
    private readonly ApplicationDbContext _dbContext;

    public ProductService(IMemoryCache cache, ApplicationDbContext dbContext)
    {
        _cache = cache;
        _dbContext = dbContext;
    }

    public async Task UpdateProductAsync(Product product)
    {
        // Update product in database
        await _dbContext.UpdateProductAsync(product);

        // Remove outdated cache entry
        string cacheKey = "productList";
        _cache.Remove(cacheKey);

        Console.WriteLine("Cache entry removed. Next request will fetch fresh data.");
    }
}
```

Using the `Remove` method, you can delete the cache entry identified by the key `productList`. This ensures that the next time the app requests this data, it fetches the latest version from the database.

## Complete Implementation Example

### Example: Product Management with Cache

```csharp
using Microsoft.Extensions.Caching.Memory;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

public class ProductCacheService
{
    private readonly IMemoryCache _cache;
    private readonly ApplicationDbContext _dbContext;
    private const string ProductListKey = "productList";

    public ProductCacheService(IMemoryCache cache, ApplicationDbContext dbContext)
    {
        _cache = cache;
        _dbContext = dbContext;
    }

    // Get all products with caching
    public async Task<List<Product>> GetAllProductsAsync()
    {
        if (!_cache.TryGetValue(ProductListKey, out List<Product> products))
        {
            Console.WriteLine("Cache miss for product list.");

            // Fetch from database
            products = await _dbContext.Products.ToListAsync();

            // Cache with settings
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15),
                Size = 1,
                Priority = CacheItemPriority.High
            };

            _cache.Set(ProductListKey, products, cacheOptions);
            Console.WriteLine("Product list cached.");
        }
        else
        {
            Console.WriteLine("Cache hit for product list.");
        }

        return products;
    }

    // Get single product by ID
    public async Task<Product> GetProductByIdAsync(int productId)
    {
        string cacheKey = $"product_{productId}";

        if (!_cache.TryGetValue(cacheKey, out Product product))
        {
            Console.WriteLine($"Cache miss for product {productId}.");

            product = await _dbContext.Products
                .FirstOrDefaultAsync(p => p.Id == productId);

            if (product != null)
            {
                var cacheOptions = new MemoryCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30),
                    Size = 1
                };

                _cache.Set(cacheKey, product, cacheOptions);
                Console.WriteLine($"Product {productId} cached.");
            }
        }
        else
        {
            Console.WriteLine($"Cache hit for product {productId}.");
        }

        return product;
    }

    // Add new product and invalidate cache
    public async Task<Product> AddProductAsync(Product product)
    {
        _dbContext.Products.Add(product);
        await _dbContext.SaveChangesAsync();

        // Clear product list cache to include new product
        _cache.Remove(ProductListKey);
        Console.WriteLine("Product added. Product list cache cleared.");

        return product;
    }

    // Update product and invalidate cache
    public async Task UpdateProductAsync(Product product)
    {
        _dbContext.Products.Update(product);
        await _dbContext.SaveChangesAsync();

        // Remove both specific product and list cache
        _cache.Remove($"product_{product.Id}");
        _cache.Remove(ProductListKey);
        Console.WriteLine($"Product {product.Id} updated. Caches cleared.");
    }

    // Delete product and invalidate cache
    public async Task DeleteProductAsync(int productId)
    {
        var product = await _dbContext.Products.FindAsync(productId);
        if (product != null)
        {
            _dbContext.Products.Remove(product);
            await _dbContext.SaveChangesAsync();

            // Clear caches
            _cache.Remove($"product_{productId}");
            _cache.Remove(ProductListKey);
            Console.WriteLine($"Product {productId} deleted. Caches cleared.");
        }
    }

    // Manually clear all product caches
    public void ClearProductCaches()
    {
        _cache.Remove(ProductListKey);
        Console.WriteLine("All product caches cleared.");
    }
}
```

## Advanced Cache Management Patterns

### Example 1: Cache with Sliding and Absolute Expiration

```csharp
public async Task<List<Order>> GetRecentOrdersAsync()
{
    string cacheKey = "recentOrders";

    if (!_cache.TryGetValue(cacheKey, out List<Order> orders))
    {
        orders = await _dbContext.Orders
            .Where(o => o.CreatedDate >= DateTime.UtcNow.AddDays(-7))
            .ToListAsync();

        var cacheOptions = new MemoryCacheEntryOptions
        {
            // Expires 1 hour after creation
            AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1),
            
            // Expires 10 minutes after last access
            SlidingExpiration = TimeSpan.FromMinutes(10),
            
            Size = 1
        };

        _cache.Set(cacheKey, orders, cacheOptions);
    }

    return orders;
}
```

### Example 2: Cache with Priority Management

```csharp
public async Task CacheUserDataAsync(int userId)
{
    var user = await _dbContext.Users.FindAsync(userId);
    var userSettings = await _dbContext.UserSettings
        .FirstOrDefaultAsync(s => s.UserId == userId);

    // High priority for user data
    var userCacheOptions = new MemoryCacheEntryOptions
    {
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30),
        Priority = CacheItemPriority.High,
        Size = 1
    };

    // Low priority for settings
    var settingsCacheOptions = new MemoryCacheEntryOptions
    {
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15),
        Priority = CacheItemPriority.Low,
        Size = 1
    };

    _cache.Set($"user_{userId}", user, userCacheOptions);
    _cache.Set($"settings_{userId}", userSettings, settingsCacheOptions);
}
```

### Example 3: Bulk Cache Operations

```csharp
public class BulkCacheService
{
    private readonly IMemoryCache _cache;

    public BulkCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public void CacheMultipleItems(Dictionary<string, object> items)
    {
        foreach (var item in items)
        {
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(20),
                Size = 1
            };

            _cache.Set(item.Key, item.Value, cacheOptions);
        }

        Console.WriteLine($"Cached {items.Count} items.");
    }

    public void ClearMultipleItems(List<string> keys)
    {
        foreach (var key in keys)
        {
            _cache.Remove(key);
        }

        Console.WriteLine($"Cleared {keys.Count} cache entries.");
    }
}
```

## Dependency Injection Setup

### Startup Configuration

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Configure database context
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));

        // Add memory cache with options
        services.AddMemoryCache(options =>
        {
            options.SizeLimit = 1024;
            options.CompactionPercentage = 0.75;
            options.ExpirationScanFrequency = TimeSpan.FromMinutes(5);
        });

        // Register cache services
        services.AddScoped<ProductCacheService>();
        services.AddScoped<BulkCacheService>();

        services.AddControllers();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseRouting();
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
```

## API Controller Example

```csharp
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;
using System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly ProductCacheService _productService;

    public ProductsController(ProductCacheService productService)
    {
        _productService = productService;
    }

    [HttpGet]
    public async Task<ActionResult<List<Product>>> GetAllProducts()
    {
        var products = await _productService.GetAllProductsAsync();
        return Ok(products);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<Product>> GetProduct(int id)
    {
        var product = await _productService.GetProductByIdAsync(id);

        if (product == null)
            return NotFound();

        return Ok(product);
    }

    [HttpPost]
    public async Task<ActionResult<Product>> CreateProduct([FromBody] Product product)
    {
        var createdProduct = await _productService.AddProductAsync(product);
        return CreatedAtAction(nameof(GetProduct), new { id = createdProduct.Id }, createdProduct);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateProduct(int id, [FromBody] Product product)
    {
        if (id != product.Id)
            return BadRequest();

        await _productService.UpdateProductAsync(product);
        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteProduct(int id)
    {
        await _productService.DeleteProductAsync(id);
        return NoContent();
    }

    [HttpPost("clear-cache")]
    public IActionResult ClearCache()
    {
        _productService.ClearProductCaches();
        return Ok(new { message = "Cache cleared successfully" });
    }
}
```

## Best Practices for Cache Management

### 1. Always Handle Cache Misses Gracefully

```csharp
if (!_cache.TryGetValue(key, out var data))
{
    // Fetch from database
    // Add to cache with appropriate settings
}
```

### 2. Set Appropriate Size Limits

```csharp
var options = new MemoryCacheOptions
{
    SizeLimit = 1024,
    CompactionPercentage = 0.75  // Remove 25% when limit reached
};
```

### 3. Invalidate Cache on Data Changes

```csharp
public async Task UpdateData(DataModel data)
{
    await _repository.UpdateAsync(data);
    _cache.Remove(GetCacheKey(data.Id));  // Clear stale cache
}
```

### 4. Use Meaningful Cache Keys

```csharp
// Good: Descriptive and unique
string cacheKey = $"user_profile_{userId}";

// Bad: Generic and prone to conflicts
string cacheKey = "data";
```

### 5. Monitor Cache Performance

```csharp
var cacheOptions = new MemoryCacheEntryOptions()
    .RegisterPostEvictionCallback((key, value, reason, state) =>
    {
        Console.WriteLine($"Cache evicted - Key: {key}, Reason: {reason}");
    });
```

## Performance Benefits

With `IMemoryCache`, you can transform your app's performance by:

- **Effectively managing memory**: Control cache size to prevent memory overuse
- **Minimizing delays from cache misses**: Asynchronous data retrieval keeps the app responsive
- **Keeping data fresh**: Regular cache invalidation ensures users see up-to-date information
- **Reducing database load**: Fewer queries mean better database performance
- **Improving response times**: In-memory access is significantly faster than database queries

## When to Clear Cache

Clear cache entries when:

- Data is updated in the database
- User performs create, update, or delete operations
- Cache entries become stale or outdated
- Application requirements change
- Manual cache refresh is requested

## Conclusion

Managing cache entries with `IMemoryCache` is essential for building high-performance, scalable applications. By properly handling cache misses, setting appropriate expiration policies, managing cache size limits, and clearing stale data, you can ensure your application delivers fast, reliable, and accurate responses to users while efficiently utilizing system resources.