# Cache Expiration Policies in .NET

This guide demonstrates how to implement and test expiration policies using IMemoryCache and Redis in .NET. We'll explore three different approaches to managing cache expiration.

## Overview

The three methods covered are:

1. **Absolute Expiration** - Cache expires after a fixed time period
2. **Sliding Expiration** - Cache expiration resets with each access
3. **Redis Dependencies** - Child cache entries expire when parent entries are updated

---

## Method 1: Absolute Expiration with IMemoryCache

Absolute expiration sets a fixed time after which the cache entry is automatically removed, regardless of access patterns.

### Code Example

```csharp
public void CacheAbsoluteMethod()
{
    var memoryCache = new MemoryCache(new MemoryCacheOptions());
    
    // Define key-value pair
    string key = "absolute_key";
    string value = "Cache data with absolute expiration";
    
    // Configure cache entry options with absolute expiration
    var cacheEntryOptions = new MemoryCacheEntryOptions()
        .SetAbsoluteExpiration(TimeSpan.FromSeconds(5));
    
    // Set cache entry
    memoryCache.Set(key, value, cacheEntryOptions);
    
    // Retrieve and display initial value
    Console.WriteLine($"Initial value: {memoryCache.Get<string>(key)}");
    
    // Wait for expiration (6 seconds > 5 seconds expiration)
    Thread.Sleep(TimeSpan.FromSeconds(6));
    
    // Check cache after expiration
    var cachedValue = memoryCache.Get<string>(key);
    Console.WriteLine(cachedValue != null 
        ? $"After expiration: {cachedValue}" 
        : "After expiration: Cache expired");
}
```

### Expected Output

```
Initial value: Cache data with absolute expiration
After expiration: Cache expired
```

### Key Points

- Once the absolute expiration time is reached, the cache entry is deleted
- Accessing the cache does not reset the expiration timer
- Use for data that should refresh at specific intervals

---

## Method 2: Sliding Expiration with IMemoryCache

Sliding expiration extends the cache lifetime each time the entry is accessed. The cache expires only if not accessed within the specified timespan.

### Code Example

```csharp
public void CacheSlidingMethod()
{
    var memoryCache = new MemoryCache(new MemoryCacheOptions());
    
    // Define key-value pair
    string key = "sliding_key";
    string value = "Cache data with sliding expiration";
    
    // Configure cache entry options with sliding expiration
    var cacheEntryOptions = new MemoryCacheEntryOptions()
        .SetSlidingExpiration(TimeSpan.FromSeconds(5));
    
    // Set cache entry
    memoryCache.Set(key, value, cacheEntryOptions);
    
    // Access cache multiple times within expiration window
    for (int i = 1; i <= 3; i++)
    {
        Thread.Sleep(TimeSpan.FromSeconds(3));
        var cachedValue = memoryCache.Get<string>(key);
        Console.WriteLine($"Loop {i}: {cachedValue}");
        
        if (i == 2)
        {
            Thread.Sleep(TimeSpan.FromSeconds(4));
        }
    }
    
    // Wait beyond sliding expiration window
    Thread.Sleep(TimeSpan.FromSeconds(6));
    
    // Check cache after expiration
    var finalValue = memoryCache.Get<string>(key);
    Console.WriteLine(finalValue != null 
        ? $"After expiration: {finalValue}" 
        : "After expiration: Cache expired");
}
```

### Expected Output

```
Loop 1: Cache data with sliding expiration
Loop 2: Cache data with sliding expiration
Loop 3: Cache data with sliding expiration
After expiration: Cache expired
```

### Key Points

- Each access resets the expiration timer
- Cache remains valid as long as it's accessed within the sliding window
- Ideal for frequently accessed data that should persist with activity

---

## Method 3: Redis Dependency-Based Expiration

This approach uses Redis to manage cache dependencies, where child entries can be invalidated based on parent entry updates.

### Code Example

```csharp
public async Task CacheRedisMethod()
{
    var redis = ConnectionMultiplexer.Connect("localhost");
    var db = redis.GetDatabase();
    
    // Define parent and child keys
    string parentKey = "product";
    string childKey = "inventory";
    
    // Set initial cache values
    await db.StringSetAsync(parentKey, "Product data");
    await db.StringSetAsync(childKey, "Inventory data");
    
    // Display initial values
    Console.WriteLine($"Parent: {await db.StringGetAsync(parentKey)}");
    Console.WriteLine($"Child: {await db.StringGetAsync(childKey)}");
    
    // Update parent key
    await db.StringSetAsync(parentKey, "Updated product data");
    
    // Invalidate child based on parent update
    var parentValue = await db.StringGetAsync(parentKey);
    if (parentValue == "Updated product data")
    {
        await db.KeyDeleteAsync(childKey);
        Console.WriteLine("Child key deleted due to parent update");
    }
    
    // Display state after update
    Console.WriteLine($"Parent after update: {await db.StringGetAsync(parentKey)}");
    
    var childValue = await db.StringGetAsync(childKey);
    Console.WriteLine(childValue.HasValue 
        ? $"Child after update: {childValue}" 
        : "Child after update: Cache expired");
}
```

### Expected Output

```
Parent: Product data
Child: Inventory data
Child key deleted due to parent update
Parent after update: Updated product data
Child after update: Cache expired
```

### Key Points

- Enables complex cache invalidation patterns
- Child entries can depend on parent entries
- Useful for maintaining cache consistency across related data
- Requires Redis connection and configuration

---

## When to Use Each Approach

| Approach                | Use Case                                                                                                  |
| ----------------------- | --------------------------------------------------------------------------------------------------------- |
| **Absolute Expiration** | Data that should refresh at specific intervals (e.g., daily reports, scheduled updates)                   |
| **Sliding Expiration**  | Frequently accessed data that should persist with activity (e.g., user sessions, active documents)        |
| **Redis Dependencies**  | Related data requiring coordinated invalidation (e.g., product and inventory, parent-child relationships) |

---

## Required NuGet Packages

```xml
<PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.0" />
<PackageReference Include="StackExchange.Redis" Version="2.7.0" />
```

## Conclusion

Each caching strategy serves different purposes in application development. Choose the appropriate approach based on your data access patterns and consistency requirements.