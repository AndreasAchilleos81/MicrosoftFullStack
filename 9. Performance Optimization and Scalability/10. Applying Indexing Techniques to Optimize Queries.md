# Web Security and Database Optimization Guide

## Introduction
Managing security on your website will help make your data and your users more safe. In this lab, we're going to implement encoding and sanitation techniques to prevent cross-site scripting or XSS attacks in a sample web application.

---

## Step 1: HTML Encoding

HTML encoding renders any HTML tags as plain text, making them less dangerous by converting them into text fields rather than executable HTML.

### Concept
By encoding HTML input, we prevent malicious code from being executed when rendered to the screen. The content is displayed as text rather than being interpreted as HTML.

### C# Example

```csharp
using System.Web;
using System.Text.Encodings.Web;

public class HtmlEncodingExample
{
    // Method 1: Using HttpUtility (ASP.NET)
    public string EncodeHtmlWithHttpUtility(string userInput)
    {
        string encodedOutput = HttpUtility.HtmlEncode(userInput);
        return encodedOutput;
    }

    // Method 2: Using HtmlEncoder (ASP.NET Core)
    public string EncodeHtmlWithEncoder(string userInput)
    {
        string encodedOutput = HtmlEncoder.Default.Encode(userInput);
        return encodedOutput;
    }

    // Usage example
    public void ProcessUserInput()
    {
        string userInput = "<script>alert('XSS');</script>";
        string safeOutput = EncodeHtmlWithEncoder(userInput);
        
        // Output: &lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;
        Console.WriteLine(safeOutput);
    }
}
```

---

## Step 2: JavaScript Encoding

JavaScript encoding uses regular expressions to escape potentially dangerous characters, preventing them from being executed as code.

### Concept
By escaping special characters with slashes, we ensure they render as text in the output rather than being interpreted as executable scripts.

### C# Example

```csharp
using System.Text.RegularExpressions;
using System.Text.Encodings.Web;

public class JavaScriptEncodingExample
{
    // Method 1: Manual escaping with Regex
    public string EscapeJavaScript(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        // Escape dangerous characters
        string safeInput = Regex.Replace(input, 
            @"[<>""'/\\]", 
            m => "\\" + m.Value);
        
        return safeInput;
    }

    // Method 2: Using JavaScriptEncoder (Recommended)
    public string EncodeJavaScript(string input)
    {
        string safeInput = JavaScriptEncoder.Default.Encode(input);
        return safeInput;
    }

    // Usage example
    public void ProcessInput()
    {
        string userInput = "'; alert('XSS'); //";
        string safeOutput = EncodeJavaScript(userInput);
        
        Console.WriteLine($"Safe output: {safeOutput}");
    }
}
```

---

## Step 3: URL Encoding

URL encoding ensures that URL components are properly encoded and safe to use in web requests.

### Concept
URL encoding converts special characters into a format that can be safely transmitted over the internet.

### C# Example

```csharp
using System;
using System.Web;

public class UrlEncodingExample
{
    // Method 1: Using HttpUtility
    public string EncodeUrlWithHttpUtility(string input)
    {
        string encodedUrl = HttpUtility.UrlEncode(input);
        return encodedUrl;
    }

    // Method 2: Using Uri.EscapeDataString (More modern)
    public string EncodeUrlWithUri(string input)
    {
        string encodedUrl = Uri.EscapeDataString(input);
        return encodedUrl;
    }

    // Usage example
    public void ProcessUrlInput()
    {
        string userInput = "https://example.com?name=John Doe&age=30";
        string encodedUrl = EncodeUrlWithUri(userInput);
        
        Console.WriteLine($"Encoded URL: {encodedUrl}");
        // Output: https%3A%2F%2Fexample.com%3Fname%3DJohn%20Doe%26age%3D30
    }
}
```

---

## Step 4: Input Sanitization with Libraries

In the real world, using established sanitization libraries is recommended for comprehensive input cleaning.

### C# Example with HtmlSanitizer

```csharp
using Ganss.XSS;

public class InputSanitizationExample
{
    private readonly HtmlSanitizer _sanitizer;

    public InputSanitizationExample()
    {
        _sanitizer = new HtmlSanitizer();
        
        // Configure allowed tags and attributes
        _sanitizer.AllowedTags.Clear();
        _sanitizer.AllowedTags.Add("p");
        _sanitizer.AllowedTags.Add("b");
        _sanitizer.AllowedTags.Add("i");
        _sanitizer.AllowedTags.Add("br");
    }

    public string SanitizeInput(string userInput)
    {
        string sanitizedInput = _sanitizer.Sanitize(userInput);
        return sanitizedInput;
    }

    // Usage example
    public void ProcessUserComment()
    {
        string userInput = "<p>Valid content</p><script>alert('XSS');</script>";
        string cleanOutput = SanitizeInput(userInput);
        
        // Output: <p>Valid content</p>
        Console.WriteLine($"Sanitized: {cleanOutput}");
    }
}
```

---

## Step 5: Database Query Optimization with Indexes

Creating indexes on foreign key columns improves the performance of JOIN queries significantly.

### Concept
A non-clustered index on the `CustomerID` column in the `Orders` table will speed up JOIN operations with the `Customers` table.

### T-SQL Example

```sql
-- Create the Customers table
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY IDENTITY(1,1),
    CustomerName NVARCHAR(100) NOT NULL,
    Email NVARCHAR(100),
    City NVARCHAR(50)
);

-- Create the Orders table
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY IDENTITY(1,1),
    CustomerID INT NOT NULL,
    OrderDate DATETIME NOT NULL,
    TotalAmount DECIMAL(10, 2),
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

-- Step 1: Create a non-clustered index on CustomerID in Orders table
CREATE NONCLUSTERED INDEX IX_Orders_CustomerID 
ON Orders(CustomerID);

-- Step 2: Query to retrieve customer names with their orders
SELECT 
    c.CustomerID,
    c.CustomerName,
    o.OrderID,
    o.OrderDate,
    o.TotalAmount
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.City = 'New York';

-- Step 3: Examine query execution plan
SET SHOWPLAN_TEXT ON;
GO

SELECT 
    c.CustomerName,
    COUNT(o.OrderID) AS TotalOrders,
    SUM(o.TotalAmount) AS TotalRevenue
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID, c.CustomerName;

SET SHOWPLAN_TEXT OFF;
GO

-- Step 4: View index usage statistics
SELECT 
    OBJECT_NAME(s.object_id) AS TableName,
    i.name AS IndexName,
    s.user_seeks,
    s.user_scans,
    s.user_lookups,
    s.user_updates
FROM sys.dm_db_index_usage_stats s
INNER JOIN sys.indexes i ON s.object_id = i.object_id 
    AND s.index_id = i.index_id
WHERE OBJECT_NAME(s.object_id) = 'Orders';

-- Additional optimization: Create covering index for frequent queries
CREATE NONCLUSTERED INDEX IX_Orders_CustomerID_Covering
ON Orders(CustomerID)
INCLUDE (OrderDate, TotalAmount);
```

---

## Best Practices Summary

### Input Validation and Encoding
1. **Always validate and sanitize user input** before processing or storing it
2. **Use multiple layers of encoding** (HTML, JavaScript, URL) depending on context
3. **Leverage established libraries** rather than writing custom sanitization code
4. **Encode output** when displaying user-generated content
5. **Never trust client-side validation alone** - always validate on the server

### Database Optimization
1. **Create indexes on foreign key columns** used in JOIN operations
2. **Use execution plans** to identify performance bottlenecks
3. **Monitor index usage** to ensure indexes are being utilized
4. **Consider covering indexes** for frequently-run queries
5. **Avoid over-indexing** as it can slow down INSERT/UPDATE operations

---

## Conclusion

By implementing proper encoding, sanitization, and database optimization techniques, you can significantly improve both the security and performance of your web applications. These practices protect your data and users while ensuring efficient database operations.