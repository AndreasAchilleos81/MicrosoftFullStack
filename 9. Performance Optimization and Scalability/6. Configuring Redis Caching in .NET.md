# Redis Caching in .NET Application Lab

## Overview

This lab demonstrates how to configure Redis caching in a .NET application to manage data across multiple servers.

## Prerequisites

- Redis server running (default port: 6379)
- .NET application with Web API
- Stack Exchange Redis library installed

## Step 1: Configure Redis in .NET Application

### Verify Redis Installation

First, verify that Redis is running by using the Redis CLI:

```bash
redis-cli
> ping
PONG
> exit
```

When Redis responds with `PONG`, the server is running correctly on port 6379 (default port).

### Install Required Package

Add the Stack Exchange Redis library to your project:

```xml
<!-- In your .csproj file -->
<ItemGroup>
  <PackageReference Include="Microsoft.Extensions.Caching.StackExchange.Redis" Version="*" />
</ItemGroup>
```

### Configure Redis in Program.cs

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add Redis distributed cache
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = "localhost:6379";
    options.InstanceName = "RedisEventCache";
});

var app = builder.Build();
```

## Step 2: Store Event Data in Redis Cache

### Create Event Controller

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Distributed;
using System.Text.Json;

[ApiController]
[Route("[controller]")]
public class EventController : ControllerBase
{
    private readonly IDistributedCache _cache;

    public EventController(IDistributedCache cache)
    {
        _cache = cache;
    }

    [HttpPost("Store")]
    public async Task<IActionResult> StoreEvent([FromBody] EventData eventData)
    {
        // Serialize the event data
        string serializedData = JsonSerializer.Serialize(eventData);

        // Convert to byte array
        byte[] data = System.Text.Encoding.UTF8.GetBytes(serializedData);

        // Set cache options with 10-minute expiration
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
        };

        // Store data in cache using the event ID as the key
        string key = $"event:{eventData.Id}";
        await _cache.SetAsync(key, data, options);

        return Ok(new { message = "Event stored in cache", key });
    }
}
```

### Event Data Model

```csharp
public class EventData
{
    public int Id { get; set; }
    public string Name { get; set; }
    public DateTime Date { get; set; }
    public string Location { get; set; }
}
```

## Step 3: Retrieve Data from Redis Cache

### Create GET Endpoint

```csharp
[HttpGet("Retrieve/{id}")]
public async Task<IActionResult> RetrieveEvent(int id)
{
    string key = $"event:{id}";

    // Attempt to get data from cache
    byte[]? cacheData = await _cache.GetAsync(key);

    if (cacheData != null)
    {
        // Deserialize the cached data
        string serializedData = System.Text.Encoding.UTF8.GetString(cacheData);
        EventData? eventData = JsonSerializer.Deserialize<EventData>(serializedData);

        return Ok(eventData);
    }

    // Data not found in cache
    return NotFound(new { message = "Event data not found in cache" });
}
```

## Complete Controller Example

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Distributed;
using System.Text.Json;

[ApiController]
[Route("[controller]")]
public class EventController : ControllerBase
{
    private readonly IDistributedCache _cache;

    public EventController(IDistributedCache cache)
    {
        _cache = cache;
    }

    [HttpPost("Store")]
    public async Task<IActionResult> StoreEvent([FromBody] EventData eventData)
    {
        // Serialize the event data
        string serializedData = JsonSerializer.Serialize(eventData);

        // Convert to byte array
        byte[] data = System.Text.Encoding.UTF8.GetBytes(serializedData);

        // Set cache options with 10-minute expiration
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
        };

        // Store data in cache
        string key = $"event:{eventData.Id}";
        await _cache.SetAsync(key, data, options);

        return Ok(new { message = "Event stored in cache", key });
    }

    [HttpGet("Retrieve/{id}")]
    public async Task<IActionResult> RetrieveEvent(int id)
    {
        string key = $"event:{id}";

        // Attempt to get data from cache
        byte[]? cacheData = await _cache.GetAsync(key);

        if (cacheData != null)
        {
            // Deserialize the cached data
            string serializedData = System.Text.Encoding.UTF8.GetString(cacheData);
            EventData? eventData = JsonSerializer.Deserialize<EventData>(serializedData);

            return Ok(eventData);
        }

        // Data not found in cache
        return NotFound(new { message = "Event data not found in cache" });
    }
}

public class EventData
{
    public int Id { get; set; }
    public string Name { get; set; }
    public DateTime Date { get; set; }
    public string Location { get; set; }
}
```

## Testing the API

### Store Event Data

```bash
POST http://localhost:5000/Event/Store
Content-Type: application/json

{
  "id": 1,
  "name": "Tech Conference 2025",
  "date": "2025-11-15T09:00:00",
  "location": "Convention Center"
}
```

### Retrieve Event Data

```bash
GET http://localhost:5000/Event/Retrieve/1
```

## Key Concepts

### Cache Expiration

The `AbsoluteExpirationRelativeToNow` property sets how long data remains in the cache. After expiration:
- Cached data becomes unavailable
- Clients must fetch fresh data
- Helps ensure data freshness

**Best Practices:**
- **Frequently changing data**: Short expiration (minutes)
- **Daily updates**: 24-hour expiration
- **Rarely changing data**: Long expiration (hours/days)

### Benefits of Redis Caching

1. **Reduced database load**: Minimizes API calls and database queries
2. **Improved performance**: Faster data retrieval from memory
3. **Scalability**: Share data across multiple servers
4. **Flexibility**: Easy expiration and invalidation strategies

## Real-World Considerations

In production scenarios, when cache data is not found, you would typically:
1. Query the database for the requested data
2. Store the retrieved data in cache for future requests
3. Return the data to the client

This lab demonstrates the basic caching pattern. Extend it based on your application's specific needs.