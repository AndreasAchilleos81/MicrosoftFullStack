# SQL Indexes: Clustered and Non-Clustered

## Introduction

This guide demonstrates how to create and monitor clustered and non-clustered indexes in SQL databases. Indexes are powerful tools for improving query performance, especially with large datasets.

## Database Setup

### Creating the Database

First, create a database called `InventoryDB` and switch to it:

```sql
CREATE DATABASE InventoryDB;
USE InventoryDB;
```

### Creating the Products Table

```sql
CREATE TABLE Products (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(100),
    Category VARCHAR(50),
    Price DECIMAL(10, 2),
    StockItem INT
);
```

### Inserting Sample Data

```sql
INSERT INTO Products (ProductID, ProductName, Category, Price, StockItem) VALUES
(1, 'Laptop', 'Electronics', 800.00, 15),
(2, 'Mouse', 'Electronics', 20.00, 50),
(3, 'Keyboard', 'Electronics', 50.00, 30),
(4, 'Desk', 'Furniture', 200.00, 10),
(5, 'Chair', 'Furniture', 150.00, 20);
```

## Monitoring Performance

### Enable Profiling (MySQL)

```sql
SET profiling = 1;
```

### View Query Profiles

```sql
SHOW PROFILES;
```

This displays execution times for queries, helping you monitor index performance improvements.

## Creating Indexes

### Primary Key (Clustered Index)

A primary key automatically creates a clustered index:

```sql
ALTER TABLE Products
ADD PRIMARY KEY (ProductID);
```

**Note:** If a primary key already exists, this will return an error since a table can only have one primary key.

### Non-Clustered Index

Create a single-column non-clustered index:

```sql
CREATE INDEX IDX_Category
ON Products(Category);
```

### Composite (Multi-Column) Index

Create an index spanning multiple columns:

```sql
CREATE INDEX IDX_Category_Price
ON Products(Category, Price);
```

## Analyzing Query Performance

### Using EXPLAIN (MySQL)

```sql
EXPLAIN SELECT * FROM Products WHERE Category = 'Electronics';
```

**Key columns to monitor:**
- **type**: Shows if index is being used (ALL = no index, REF = index used, RANGE = range scan)
- **key**: Shows which index is being used
- **rows**: Estimated number of rows examined

### Sample Query Results

```sql
-- Simple query
SELECT * FROM Products WHERE Category = 'Electronics';

-- Compound query using composite index
SELECT * FROM Products 
WHERE Category = 'Electronics' AND Price < 500;
```

## Managing Indexes

### Dropping an Index

```sql
DROP INDEX IDX_Category ON Products;
```

## Important Considerations

1. **Small Datasets**: On small tables, indexes may actually slow down queries. The database might perform a full table scan faster than using an index.

2. **Large Datasets**: Indexes significantly improve performance when working with thousands or millions of records.

3. **Monitor Regularly**: Use profiling tools to track query performance as data grows.

4. **Maintenance**: Drop and recreate indexes as needed based on dataset size and query patterns.

---

## T-SQL Examples (SQL Server)

### Creating the Database and Table

```tsql
-- Create database
CREATE DATABASE InventoryDB;
GO

USE InventoryDB;
GO

-- Create table
CREATE TABLE Products (
    ProductID INT PRIMARY KEY CLUSTERED,
    ProductName NVARCHAR(100),
    Category NVARCHAR(50),
    Price DECIMAL(10, 2),
    StockItem INT
);
GO

-- Insert sample data
INSERT INTO Products (ProductID, ProductName, Category, Price, StockItem) VALUES
(1, 'Laptop', 'Electronics', 800.00, 15),
(2, 'Mouse', 'Electronics', 20.00, 50),
(3, 'Keyboard', 'Electronics', 50.00, 30),
(4, 'Desk', 'Furniture', 200.00, 10),
(5, 'Chair', 'Furniture', 150.00, 20);
GO
```

### Creating Non-Clustered Index

```tsql
-- Single column index
CREATE NONCLUSTERED INDEX IDX_Category
ON Products(Category);
GO

-- Composite index
CREATE NONCLUSTERED INDEX IDX_Category_Price
ON Products(Category, Price);
GO
```

### Analyzing Query Execution

```tsql
-- Enable execution plan
SET STATISTICS IO ON;
SET STATISTICS TIME ON;

-- Query with execution plan
SELECT * FROM Products 
WHERE Category = 'Electronics';

-- View actual execution plan (Ctrl+M in SSMS)
SELECT * FROM Products 
WHERE Category = 'Electronics' AND Price < 500;
```

### Dropping Indexes

```tsql
DROP INDEX IDX_Category ON Products;
GO
```

---

## C# Examples (Using ADO.NET and Entity Framework Core)

### ADO.NET: Creating Indexes via SQL

```csharp
using System;
using System.Data.SqlClient;

namespace IndexManagement
{
    class Program
    {
        static void Main(string[] args)
        {
            string connectionString = "Server=localhost;Database=InventoryDB;Trusted_Connection=True;";
            
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                
                // Create non-clustered index
                string createIndexQuery = @"
                    CREATE NONCLUSTERED INDEX IDX_Category
                    ON Products(Category);";
                
                using (SqlCommand command = new SqlCommand(createIndexQuery, connection))
                {
                    command.ExecuteNonQuery();
                    Console.WriteLine("Index created successfully.");
                }
                
                // Query using the index
                string selectQuery = "SELECT * FROM Products WHERE Category = @Category";
                
                using (SqlCommand command = new SqlCommand(selectQuery, connection))
                {
                    command.Parameters.AddWithValue("@Category", "Electronics");
                    
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            Console.WriteLine($"{reader["ProductName"]} - ${reader["Price"]}");
                        }
                    }
                }
            }
        }
    }
}
```

### Entity Framework Core: Index Configuration

```csharp
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace InventorySystem.Models
{
    // Product entity
    public class Product
    {
        [Key]
        public int ProductID { get; set; }
        
        [Required]
        [MaxLength(100)]
        public string ProductName { get; set; }
        
        [MaxLength(50)]
        public string Category { get; set; }
        
        [Column(TypeName = "decimal(10, 2)")]
        public decimal Price { get; set; }
        
        public int StockItem { get; set; }
    }
    
    // DbContext with index configuration
    public class InventoryContext : DbContext
    {
        public DbSet<Product> Products { get; set; }
        
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer(
                "Server=localhost;Database=InventoryDB;Trusted_Connection=True;");
        }
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure single column index
            modelBuilder.Entity<Product>()
                .HasIndex(p => p.Category)
                .HasDatabaseName("IDX_Category");
            
            // Configure composite index
            modelBuilder.Entity<Product>()
                .HasIndex(p => new { p.Category, p.Price })
                .HasDatabaseName("IDX_Category_Price");
        }
    }
}
```

### C# Query Examples with EF Core

```csharp
using System;
using System.Linq;
using InventorySystem.Models;

namespace InventorySystem
{
    class Program
    {
        static void Main(string[] args)
        {
            using (var context = new InventoryContext())
            {
                // Simple query using single column index
                var electronics = context.Products
                    .Where(p => p.Category == "Electronics")
                    .ToList();
                
                Console.WriteLine("Electronics Products:");
                foreach (var product in electronics)
                {
                    Console.WriteLine($"{product.ProductName} - ${product.Price}");
                }
                
                // Compound query using composite index
                var affordableElectronics = context.Products
                    .Where(p => p.Category == "Electronics" && p.Price < 500)
                    .ToList();
                
                Console.WriteLine("\nAffordable Electronics:");
                foreach (var product in affordableElectronics)
                {
                    Console.WriteLine($"{product.ProductName} - ${product.Price}");
                }
            }
        }
    }
}
```

### C# Performance Monitoring

```csharp
using System;
using System.Diagnostics;
using System.Linq;
using InventorySystem.Models;

namespace InventorySystem
{
    class PerformanceMonitor
    {
        static void MeasureQueryPerformance()
        {
            using (var context = new InventoryContext())
            {
                var stopwatch = new Stopwatch();
                
                // Measure query execution time
                stopwatch.Start();
                var results = context.Products
                    .Where(p => p.Category == "Electronics" && p.Price < 500)
                    .ToList();
                stopwatch.Stop();
                
                Console.WriteLine($"Query executed in {stopwatch.ElapsedMilliseconds} ms");
                Console.WriteLine($"Records returned: {results.Count}");
            }
        }
        
        static void Main(string[] args)
        {
            MeasureQueryPerformance();
        }
    }
}
```

## Summary

Indexes are essential for optimizing database performance:

- **Clustered indexes** physically sort data (one per table, typically the primary key)
- **Non-clustered indexes** create separate lookup structures
- **Composite indexes** optimize queries filtering on multiple columns
- Always monitor performance to ensure indexes provide benefits
- Small datasets may not benefit from indexes
- Regular maintenance and monitoring are crucial as data grows