# Integrating Swagger with ASP.NET Core Tutorial

## Introduction

API documentation is one of the most critical and time-consuming aspects of backend development. Keeping documentation synchronized with your code is essential—incorrect documentation is often worse than no documentation at all. Swagger provides automatic documentation generation that stays in sync with your underlying code.

## Understanding the Terminology

Before we begin, let's clarify the key terms:

- **OpenAPI**: A standard specification for documenting APIs (think of it as a special syntax)
- **Swagger**: Tooling built to work with and produce APIs that meet the OpenAPI standard
- **Swashbuckle**: A .NET namespace that contains Swagger packages for the .NET ecosystem

*Note: OpenAPI and Swagger merged several years ago, so you'll often hear them used interchangeably.*

## Required Dependencies

First, install the necessary NuGet packages:

```xml
<PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
<PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
```

Add the corresponding using statements:

```csharp
using Microsoft.OpenApi.Models;
using Swashbuckle.AspNetCore.SwaggerGen;
```

## Basic Swagger Setup

To integrate Swagger into your ASP.NET Core application, you need to make four key additions to your `Program.cs`:

### 1. Add Endpoint API Explorer Service

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddEndpointsApiExplorer();
```

This service examines all your routes and documents them.

### 2. Add Swagger Generation Service

```csharp
builder.Services.AddSwaggerGen();
```

SwaggerGen takes the endpoint information and converts it to meet the OpenAPI standard, producing a JSON document.

### 3. Configure Swagger Middleware (Development Only)

```csharp
var app = builder.Build();

// Configure middleware (only in development)
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();      // Exposes the Swagger JSON document
    app.UseSwaggerUI();    // Creates the interactive UI
}
```

**Important**: Only enable Swagger in development to avoid exposing sensitive API information in production.

## Complete Basic Setup Example

```csharp
using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure middleware
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Your API endpoints
app.MapGet("/blogs", () => GetAllBlogs());
app.MapGet("/blogs/{id}", (int id) => GetBlogById(id));
app.MapPost("/blogs", (Blog blog) => CreateBlog(blog));
app.MapPut("/blogs/{id}", (int id, Blog blog) => UpdateBlog(id, blog));
app.MapDelete("/blogs/{id}", (int id) => DeleteBlog(id));

app.Run();
```

## Accessing Swagger Documentation

Once configured, you can access your documentation at:

- **Swagger JSON**: `https://localhost:5228/swagger/v1/swagger.json`
- **Swagger UI**: `https://localhost:5228/swagger`

The JSON document contains all API information in OpenAPI format, while the UI provides a user-friendly interface for exploring and testing your API.

## Enhanced Documentation with WithOpenApi()

You can provide additional metadata for your endpoints using the `WithOpenApi()` method:

```csharp
app.MapGet("/blogs/{id}", (int id) => GetBlogById(id))
    .WithOpenApi(operation =>
    {
        operation.Summary = "Get single blog";
        operation.Description = "Returns a single blog post by its ID";
        operation.Parameters[0].Description = "The ID of the blog to retrieve";
        return operation;
    });
```

This enhances your documentation with:
- **Summary**: Brief description of what the endpoint does
- **Description**: Detailed explanation of the endpoint's functionality
- **Parameter descriptions**: Clear explanations of what each parameter represents

## Using TypedResults for Better Documentation

### The Problem with Basic Results

Using basic `Results` can lead to documentation inconsistencies:

```csharp
// ❌ Not recommended - documentation can become out of sync
app.MapGet("/blogs/{id}", (int id) =>
{
    var blog = GetBlogById(id);
    if (blog == null)
        return Results.NotFound();
    return Results.Ok(blog);
})
.Produces<Blog>(StatusCodes.Status200OK)           // Manual documentation
.Produces(StatusCodes.Status404NotFound);          // Can become outdated
```

### The Solution: TypedResults

Use `TypedResults` for automatic, accurate documentation:

```csharp
// ✅ Recommended - automatic documentation sync
app.MapGet("/blogs/{id}", Results<Ok<Blog>, NotFound> (int id) =>
{
    var blog = GetBlogById(id);
    if (blog == null)
        return TypedResults.NotFound();
    return TypedResults.Ok(blog);
});
```

**Benefits of TypedResults:**
- Automatic documentation generation
- Type safety
- Always accurate - documentation matches code reality
- No manual status code declarations needed

## Complete Enhanced Example

```csharp
using Microsoft.AspNetCore.Http.HttpResults;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Enhanced endpoint with documentation
app.MapGet("/blogs/{id}", (int id) =>
{
    var blog = GetBlogById(id);
    if (blog == null)
        return TypedResults.NotFound();
    return TypedResults.Ok(blog);
})
.WithOpenApi(operation =>
{
    operation.Summary = "Get single blog";
    operation.Description = "Returns a single blog post by its unique identifier";
    operation.Parameters[0].Description = "The ID of the blog to retrieve";
    return operation;
});

// POST endpoint with enhanced documentation
app.MapPost("/blogs", (Blog blog) =>
{
    var createdBlog = CreateBlog(blog);
    return TypedResults.Created($"/blogs/{createdBlog.Id}", createdBlog);
})
.WithOpenApi(operation =>
{
    operation.Summary = "Create new blog";
    operation.Description = "Creates a new blog post with the provided data";
    return operation;
});

app.Run();
```

## Excluding Endpoints from Documentation

Sometimes you may want to hide certain endpoints from Swagger documentation:

```csharp
app.MapGet("/", () => "Hello World!")
    .ExcludeFromDescription(); // This endpoint won't appear in Swagger
```

## Testing Your API with Swagger UI

The Swagger UI provides an interactive interface where you can:

1. **Explore endpoints**: View all available routes and their documentation
2. **Test endpoints**: Use the "Try it out" button to make actual API calls
3. **View schemas**: Understand the structure of request/response objects
4. **Generate code**: Get curl commands and code samples for various languages

### Example Testing Workflow

1. Navigate to `/swagger` in your browser
2. Find the endpoint you want to test
3. Click "Try it out"
4. Fill in required parameters
5. Click "Execute"
6. View the response, including status code, headers, and body

## Best Practices

### 1. Environment-Specific Configuration
```csharp
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

### 2. Always Use TypedResults
```csharp
// ✅ Good
return TypedResults.Ok(data);
return TypedResults.NotFound();
return TypedResults.BadRequest("Invalid input");

// ❌ Avoid
return Results.Ok(data);
```

### 3. Provide Meaningful Documentation
```csharp
.WithOpenApi(operation =>
{
    operation.Summary = "Clear, concise summary";
    operation.Description = "Detailed description of functionality";
    // Document all parameters
    return operation;
});
```

### 4. Use Descriptive Parameter Names
```csharp
app.MapGet("/blogs/{blogId}", (int blogId) => { /* ... */ })
    .WithOpenApi(operation =>
    {
        operation.Parameters[0].Description = "Unique identifier for the blog post";
        return operation;
    });
```

## Advanced Configuration

For more complex scenarios, you can customize Swagger generation:

```csharp
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo 
    { 
        Title = "My API", 
        Version = "v1",
        Description = "A comprehensive API for managing blog posts"
    });
    
    // Add XML comments support
    var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    c.IncludeXmlComments(xmlPath);
});
```

## Conclusion

Integrating Swagger with ASP.NET Core provides:

- **Automatic documentation generation** that stays in sync with your code
- **Interactive testing interface** for API exploration
- **Reduced documentation maintenance** overhead
- **Better developer experience** for API consumers

With just four lines of code, you can transform your API from undocumented to having professional-grade interactive documentation. Using `TypedResults` and `WithOpenApi()` enhancements ensures your documentation remains accurate and comprehensive.

The investment in setting up Swagger pays dividends in reduced support requests, faster developer onboarding, and improved API adoption.