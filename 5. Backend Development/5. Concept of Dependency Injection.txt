# Dependency Injection in ASP.NET Core

## Introduction

Think of your code like a machine made up of different parts. Changing one part could affect the others. Dependency Injection helps keep pieces of code separate so they can be exchanged for other parts or updated without breaking anything else in the code.

## What Are Dependencies and Services?

In software, a **dependency** is an external object or service that a class or function relies on to perform its tasks. When the dependency is an object, that object is called a **service**.

A **service** is simply an object that performs some utility for another class or function. For example, one of our API routes might need access to a service that handles authentication and authorization when requests are made. That service is a dependency of our API route, and that service is just an object that can handle authentication and authorization.

## The Problem with Manual Instantiation

The simplest way to create a service is to manually create an instance of that object within our API route, but this causes several problems:

### Example of Tight Coupling (What NOT to do):

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    public IActionResult GetUsers()
    {
        // Manual instantiation - causes tight coupling
        var authService = new AuthenticationService();
        
        if (!authService.IsAuthenticated())
        {
            return Unauthorized();
        }
        
        // Get users logic...
        return Ok();
    }
    
    [HttpPost]
    public IActionResult CreateUser()
    {
        // Another manual instantiation - code duplication
        var authService = new AuthenticationService();
        
        if (!authService.IsAuthenticated())
        {
            return Unauthorized();
        }
        
        // Create user logic...
        return Ok();
    }
}
```

### Problems with This Approach:

1. **Tight Coupling**: Making changes to our service can break other parts of our code
2. **Code Duplication**: If we have 100 routes that need this service, changing one route means changing 99 other places
3. **Performance Issues**: Each time any of our API routes is called, it creates a new instance of this object, which has serious performance implications

## Loose Coupling Solution

**Loose coupling** is a design principle in which components have minimal dependencies, allowing changes in one part to have little impact on others. This improves flexibility and maintainability and makes the system more resilient to modifications.

### Step 1: Create an Interface

```csharp
public interface IAuthService
{
    bool IsAuthenticated();
    Task<bool> AuthenticateAsync(string username, string password);
    string GetCurrentUser();
}
```

### Step 2: Implement the Service

```csharp
public class AuthenticationService : IAuthService
{
    private readonly IConfiguration _configuration;
    
    public AuthenticationService(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    
    public bool IsAuthenticated()
    {
        // Authentication logic here
        return true; // Simplified for example
    }
    
    public async Task<bool> AuthenticateAsync(string username, string password)
    {
        // Database authentication logic
        return await Task.FromResult(true);
    }
    
    public string GetCurrentUser()
    {
        // Get current user logic
        return "current_user";
    }
}
```

### Step 3: Register the Service in Program.cs

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register services
builder.Services.AddScoped<IAuthService, AuthenticationService>();
builder.Services.AddControllers();

var app = builder.Build();

app.MapControllers();
app.Run();
```

### Step 4: Use Dependency Injection in Controllers

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IAuthService _authService;
    
    // Constructor injection
    public UsersController(IAuthService authService)
    {
        _authService = authService;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetUsers()
    {
        if (!_authService.IsAuthenticated())
        {
            return Unauthorized();
        }
        
        // Get users logic...
        return Ok();
    }
    
    [HttpPost]
    public async Task<IActionResult> CreateUser()
    {
        if (!_authService.IsAuthenticated())
        {
            return Unauthorized();
        }
        
        // Create user logic...
        return Ok();
    }
}
```

## Benefits of Dependency Injection

### 1. Loose Coupling
The application doesn't care how authentication happens. It only knows that it will use a service that implements the `IAuthService` interface. The `IAuthService` is a general contract that says "I need to authenticate this user" without specifying the implementation details like checking a database.

### 2. Increased Performance
We can choose when and how a service instance is created through dependency injection. Maybe we only ever need a single object to handle our requests, or maybe we need a new instance every time it's used. Our API route doesn't have to concern itself with any of that.

#### Service Lifetimes in ASP.NET Core:

```csharp
// Singleton - One instance for the entire application lifetime
builder.Services.AddSingleton<IAuthService, AuthenticationService>();

// Scoped - One instance per HTTP request
builder.Services.AddScoped<IAuthService, AuthenticationService>();

// Transient - New instance every time it's requested
builder.Services.AddTransient<IAuthService, AuthenticationService>();
```

### 3. Maintainability
If we had many different routes that depended on a single dependency, we would only have to change it in one place, which makes our code more maintainable.

## Swapping Implementations

We can use DI to swap the authentication method. Say you decide to move from database-based authentication to an API-based authentication:

### New API-Based Authentication Service

```csharp
public class ApiAuthenticationService : IAuthService
{
    private readonly HttpClient _httpClient;
    
    public ApiAuthenticationService(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }
    
    public bool IsAuthenticated()
    {
        // API-based authentication logic
        return true;
    }
    
    public async Task<bool> AuthenticateAsync(string username, string password)
    {
        // Call external API for authentication
        var response = await _httpClient.PostAsync("/api/auth", 
            new StringContent(JsonSerializer.Serialize(new { username, password })));
        
        return response.IsSuccessStatusCode;
    }
    
    public string GetCurrentUser()
    {
        // Get current user from API
        return "api_user";
    }
}
```

### Switch Implementation in Program.cs

```csharp
var builder = WebApplication.CreateBuilder(args);

// Simply change the registration - no other code changes needed!
builder.Services.AddHttpClient();
builder.Services.AddScoped<IAuthService, ApiAuthenticationService>();

var app = builder.Build();
```

Since the application only depends on the `IAuthService` interface (the general contract), you can inject a new API-based authentication service without changing the core application logic.

## Advanced Example: Multiple Dependencies

```csharp
public interface IUserRepository
{
    Task<User> GetUserAsync(int id);
    Task<User> CreateUserAsync(User user);
}

public interface IEmailService
{
    Task SendWelcomeEmailAsync(string email);
}

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IAuthService _authService;
    private readonly IUserRepository _userRepository;
    private readonly IEmailService _emailService;
    
    public UsersController(
        IAuthService authService,
        IUserRepository userRepository,
        IEmailService emailService)
    {
        _authService = authService;
        _userRepository = userRepository;
        _emailService = emailService;
    }
    
    [HttpPost]
    public async Task<IActionResult> CreateUser([FromBody] CreateUserRequest request)
    {
        if (!_authService.IsAuthenticated())
        {
            return Unauthorized();
        }
        
        var user = await _userRepository.CreateUserAsync(new User 
        { 
            Email = request.Email,
            Name = request.Name 
        });
        
        await _emailService.SendWelcomeEmailAsync(user.Email);
        
        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }
}
```

## Key Takeaways

- **Dependency Injection** is a design pattern in which objects receive their dependencies from an external source rather than creating them internally
- **Loose coupling** improves maintainability and adaptability, making updates smooth and efficient
- With dependency injection, you can update services like authentication without rewriting your core application logic
- This keeps your code flexible and easier to manage in the long run
- The flexibility provided by DI ensures that changes to one part (like authentication logic) don't affect the rest of the system