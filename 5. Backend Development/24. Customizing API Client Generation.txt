# Swagger API Client Generation Guide

## Overview

One of the best features of working in the .NET ecosystem is the Swagger tooling. While we've explored adding Swagger documentation, this guide covers how to automatically generate API client code using Swagger, eliminating the need for manual HTTP requests and ensuring type safety.

## Why Use Generated Clients?

Generated API clients provide several advantages over manual HTTP requests:
- **Type Safety**: Compile-time checking of API contracts
- **Automatic Error Handling**: Built-in status code and null checks
- **IntelliSense Support**: Self-documenting with IDE integration
- **Maintainability**: Automatically sync with API changes
- **Reduced Boilerplate**: Eliminates repetitive HTTP client code

## Setting Up the Project

### 1. Create a Console Application

```bash
dotnet new console
```

### 2. Install Required Package

```bash
dotnet add package NSwag.CodeGeneration.CSharp
```

### 3. Add Using Statements

```csharp
using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;
using NSwag;
using NSwag.CodeGeneration.CSharp;
```

## Manual HTTP Client Approach (Before Generation)

Here's what making API requests manually looks like:

```csharp
// Create HTTP client
var httpClient = new HttpClient();
var apiBaseUrl = "https://localhost:5230"; // Your API URL

// Make GET request
var httpResults = await httpClient.GetAsync($"{apiBaseUrl}/blogs");

// Check status code
if (httpResults.StatusCode != System.Net.HttpStatusCode.OK)
{
    Console.WriteLine("Failed to fetch blogs");
    return;
}

// Read response stream
var stream = await httpResults.Content.ReadAsStreamAsync();

// Configure JSON options
var deserializerOptions = new System.Text.Json.JsonSerializerOptions
{
    PropertyNameCaseInsensitive = true
};

// Deserialize response
var blogs = await System.Text.Json.JsonSerializer.DeserializeAsync<List<Blog>>(
    stream, 
    deserializerOptions
);

// Handle null response
if (blogs != null)
{
    foreach (var blog in blogs)
    {
        Console.WriteLine($"Title: {blog.Title}, Body: {blog.Body}");
    }
}
```

### Blog Model Class

```csharp
public class Blog
{
    public required string Title { get; set; }
    public required string Body { get; set; }
}
```

## Swagger Client Generator Implementation

### 1. Create the Generator Class

```csharp
public class SwaggerClientGenerator
{
    public async Task GenerateClient()
    {
        // Create HTTP client to fetch Swagger JSON
        var httpClient = new HttpClient();
        
        // Download the Swagger/OpenAPI specification
        var swaggerJson = await httpClient.GetStringAsync(
            "https://localhost:5230/swagger/v1/swagger.json"
        );

        // Parse the OpenAPI document
        var document = await OpenApiDocument.FromJsonAsync(swaggerJson);

        // Configure generation settings
        var settings = new CSharpClientGeneratorSettings
        {
            ClassName = "BlogApiClient",
            CSharpGeneratorSettings =
            {
                Namespace = "BlogApi"
            }
        };

        // Create the generator
        var generator = new CSharpClientGenerator(document, settings);

        // Generate the client code
        var code = generator.GenerateFile();

        // Save to file
        await File.WriteAllTextAsync("BlogApiClient.cs", code);
    }
}
```

### 2. Generate the Client (Run Once)

```csharp
// In your Main method or startup code
await new SwaggerClientGenerator().GenerateClient();
```

This creates a `BlogApiClient.cs` file with hundreds of lines of generated code that handles all API interactions.

## Using the Generated Client

### 1. Import the Generated Namespace

```csharp
using BlogApi; // The namespace we specified in settings
```

### 2. Create and Use the Client

```csharp
// Initialize the generated client
var httpClient = new HttpClient();
var apiBaseUrl = "https://localhost:5230";
var client = new BlogApiClient(apiBaseUrl, httpClient);

// Get all blogs (replaces all the manual code above)
var blogs = await client.GetAllAsync();

// Display results
foreach (var blog in blogs)
{
    Console.WriteLine($"Title: {blog.Title}, Body: {blog.Body}");
}
```

### 3. Additional Operations

```csharp
// Delete a blog
await client.DeleteAsync(1); // Delete blog with ID 1

// Create a new blog
var newBlog = new Blog
{
    Title = "My New Title",
    Body = "This is the blog content"
};
await client.PostAsync(newBlog);

// Update existing blog
await client.PutAsync(1, updatedBlog);
```

## Complete Example: Before vs After

### Before (Manual Approach - ~40 lines)

```csharp
var httpClient = new HttpClient();
var apiBaseUrl = "https://localhost:5230";

try
{
    var httpResults = await httpClient.GetAsync($"{apiBaseUrl}/blogs");
    
    if (httpResults.StatusCode != System.Net.HttpStatusCode.OK)
    {
        Console.WriteLine("Failed to fetch blogs");
        return;
    }

    var stream = await httpResults.Content.ReadAsStreamAsync();
    var deserializerOptions = new System.Text.Json.JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    };

    var blogs = await System.Text.Json.JsonSerializer.DeserializeAsync<List<Blog>>(
        stream, deserializerOptions);

    if (blogs != null)
    {
        foreach (var blog in blogs)
        {
            Console.WriteLine($"Title: {blog.Title}, Body: {blog.Body}");
        }
    }
}
catch (Exception ex)
{
    Console.WriteLine($"Error: {ex.Message}");
}
```

### After (Generated Client - ~6 lines)

```csharp
var httpClient = new HttpClient();
var client = new BlogApiClient("https://localhost:5230", httpClient);

var blogs = await client.GetAllAsync();
foreach (var blog in blogs)
{
    Console.WriteLine($"Title: {blog.Title}, Body: {blog.Body}");
}
```

## When to Regenerate the Client

Regenerate your API client whenever you:
- Add new endpoints to your API
- Modify existing endpoint signatures
- Change data models or DTOs
- Update API versioning

Simply run the generator again:

```csharp
await new SwaggerClientGenerator().GenerateClient();
```

## Multi-Language Support

The same approach works for other languages. For TypeScript:

```csharp
// Replace CSharpClientGenerator with TypeScriptClientGenerator
var generator = new TypeScriptClientGenerator(document, typeScriptSettings);
```

## Best Practices

1. **Separate Projects**: In production, keep the generator in a separate project or build step
2. **Version Control**: Consider whether to commit generated files or generate them during build
3. **Error Handling**: The generated client handles most error cases automatically
4. **Type Safety**: Generated clients provide compile-time checking of API contracts
5. **Documentation**: Generated clients include IntelliSense documentation from your API

## Benefits Summary

✅ **Shorter Code**: 6 lines vs 40+ lines of manual HTTP handling  
✅ **Type Safety**: Compile-time checking prevents runtime errors  
✅ **Error Handling**: Automatic status code and null reference handling  
✅ **Self-Documenting**: IntelliSense support with parameter hints  
✅ **Always Up-to-Date**: Regenerate when API changes  
✅ **Multi-Language**: Generate clients for different platforms  

This approach saves significant development time and ensures your client code stays synchronized with your API changes.