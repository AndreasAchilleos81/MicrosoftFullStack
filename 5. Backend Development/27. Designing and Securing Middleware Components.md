# ASP.NET Core Middleware Security Lab Guide

In this lab, we're going to be securing our ASP.NET application using middleware. This is all going to be kind of simulated, but it'll give us an idea of how we can secure an ASP.NET application using various middleware components.

## Step 1: Setting Up the Application

First, we set up our basic application structure. We configure the web server to use HTTP only (in a real application, we'd want to use HTTPS, but this demonstrates how we can configure our web server with various options).

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configure Kestrel web server
builder.WebHost.ConfigureKestrel(options =>
{
    // Tell the application to listen on localhost at port 5294 (HTTP port)
    options.Listen(IPAddress.Loopback, 5294);
});

var app = builder.Build();

// Application will run here with all middleware
app.Run();
```

**Key Points:**
- `builder` variable gives us the ability to build out various features
- `ConfigureKestrel` configures the underlying ASP.NET lightweight web server
- We're setting the server to listen only on localhost port 5294 (HTTP)
- `app.Run()` starts the application and runs all the middleware we'll create

## Step 2: First Middleware - HTTPS Security Check

Our first middleware security component checks for a secure connection simulation.

```csharp
app.Use(async (context, next) =>
{
    // Check query string for 'secure=true'
    if (context.Request.Query["secure"] != "true")
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("Simulated HTTPS required");
        return; // Stop processing if not secure
    }
    
    await next(); // Continue to next middleware if secure
});
```

**How it works:**
- Checks the URL query string for `secure=true`
- Example URL: `http://localhost:5294?secure=true`
- If `secure` is not set to "true", returns HTTP 400 error
- In real-world applications, this would enforce actual HTTPS connections

################ Real world example of https #########################

Realistic HTTPS Checking Methods
Method 1: Check the Request Scheme (Most Common)

```
app.Use(async (context, next) =>
{
    // Actually check if the request is using HTTPS
    if (!context.Request.IsHttps)
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("HTTPS required");
        return;
    }
    
    await next();
});
```
Method 2: Check the URL Scheme

app.Use(async (context, next) =>
{
    // Check if the scheme is https://
    if (context.Request.Scheme != "https")
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("HTTPS connection required");
        return;
    }
    
    await next();
});

Method 3: Comprehensive HTTPS Validation

app.Use(async (context, next) =>
{
    var request = context.Request;
    
    // Multiple ways to verify HTTPS
    bool isSecure = request.IsHttps || 
                   request.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) ||
                   request.Headers["X-Forwarded-Proto"].ToString().Equals("https", StringComparison.OrdinalIgnoreCase);
    
    if (!isSecure)
    {
        context.Response.StatusCode = 426; // Upgrade Required
        context.Response.Headers.Add("Upgrade", "TLS/1.2");
        await context.Response.WriteAsync("HTTPS connection required for security");
        return;
    }
    
    await next();
});

Better Approach: Use Built-in ASP.NET Core Features
Instead of writing custom middleware, use the built-in security features:
Option 1: HTTPS Redirection (Recommended)

var builder = WebApplication.CreateBuilder(args);

// Configure HTTPS redirection
builder.Services.AddHttpsRedirection(options =>
{
    options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
    options.HttpsPort = 5001; // Your HTTPS port
});

var app = builder.Build();

// This automatically redirects HTTP to HTTPS
app.UseHttpsRedirection();

app.Run();

Option 2: Require HTTPS for Specific Endpoints

// Using attributes on controllers/actions
[RequireHttps]
public class SecureController : ControllerBase
{
    // All actions in this controller require HTTPS
}

// Or on specific actions
public class HomeController : ControllerBase
{
    [RequireHttps]
    public IActionResult SecureAction()
    {
        return Ok("This action requires HTTPS");
    }
}

Option 3: HSTS (HTTP Strict Transport Security)

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHsts(options =>
{
    options.MaxAge = TimeSpan.FromDays(365);
    options.IncludeSubDomains = true;
    options.Preload = true;
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseHsts(); // Only in production
}

app.UseHttpsRedirection();
app.Run();

How to Test Real HTTPS
1. Configure Your App for HTTPS
In appsettings.json:

{
  "Kestrel": {
    "Endpoints": {
      "Http": {
        "Url": "http://localhost:5000"
      },
      "Https": {
        "Url": "https://localhost:5001"
      }
    }
  }
}

2. Test with Different URLs

// This middleware will show you the actual request details
app.Use(async (context, next) =>
{
    var request = context.Request;
    
    Console.WriteLine($"Scheme: {request.Scheme}");
    Console.WriteLine($"IsHttps: {request.IsHttps}");
    Console.WriteLine($"Host: {request.Host}");
    Console.WriteLine($"Full URL: {request.Scheme}://{request.Host}{request.Path}");
    
    await next();
});

Test URLs:

http://localhost:5000 → Should show IsHttps: False
https://localhost:5001 → Should show IsHttps: True

Real-World Example

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Real HTTPS checking middleware
app.Use(async (context, next) =>
{
    // Log the actual connection details
    Console.WriteLine($"Request: {context.Request.Scheme}://{context.Request.Host}{context.Request.Path}");
    Console.WriteLine($"Is HTTPS: {context.Request.IsHttps}");
    
    // Enforce HTTPS in production
    if (!app.Environment.IsDevelopment() && !context.Request.IsHttps)
    {
        var httpsUrl = $"https://{context.Request.Host}{context.Request.Path}{context.Request.QueryString}";
        context.Response.Redirect(httpsUrl, true);
        return;
    }
    
    await next();
});

app.MapGet("/", () => "Hello World!");
app.Run();

The key difference is using context.Request.IsHttps or context.Request.Scheme instead of checking arbitrary query parameters. This actually examines the connection protocol, not just user input.


##########################################################



## Step 3: Input Validation Middleware

This middleware validates user input to prevent malicious code injection.

```csharp
app.Use(async (context, next) =>
{
    var input = context.Request.Query["input"];
    
    if (!IsValidInput(input))
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("Invalid input");
        return;
    }
    
    await next();
});

// Input validation method
static bool IsValidInput(string input)
{
    if (string.IsNullOrEmpty(input))
        return false;
    
    // Check if input contains only letters and digits
    // and doesn't contain script tags
    return input.All(char.IsLetterOrDigit) && 
           !input.Contains("script", StringComparison.OrdinalIgnoreCase);
}
```

**Security purpose:**
- Prevents users from passing malicious code in query strings
- Example of valid input: `http://localhost:5294?input=hello123&secure=true`
- Example of invalid input: `http://localhost:5294?input=<script>alert('hack')</script>&secure=true`
- Filters out potential malware, viruses, or malicious scripts

## Step 4: Authorization Middleware

This middleware checks for unauthorized access attempts.

```csharp
app.Use(async (context, next) =>
{
    // Check if user is trying to access unauthorized path
    if (context.Request.Path.StartsWithSegments("/unauthorized"))
    {
        await context.Response.WriteAsync("Unauthorized access");
        return; // Stop processing
    }
    
    await next();
});
```

**Example URLs:**
- Allowed: `http://localhost:5294/home?secure=true&input=validdata`
- Blocked: `http://localhost:5294/unauthorized?secure=true&input=validdata`

## Step 5: Authentication Middleware

This middleware handles user authentication and sets secure cookies.

```csharp
app.Use(async (context, next) =>
{
    var isAuthenticated = context.Request.Query["authenticated"] == "true";
    
    if (!isAuthenticated)
    {
        context.Response.StatusCode = 403; // Forbidden
        await context.Response.WriteAsync("Access denied");
        return;
    }
    
    // Set secure cookie for authenticated users
    context.Response.Cookies.Append("SecureData", "secure_data", new CookieOptions
    {
        HttpOnly = true,  // Prevents client-side script access
        Secure = true     // Only sent over HTTPS (simulated)
    });
    
    await next();
});
```

**Authentication flow:**
- Checks query parameter `authenticated=true`
- Example: `http://localhost:5294?secure=true&input=validdata&authenticated=true`
- If authenticated, sets a secure cookie
- If not authenticated, returns HTTP 403 (Forbidden)

## Step 6: Asynchronous Processing Middleware

The final middleware simulates asynchronous processing.

```csharp
app.Use(async (context, next) =>
{
    // Simulate asynchronous processing delay
    await Task.Delay(100);
    
    await context.Response.WriteAsync("We processed the response asynchronously");
    
    await next();
});
```

**Purpose:**
- Demonstrates how to handle asynchronous operations in middleware
- Adds a 100ms delay to simulate real-world processing time
- Shows that middleware can perform time-consuming operations without blocking

## Complete Example

Here's how all the middleware components work together:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.WebHost.ConfigureKestrel(options =>
{
    options.Listen(IPAddress.Loopback, 5294);
});

var app = builder.Build();

// Middleware 1: HTTPS Security Check
app.Use(async (context, next) =>
{
    if (context.Request.Query["secure"] != "true")
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("Simulated HTTPS required");
        return;
    }
    await next();
});

// Middleware 2: Input Validation
app.Use(async (context, next) =>
{
    var input = context.Request.Query["input"];
    if (!IsValidInput(input))
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("Invalid input");
        return;
    }
    await next();
});

// Middleware 3: Authorization Check
app.Use(async (context, next) =>
{
    if (context.Request.Path.StartsWithSegments("/unauthorized"))
    {
        await context.Response.WriteAsync("Unauthorized access");
        return;
    }
    await next();
});

// Middleware 4: Authentication
app.Use(async (context, next) =>
{
    var isAuthenticated = context.Request.Query["authenticated"] == "true";
    if (!isAuthenticated)
    {
        context.Response.StatusCode = 403;
        await context.Response.WriteAsync("Access denied");
        return;
    }
    
    context.Response.Cookies.Append("SecureData", "secure_data", new CookieOptions
    {
        HttpOnly = true,
        Secure = true
    });
    
    await next();
});

// Middleware 5: Asynchronous Processing
app.Use(async (context, next) =>
{
    await Task.Delay(100);
    await context.Response.WriteAsync("We processed the response asynchronously");
    await next();
});

static bool IsValidInput(string input)
{
    if (string.IsNullOrEmpty(input))
        return false;
    
    return input.All(char.IsLetterOrDigit) && 
           !input.Contains("script", StringComparison.OrdinalIgnoreCase);
}

app.Run();
```

## Testing the Security Middleware

**Valid request that passes all security checks:**
```
http://localhost:5294?secure=true&input=validdata123&authenticated=true
```

**Invalid requests that will be blocked:**

1. **Missing security parameter:**
   ```
   http://localhost:5294?input=validdata123&authenticated=true
   ```
   *Result: "Simulated HTTPS required"*

2. **Invalid input with script:**
   ```
   http://localhost:5294?secure=true&input=<script>&authenticated=true
   ```
   *Result: "Invalid input"*

3. **Unauthorized path:**
   ```
   http://localhost:5294/unauthorized?secure=true&input=validdata&authenticated=true
   ```
   *Result: "Unauthorized access"*

4. **Not authenticated:**
   ```
   http://localhost:5294?secure=true&input=validdata123&authenticated=false
   ```
   *Result: "Access denied"*

## How the Middleware Pipeline Works

The middleware process starts at the top and goes through each middleware component in order:

1. **HTTPS Check** → Ensures secure connection
2. **Input Validation** → Prevents malicious input
3. **Authorization** → Checks access permissions
4. **Authentication** → Verifies user identity
5. **Asynchronous Processing** → Handles the request

Each middleware can either:
- **Continue** to the next middleware by calling `await next()`
- **Stop** the pipeline by returning without calling `next()`

This layered approach creates a robust security system where each component checks for specific security conditions, ensuring that only valid, authenticated, and authorized requests reach your application logic.