# Binary Search Algorithm

## Overview

Binary search is a search algorithm that is particularly useful when searching for items in large datasets. Compared to linear search, which takes a "start at the beginning and move to the end" approach, binary search uses a **divide and conquer** strategy. It divides a large dataset into two parts and continues to winnow down each part until it finds the target item.

## How Binary Search Works

Binary search operates by:

1. Setting left and right boundaries of the search space
2. Calculating the midpoint between these boundaries
3. Comparing the value at the midpoint with the target
4. Adjusting the search boundaries based on the comparison
5. Repeating until the target is found or the search space is exhausted

## Performance Characteristics

Binary search excels with large datasets. Even with millions of elements, it maintains excellent performance due to its divide-and-conquer approach. While linear search must evaluate each item sequentially (potentially checking millions of records), binary search quickly narrows down the possibilities.

## C# Implementation

### Basic Setup

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Small array example
        int[] numbers = { 10, 20, 30, 40, 50 };
        int target = 30;
        
        int result = Search.BinarySearch(numbers, target);
        
        if (result >= 0)
        {
            Console.WriteLine($"Element found at index: {result}");
        }
        else
        {
            Console.WriteLine("Element was not found");
        }
    }
}
```

### Binary Search Algorithm

```csharp
public class Search
{
    public static int BinarySearch(int[] array, int target)
    {
        int left = 0;
        int right = array.Length - 1;
        
        while (left <= right)
        {
            // Calculate midpoint
            int mid = left + (right - left) / 2;
            
            // Check if target is at midpoint
            if (array[mid] == target)
            {
                return mid;
            }
            
            // If target is greater, ignore left half
            if (array[mid] < target)
            {
                left = mid + 1;
            }
            // If target is smaller, ignore right half
            else
            {
                right = mid - 1;
            }
        }
        
        // Target not found
        return -1;
    }
}
```

### Large Dataset Example

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Create array with 100,000 elements
        int[] largeArray = new int[100000];
        for (int i = 0; i < largeArray.Length; i++)
        {
            largeArray[i] = i;
        }
        
        // Pick a random target to search for
        Random random = new Random();
        int randomTarget = random.Next(0, largeArray.Length);
        
        Console.WriteLine($"Searching for: {randomTarget}");
        
        int result = Search.BinarySearch(largeArray, randomTarget);
        
        if (result >= 0)
        {
            Console.WriteLine($"Element found at index: {result}");
        }
        else
        {
            Console.WriteLine("Element was not found");
        }
    }
}
```

### Performance Testing

```csharp
// Test with 1 million elements
int[] millionArray = new int[1000000];
for (int i = 0; i < millionArray.Length; i++)
{
    millionArray[i] = i;
}

Random random = new Random();
int target = random.Next(0, millionArray.Length);

int result = Search.BinarySearch(millionArray, target);
Console.WriteLine($"Found at index: {result}");

// Test with 10 million elements
int[] tenMillionArray = new int[10000000];
for (int i = 0; i < tenMillionArray.Length; i++)
{
    tenMillionArray[i] = i;
}

target = random.Next(0, tenMillionArray.Length);
result = Search.BinarySearch(tenMillionArray, target);
Console.WriteLine($"Found at index: {result}");
```

## Key Points

- **Zero-based indexing**: Array indices start at 0, so an array of length 50 has indices from 0 to 49
- **Midpoint calculation**: `mid = left + (right - left) / 2` prevents integer overflow
- **Boundary adjustment**: The search space is continuously halved by adjusting left or right boundaries
- **Return value**: Returns the index if found, -1 if not found
- **Prerequisite**: The array must be sorted for binary search to work correctly

## Binary Search vs Linear Search

**Linear Search:**
- Checks every element sequentially from start to finish
- Time complexity: O(n)
- For an item at position 9,000,000 in a 10 million element array, it must check 9 million items

**Binary Search:**
- Divides the search space in half with each iteration
- Time complexity: O(log n)
- Can search 10 million elements in approximately 24 comparisons
- Significantly faster for large datasets