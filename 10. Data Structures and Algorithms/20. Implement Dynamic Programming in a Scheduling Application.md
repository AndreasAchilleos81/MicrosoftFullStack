# Dynamic Programming: Resource Scheduling with Knapsack Algorithm in .NET Core

## Introduction

In this lab, we're going to implement a dynamic programming algorithm to solve a resource scheduling problem in .NET Core. We'll use the knapsack model to figure out how to optimize resource allocation. Dynamic programming allows you to adjust to data that's coming in, and using memoization can actually improve the performance of a dynamic program significantly.

## Step 1: Setting Up the Application

First, we'll create a new console application for our scheduling implementation:

```bash
dotnet new console -n SchedulingApp
cd SchedulingApp
code .
```

This creates a new .NET Core console application and opens it in Visual Studio Code.

## Step 2: Implementing the Recursive Knapsack Algorithm

The recursive knapsack algorithm is the foundation of our solution. In this implementation, we have a knapsack method that accepts values, weights, capacity, and an integer n.

### How the Recursive Algorithm Works

The algorithm works as follows:

1. First, we check to see if n is equal to zero, or if capacity is equal to zero. If either is true, we're going to return zero from whatever method called this method - just return back from that function.

2. If neither is zero, then we check whether the weights of n minus one (because it's a zero-based array) are less than or equal to the capacity.

3. We run the `Math.Max` function, and we're also going to run it again recursively, passing values into knapsack again. We're actually getting another value and returning the value for that as we call that.

4. We're running it a couple of times, passing in capacity minus weights[n-1], and then capacity with n minus one. We're doing n minus one both times because it's a zero-based array.

This is our regular knapsack function without any optimization.

## Step 3: Applying Memoization to the Knapsack Function

To optimize performance, we'll apply memoization to the knapsack function. This involves storing calculations so that we don't have to recalculate if we've already done the calculation.

### Setting Up Memoization

First, we create a dictionary called `memo`. This will be a dictionary of string and int objects, instantiated at the top of our program.

### How Memoization Improves Performance

In the memoized version (`KnapsackMemo`), we store pre-calculated values in the dictionary object we created. We store them, and then if the result of that calculation is already in there, we're not going to recalculate, which should save time as we run the application.

### The Memoization Process

1. The first thing we check is if the memo contains the key that we're using. The key is just made up of the number, a dash, and then capacity (e.g., "n-capacity").

2. If the key exists in the memo, then we just return the value that's at `memo[key]`.

3. If not, then we again check to see if n is equal to zero or if capacity is equal to zero. If either is true, then we return zero.

4. Otherwise, we run through essentially the same algorithm that we did in the original knapsack method, except here we're going to also add the memo with the index of key to the result of `KnapsackMemo`, just so we can store that value.

5. Then we use that stored value again in the future when we do the evaluation at the top of the function.

6. Finally, we return `memo[key]` back to the calling function.

## Understanding Dynamic Programming

These are two different ways that you can implement dynamic programming:

1. **Recursive approach** - The straightforward recursive solution that recalculates values
2. **Memoized approach** - The optimized version that stores and reuses previously calculated results

Dynamic programming allows you to adjust to data that's coming in. Using memoization can dramatically improve the performance of a dynamic program like the knapsack algorithm, especially when dealing with overlapping subproblems where the same calculations would otherwise be performed multiple times.




using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace SchedulingApp
{
    /// <summary>
    /// Represents a resource item with value and weight
    /// </summary>
    public class ResourceItem
    {
        public string Name { get; set; }
        public int Value { get; set; }
        public int Weight { get; set; }

        public ResourceItem(string name, int value, int weight)
        {
            Name = name;
            Value = value;
            Weight = weight;
        }

        public override string ToString() => $"{Name} (Value: {Value}, Weight: {Weight})";
    }

    /// <summary>
    /// Solution result containing the optimal value and selected items
    /// </summary>
    public class KnapsackSolution
    {
        public int OptimalValue { get; set; }
        public List<ResourceItem> SelectedItems { get; set; }
        public long ExecutionTimeMs { get; set; }
        public int RecursiveCalls { get; set; }

        public KnapsackSolution()
        {
            SelectedItems = new List<ResourceItem>();
        }
    }

    public class KnapsackScheduler
    {
        // Memoization dictionary for storing computed results
        private readonly Dictionary<string, int> memo = new Dictionary<string, int>();
        private int recursiveCallCount = 0;

        /// <summary>
        /// Solves the knapsack problem using standard recursive approach
        /// </summary>
        public KnapsackSolution SolveRecursive(ResourceItem[] items, int capacity)
        {
            recursiveCallCount = 0;
            var stopwatch = Stopwatch.StartNew();

            int[] values = items.Select(i => i.Value).ToArray();
            int[] weights = items.Select(i => i.Weight).ToArray();

            int optimalValue = Knapsack(values, weights, capacity, items.Length);

            stopwatch.Stop();

            return new KnapsackSolution
            {
                OptimalValue = optimalValue,
                SelectedItems = ReconstructSolution(items, capacity, values, weights),
                ExecutionTimeMs = stopwatch.ElapsedMilliseconds,
                RecursiveCalls = recursiveCallCount
            };
        }

        /// <summary>
        /// Solves the knapsack problem using memoization for optimization
        /// </summary>
        public KnapsackSolution SolveMemoized(ResourceItem[] items, int capacity)
        {
            memo.Clear();
            recursiveCallCount = 0;
            var stopwatch = Stopwatch.StartNew();

            int[] values = items.Select(i => i.Value).ToArray();
            int[] weights = items.Select(i => i.Weight).ToArray();

            int optimalValue = KnapsackMemo(values, weights, capacity, items.Length);

            stopwatch.Stop();

            return new KnapsackSolution
            {
                OptimalValue = optimalValue,
                SelectedItems = ReconstructSolutionMemo(items, capacity, values, weights),
                ExecutionTimeMs = stopwatch.ElapsedMilliseconds,
                RecursiveCalls = recursiveCallCount
            };
        }

        /// <summary>
        /// Standard recursive knapsack implementation without memoization
        /// </summary>
        private int Knapsack(int[] values, int[] weights, int capacity, int n)
        {
            recursiveCallCount++;

            // Base case: no items left or no capacity
            if (n == 0 || capacity == 0)
            {
                return 0;
            }

            // If weight of the nth item is more than capacity, skip it
            if (weights[n - 1] > capacity)
            {
                return Knapsack(values, weights, capacity, n - 1);
            }

            // Return maximum of two cases:
            // 1. nth item included
            // 2. nth item not included
            return Math.Max(
                values[n - 1] + Knapsack(values, weights, capacity - weights[n - 1], n - 1),
                Knapsack(values, weights, capacity, n - 1)
            );
        }

        /// <summary>
        /// Optimized knapsack implementation with memoization
        /// </summary>
        private int KnapsackMemo(int[] values, int[] weights, int capacity, int n)
        {
            recursiveCallCount++;

            // Create unique key for this subproblem
            string key = $"{n}-{capacity}";

            // Check if result is already computed
            if (memo.ContainsKey(key))
            {
                return memo[key];
            }

            // Base case: no items left or no capacity
            if (n == 0 || capacity == 0)
            {
                return 0;
            }

            int result;

            // If weight of the nth item is more than capacity, skip it
            if (weights[n - 1] > capacity)
            {
                result = KnapsackMemo(values, weights, capacity, n - 1);
            }
            else
            {
                // Return maximum of two cases:
                // 1. nth item included
                // 2. nth item not included
                result = Math.Max(
                    values[n - 1] + KnapsackMemo(values, weights, capacity - weights[n - 1], n - 1),
                    KnapsackMemo(values, weights, capacity, n - 1)
                );
            }

            // Store result in memo before returning
            memo[key] = result;

            return result;
        }

        /// <summary>
        /// Reconstructs which items were selected in the optimal solution (recursive version)
        /// </summary>
        private List<ResourceItem> ReconstructSolution(ResourceItem[] items, int capacity, int[] values, int[] weights)
        {
            var selected = new List<ResourceItem>();
            int n = items.Length;
            int remainingCapacity = capacity;

            for (int i = n - 1; i >= 0 && remainingCapacity > 0; i--)
            {
                // Check if this item was included
                int withoutItem = (i > 0) ? Knapsack(values, weights, remainingCapacity, i) : 0;
                int withItem = Knapsack(values, weights, remainingCapacity, i + 1);

                if (withItem != withoutItem && weights[i] <= remainingCapacity)
                {
                    selected.Add(items[i]);
                    remainingCapacity -= weights[i];
                }
            }

            return selected;
        }

        /// <summary>
        /// Reconstructs which items were selected in the optimal solution (memoized version)
        /// </summary>
        private List<ResourceItem> ReconstructSolutionMemo(ResourceItem[] items, int capacity, int[] values, int[] weights)
        {
            var selected = new List<ResourceItem>();
            int n = items.Length;
            int remainingCapacity = capacity;

            for (int i = n - 1; i >= 0 && remainingCapacity > 0; i--)
            {
                string keyWith = $"{i + 1}-{remainingCapacity}";
                string keyWithout = $"{i}-{remainingCapacity}";

                int withItem = memo.ContainsKey(keyWith) ? memo[keyWith] : 0;
                int withoutItem = memo.ContainsKey(keyWithout) ? memo[keyWithout] : 0;

                if (withItem != withoutItem && weights[i] <= remainingCapacity)
                {
                    selected.Add(items[i]);
                    remainingCapacity -= weights[i];
                }
            }

            return selected;
        }

        /// <summary>
        /// Gets the current size of the memoization cache
        /// </summary>
        public int GetMemoSize() => memo.Count;
    }

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("=== Resource Scheduling: Knapsack Problem with Dynamic Programming ===\n");

            // Define resource items
            var resources = new ResourceItem[]
            {
                new ResourceItem("Task A", 60, 10),
                new ResourceItem("Task B", 100, 20),
                new ResourceItem("Task C", 120, 30),
                new ResourceItem("Task D", 80, 15),
                new ResourceItem("Task E", 90, 25),
                new ResourceItem("Task F", 70, 18)
            };

            int capacity = 50;

            Console.WriteLine("Available Resources:");
            for (int i = 0; i < resources.Length; i++)
            {
                Console.WriteLine($"  {i + 1}. {resources[i]}");
            }
            Console.WriteLine($"\nCapacity Constraint: {capacity}");
            Console.WriteLine(new string('=', 70));

            var scheduler = new KnapsackScheduler();

            // Solve using recursive approach
            Console.WriteLine("\n--- RECURSIVE APPROACH (No Memoization) ---");
            var recursiveSolution = scheduler.SolveRecursive(resources, capacity);
            DisplaySolution(recursiveSolution, "Recursive");

            // Solve using memoized approach
            Console.WriteLine("\n--- MEMOIZED APPROACH (With Dynamic Programming) ---");
            var memoizedSolution = scheduler.SolveMemoized(resources, capacity);
            DisplaySolution(memoizedSolution, "Memoized");
            Console.WriteLine($"Memo cache size: {scheduler.GetMemoSize()} entries");

            // Performance comparison
            Console.WriteLine("\n=== PERFORMANCE COMPARISON ===");
            DisplayPerformanceComparison(recursiveSolution, memoizedSolution);

            // Test with larger dataset
            Console.WriteLine("\n=== STRESS TEST: Larger Dataset ===");
            RunStressTest();
        }

        static void DisplaySolution(KnapsackSolution solution, string approach)
        {
            Console.WriteLine($"Optimal Value: {solution.OptimalValue}");
            Console.WriteLine($"Execution Time: {solution.ExecutionTimeMs}ms");
            Console.WriteLine($"Recursive Calls: {solution.RecursiveCalls:N0}");
            Console.WriteLine($"Selected Items ({solution.SelectedItems.Count}):");
            
            int totalWeight = 0;
            foreach (var item in solution.SelectedItems)
            {
                Console.WriteLine($"  • {item}");
                totalWeight += item.Weight;
            }
            Console.WriteLine($"Total Weight Used: {totalWeight}");
        }

        static void DisplayPerformanceComparison(KnapsackSolution recursive, KnapsackSolution memoized)
        {
            double speedup = recursive.ExecutionTimeMs > 0 
                ? (double)recursive.ExecutionTimeMs / Math.Max(memoized.ExecutionTimeMs, 1) 
                : 1;
            
            double callReduction = recursive.RecursiveCalls > 0
                ? (1 - (double)memoized.RecursiveCalls / recursive.RecursiveCalls) * 100
                : 0;

            Console.WriteLine($"Speedup Factor: {speedup:F2}x faster");
            Console.WriteLine($"Recursive Call Reduction: {callReduction:F1}%");
            Console.WriteLine($"  Recursive: {recursive.RecursiveCalls:N0} calls");
            Console.WriteLine($"  Memoized:  {memoized.RecursiveCalls:N0} calls");
        }

        static void RunStressTest()
        {
            var largeDataset = new ResourceItem[15];
            var random = new Random(42);
            
            for (int i = 0; i < largeDataset.Length; i++)
            {
                largeDataset[i] = new ResourceItem(
                    $"Resource {i + 1}",
                    random.Next(50, 200),
                    random.Next(5, 30)
                );
            }

            int largeCapacity = 100;
            var scheduler = new KnapsackScheduler();

            Console.WriteLine($"Dataset Size: {largeDataset.Length} items");
            Console.WriteLine($"Capacity: {largeCapacity}\n");

            // Only test memoized version for large datasets
            Console.WriteLine("Testing Memoized Approach...");
            var memoizedSolution = scheduler.SolveMemoized(largeDataset, largeCapacity);
            
            Console.WriteLine($"✓ Completed in {memoizedSolution.ExecutionTimeMs}ms");
            Console.WriteLine($"  Optimal Value: {memoizedSolution.OptimalValue}");
            Console.WriteLine($"  Recursive Calls: {memoizedSolution.RecursiveCalls:N0}");
            Console.WriteLine($"  Selected {memoizedSolution.SelectedItems.Count} items");
            Console.WriteLine($"  Memo cache size: {scheduler.GetMemoSize()} entries");
        }
    }
}