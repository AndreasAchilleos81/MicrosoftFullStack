# Binary Search for Efficient API Request Handling

## Lab Overview

In this lab, we'll apply binary search to optimize search operations in a .NET Core application that handles API requests. We'll fetch user data from a public API, sort it, and implement binary search to efficiently locate specific users.

---

## Step 1: Fetch User Data from API

### Setting Up the Console Application

We'll create a simple console application that retrieves user data from an open-source test API and displays the usernames.

### Complete Implementation

```csharp
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Json;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        // Fetch users from API
        List<User> users = await FetchUsersFromAPI();
        
        // Display usernames
        Console.WriteLine("Fetched Users:");
        Console.WriteLine("==============");
        foreach (var user in users)
        {
            Console.WriteLine(user.Username);
        }
    }
    
    static async Task<List<User>> FetchUsersFromAPI()
    {
        // Create HTTP client
        HttpClient client = new HttpClient();
        
        // Set API URL - randomuser.me is an open-source public API for testing
        string url = "https://randomuser.me/api/?results=10";
        
        // Get response from API
        var response = await client.GetFromJsonAsync<ApiResponse>(url);
        
        // Populate users list
        List<User> users = new List<User>();
        foreach (var result in response.Results)
        {
            users.Add(new User
            {
                Username = result.Login.Username,
                FirstName = result.Name.First,
                LastName = result.Name.Last
            });
        }
        
        return users;
    }
}
```

### Supporting Classes

```csharp
// User class
public class User
{
    public string Username { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

// API Response classes for JSON deserialization
public class ApiResponse
{
    public List<Result> Results { get; set; }
}

public class Result
{
    public Name Name { get; set; }
    public Login Login { get; set; }
}

public class Name
{
    public string First { get; set; }
    public string Last { get; set; }
}

public class Login
{
    public string Username { get; set; }
}
```

### How It Works

1. **Create HTTP Client**: `HttpClient` handles the HTTP request
2. **Set URL**: `https://randomuser.me/api/?results=10` returns 10 random users
3. **Get JSON Response**: `GetFromJsonAsync` retrieves and deserializes JSON data
4. **Populate Users**: Loop through results and create User objects
5. **Display**: Write usernames to console

### Expected Output

```
Fetched Users:
==============
bigcat280
happybird123
silverswan567
tinydog789
...
```

---

## Step 2: Sort List and Implement Binary Search

### Why Sorting is Required

**Critical Requirement:** Binary search requires a sorted list to work properly. Without sorting, the algorithm cannot make correct decisions about which half of the data to search.

### Add Sorting

```csharp
static async Task Main(string[] args)
{
    // Fetch users from API
    List<User> users = await FetchUsersFromAPI();
    
    // IMPORTANT: Sort the list by username for binary search
    users.Sort((a, b) => a.Username.CompareTo(b.Username));
    
    // Display sorted usernames
    Console.WriteLine("Sorted Users:");
    Console.WriteLine("=============");
    foreach (var user in users)
    {
        Console.WriteLine(user.Username);
    }
    
    Console.WriteLine();
    
    // Get username to search for
    Console.Write("Enter username to search: ");
    string searchUsername = Console.ReadLine();
    
    // Perform binary search
    User foundUser = BinarySearch(users, searchUsername);
    
    // Display results
    if (foundUser != null)
    {
        Console.WriteLine($"\nUser Found!");
        Console.WriteLine($"Username: {foundUser.Username}");
        Console.WriteLine($"Name: {foundUser.FirstName} {foundUser.LastName}");
    }
    else
    {
        Console.WriteLine("\nUser not found.");
    }
}
```

### Binary Search Implementation

```csharp
static User BinarySearch(List<User> users, string targetUsername)
{
    int left = 0;
    int right = users.Count - 1;
    
    while (left <= right)
    {
        // Calculate midpoint
        int mid = left + (right - left) / 2;
        
        // Compare username at midpoint with target
        int comparison = users[mid].Username.CompareTo(targetUsername);
        
        // Found the target
        if (comparison == 0)
        {
            return users[mid];
        }
        
        // Target is in right half
        if (comparison < 0)
        {
            left = mid + 1;
        }
        // Target is in left half
        else
        {
            right = mid - 1;
        }
    }
    
    // Not found
    return null;
}
```

**Key Components:**
- **left and right**: Boundaries of the search space
- **mid**: Current midpoint being evaluated
- **CompareTo**: String comparison for alphabetical ordering
- Returns the User object when found, null otherwise

---

## Step 3: Testing the Binary Search

### Running the Complete Application

```csharp
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Json;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        Console.WriteLine("Fetching users from API...");
        Console.WriteLine();
        
        // Fetch users from API
        List<User> users = await FetchUsersFromAPI();
        
        // Sort the list by username
        users.Sort((a, b) => a.Username.CompareTo(b.Username));
        
        // Display sorted usernames
        Console.WriteLine("Available Users:");
        Console.WriteLine("================");
        foreach (var user in users)
        {
            Console.WriteLine($"- {user.Username}");
        }
        
        Console.WriteLine();
        Console.WriteLine("Enter username to search (or 'quit' to exit):");
        
        // Search loop
        while (true)
        {
            Console.Write("> ");
            string searchUsername = Console.ReadLine();
            
            if (searchUsername.ToLower() == "quit")
                break;
            
            // Perform binary search
            User foundUser = BinarySearch(users, searchUsername);
            
            // Display results
            if (foundUser != null)
            {
                Console.WriteLine($"✓ User Found!");
                Console.WriteLine($"  Username: {foundUser.Username}");
                Console.WriteLine($"  Name: {foundUser.FirstName} {foundUser.LastName}");
            }
            else
            {
                Console.WriteLine($"✗ User '{searchUsername}' not found.");
            }
            Console.WriteLine();
        }
    }
    
    static async Task<List<User>> FetchUsersFromAPI()
    {
        HttpClient client = new HttpClient();
        string url = "https://randomuser.me/api/?results=10";
        
        var response = await client.GetFromJsonAsync<ApiResponse>(url);
        
        List<User> users = new List<User>();
        foreach (var result in response.Results)
        {
            users.Add(new User
            {
                Username = result.Login.Username,
                FirstName = result.Name.First,
                LastName = result.Name.Last
            });
        }
        
        return users;
    }
    
    static User BinarySearch(List<User> users, string targetUsername)
    {
        int left = 0;
        int right = users.Count - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            int comparison = users[mid].Username.CompareTo(targetUsername);
            
            if (comparison == 0)
            {
                return users[mid];
            }
            
            if (comparison < 0)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        
        return null;
    }
}

// Supporting classes
public class User
{
    public string Username { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

public class ApiResponse
{
    public List<Result> Results { get; set; }
}

public class Result
{
    public Name Name { get; set; }
    public Login Login { get; set; }
}

public class Name
{
    public string First { get; set; }
    public string Last { get; set; }
}

public class Login
{
    public string Username { get; set; }
}
```

### Sample Interaction

```
Fetching users from API...

Available Users:
================
- bigcat280
- bluedog456
- greenmouse789
- happybird123
- redfish321
- silverswan567
- smallfrog234
- tinydog789
- whiterabbit890
- yellowlion654

Enter username to search (or 'quit' to exit):
> bigcat280
✓ User Found!
  Username: bigcat280
  Name: John Smith

> invaliduser
✗ User 'invaliduser' not found.

> quit
```

---

## How Binary Search Works in This Context

1. **User enters a username** (e.g., "bigcat280")
2. **Binary search narrows down** the sorted list:
   - Compares with middle username
   - Eliminates half of the list
   - Repeats until found
3. **Returns the User object** with associated first and last name
4. **Displays the result** to the user

---

## Performance Characteristics

### Small Dataset (10 users)
- Binary search is very fast
- Performance difference with linear search is minimal
- Demonstrates the algorithm effectively

### Large Dataset (1000+ users)
- Binary search remains very quick
- Significant performance advantage over linear search
- Scales efficiently as data grows

### Key Point
Even though we're working with a small dataset (10 users), binary search demonstrates its efficiency. As the dataset grows (which it would in a real-world API scenario), binary search maintains excellent performance.

---

## Enhanced Version with Error Handling

```csharp
static async Task<List<User>> FetchUsersFromAPI()
{
    try
    {
        HttpClient client = new HttpClient();
        client.Timeout = TimeSpan.FromSeconds(10);
        
        string url = "https://randomuser.me/api/?results=10";
        
        var response = await client.GetFromJsonAsync<ApiResponse>(url);
        
        if (response?.Results == null || response.Results.Count == 0)
        {
            Console.WriteLine("No users returned from API.");
            return new List<User>();
        }
        
        List<User> users = new List<User>();
        foreach (var result in response.Results)
        {
            users.Add(new User
            {
                Username = result.Login.Username,
                FirstName = result.Name.First,
                LastName = result.Name.Last
            });
        }
        
        return users;
    }
    catch (HttpRequestException ex)
    {
        Console.WriteLine($"Error fetching data from API: {ex.Message}");
        return new List<User>();
    }
    catch (TaskCanceledException)
    {
        Console.WriteLine("Request timed out.");
        return new List<User>();
    }
}

static User BinarySearch(List<User> users, string targetUsername)
{
    // Validate input
    if (users == null || users.Count == 0)
    {
        return null;
    }
    
    if (string.IsNullOrWhiteSpace(targetUsername))
    {
        return null;
    }
    
    int left = 0;
    int right = users.Count - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        int comparison = string.Compare(
            users[mid].Username, 
            targetUsername, 
            StringComparison.OrdinalIgnoreCase
        );
        
        if (comparison == 0)
        {
            return users[mid];
        }
        
        if (comparison < 0)
        {
            left = mid + 1;
        }
        else
        {
            right = mid - 1;
        }
    }
    
    return null;
}
```

---

## Key Takeaways

### Critical Requirements
1. **Sort data first** - Binary search requires sorted data
2. **Use consistent comparison** - Ensure the same comparison method for sorting and searching
3. **Handle edge cases** - Validate inputs and handle empty lists

### Performance Benefits
- Fast even with small datasets
- Scales efficiently as data grows
- Maintains consistent performance regardless of target position

### Real-World Applications
- User lookup systems
- Product catalogs
- Customer databases
- Any scenario requiring efficient search in sorted data

### Implementation Notes
- The `CompareTo` method handles string comparison for alphabetical ordering
- Binary search returns the entire User object, not just an index
- The algorithm narrows down possibilities with each iteration
- Returning `null` indicates the user was not found

---

## Summary

This lab demonstrates a practical implementation of binary search in a real-world scenario:
- Fetching data from an external API
- Sorting the data for binary search compatibility
- Implementing efficient search functionality
- Handling user input and displaying results

The combination of API integration and binary search showcases how this algorithm optimizes search operations in back-end systems, making it an essential tool for efficient data retrie