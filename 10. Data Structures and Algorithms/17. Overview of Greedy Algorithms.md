# Greedy Algorithms: Making Locally Optimal Decisions

## Introduction

Greedy algorithms work by making **locally optimal decisions** at each step without regard for future consequences. This is not an "all things considered" approach—greedy algorithms make decisions without thinking ahead about what comes after the current decision.

## Example 1: Task Scheduler

In this example, we'll demonstrate a greedy task scheduler that maximizes rewards by selecting tasks with the highest rewards that fit into available time slots.

### Task Class

```csharp
public class Task
{
    public string Name { get; set; }
    public int Deadline { get; set; }
    public int Reward { get; set; }

    public Task(string name, int deadline, int reward)
    {
        Name = name;
        Deadline = deadline;
        Reward = reward;
    }
}
```

### Greedy Task Scheduler Implementation

```csharp
public class GreedyTaskScheduler
{
    public List<Task> ScheduleTasks(List<Task> tasks)
    {
        // Sort tasks by reward in descending order (greedy choice)
        var sortedTasks = tasks.OrderByDescending(t => t.Reward).ToList();
        
        // Dictionary to store one task per time slot
        Dictionary<int, Task> timeSlots = new Dictionary<int, Task>();
        
        // Iterate through sorted tasks
        foreach (var task in sortedTasks)
        {
            // If time slot is not yet filled, add the task
            if (!timeSlots.ContainsKey(task.Deadline))
            {
                timeSlots.Add(task.Deadline, task);
            }
        }
        
        return timeSlots.Values.ToList();
    }
}
```

### Main Program

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Define tasks: name, time slot, reward
        List<Task> tasks = new List<Task>
        {
            new Task("Task A", 2, 100),  // Time slot 2, reward 100
            new Task("Task B", 1, 50),   // Time slot 1, reward 50
            new Task("Task C", 2, 20),   // Time slot 2, reward 20
            new Task("Task D", 1, 70)    // Time slot 1, reward 70
        };
        
        // Instantiate scheduler
        GreedyTaskScheduler scheduler = new GreedyTaskScheduler();
        
        // Get scheduled tasks
        List<Task> scheduledTasks = scheduler.ScheduleTasks(tasks);
        
        // Display results
        Console.WriteLine("Scheduled Tasks:");
        foreach (var task in scheduledTasks.OrderBy(t => t.Deadline))
        {
            Console.WriteLine($"{task.Name} - Deadline: {task.Deadline}, Reward: {task.Reward}");
        }
    }
}
```

### How It Works

1. **Sort by reward**: Tasks are sorted from highest reward (100) to lowest (20): Task A → Task D → Task B → Task C
2. **Fill time slots greedily**: 
   - Task A (reward 100, slot 2) is added first
   - Task D (reward 70, slot 1) is added next
   - Task B and Task C are skipped because their time slots are already filled

**Output:**
```
Scheduled Tasks:
Task D - Deadline: 1, Reward: 70
Task A - Deadline: 2, Reward: 100
```

The greedy algorithm prioritizes reward without considering other factors, making it fast and efficient for this specific optimization goal.

## Example 2: Dijkstra's Algorithm for Shortest Path

Dijkstra's algorithm is a classic greedy algorithm used to find the shortest path between nodes in a graph. It's commonly used in mapping and network applications.

### Graph Implementation

```csharp
public class Graph
{
    private Dictionary<string, List<Edge>> adjacencyList;

    public Graph()
    {
        adjacencyList = new Dictionary<string, List<Edge>>();
    }

    public void AddVertex(string vertex)
    {
        if (!adjacencyList.ContainsKey(vertex))
        {
            adjacencyList[vertex] = new List<Edge>();
        }
    }

    public void AddEdge(string from, string to, int weight)
    {
        AddVertex(from);
        AddVertex(to);
        adjacencyList[from].Add(new Edge(to, weight));
    }

    public List<string> Dijkstra(string start, string end)
    {
        var distances = new Dictionary<string, int>();
        var previous = new Dictionary<string, string>();
        var unvisited = new HashSet<string>();

        // Initialize distances
        foreach (var vertex in adjacencyList.Keys)
        {
            distances[vertex] = int.MaxValue;
            unvisited.Add(vertex);
        }
        distances[start] = 0;

        while (unvisited.Count > 0)
        {
            // Greedy choice: select vertex with minimum distance
            string current = unvisited.OrderBy(v => distances[v]).First();
            unvisited.Remove(current);

            if (current == end) break;

            // Update distances to neighbors
            foreach (var edge in adjacencyList[current])
            {
                int newDist = distances[current] + edge.Weight;
                if (newDist < distances[edge.To])
                {
                    distances[edge.To] = newDist;
                    previous[edge.To] = current;
                }
            }
        }

        // Build path
        return BuildPath(previous, start, end);
    }

    private List<string> BuildPath(Dictionary<string, string> previous, string start, string end)
    {
        var path = new List<string>();
        var current = end;

        while (current != start)
        {
            path.Add(current);
            if (!previous.ContainsKey(current)) return new List<string>();
            current = previous[current];
        }
        path.Add(start);
        path.Reverse();
        return path;
    }
}

public class Edge
{
    public string To { get; set; }
    public int Weight { get; set; }

    public Edge(string to, int weight)
    {
        To = to;
        Weight = weight;
    }
}
```

### Using Dijkstra's Algorithm

```csharp
class Program
{
    static void Main(string[] args)
    {
        Graph graph = new Graph();

        // Add edges with weights
        graph.AddEdge("A", "B", 1);
        graph.AddEdge("A", "C", 4);
        graph.AddEdge("B", "C", 2);
        graph.AddEdge("B", "D", 5);
        graph.AddEdge("C", "D", 1);

        // Find shortest path from A to D
        List<string> path = graph.Dijkstra("A", "D");

        Console.WriteLine($"Shortest path from A to D:");
        Console.WriteLine(string.Join(" -> ", path));
    }
}
```

**Output:**
```
Shortest path from A to D:
A -> B -> C -> D
```

### How Dijkstra's Algorithm Works

The algorithm finds the path A → B (weight 1) → C (weight 2) → D (weight 1), with a total distance of 4. This is the shortest path through the network.

The greedy choice is made at each step by selecting the unvisited vertex with the smallest known distance. It doesn't consider traffic, latency, or other factors—just the shortest geometric path.

## When to Use Greedy Algorithms

### Advantages
- **Fast and efficient** for specific optimization problems
- **Simple to implement** and understand
- **Works well** when local optimal choices lead to global optimal solutions

### Best Use Cases
- Task scheduling with single criteria (like maximum reward)
- Finding shortest paths in networks
- Huffman coding for data compression
- Minimum spanning tree problems

### Limitations

Greedy algorithms **are not suitable** when:
- You need to consider multiple factors (traffic, latency, etc.)
- Local optimal choices don't guarantee global optimal solutions
- Future consequences of decisions matter

In such scenarios, **dynamic programming** or other approaches would be more appropriate, as they consider the broader context and future implications of decisions.

Key Differences: Greedy vs Dynamic Programming

| Aspect              | Greedy                             | Dynamic Programming        |
|---------------------|------------------------------------|----------------------------|
|Decision Making      |Makes immediate best choice         |Explores all possibilities  |
|Future Consideration |Ignores future consequences         |Considers all future options|
|Optimality           |May miss global optimum             |Guarantees global optimum   |
|Use Case             |Single-criterion optimization       |Multi-option optimization   |
|LCS Applicability    |Fails to find optimal solution      | Finds optimal solution     |



## Conclusion

Greedy algorithms excel in scenarios where you want fast, efficient sorting or optimization based on a single criterion. However, when you need to balance multiple considerations or think ahead about future consequences, more sophisticated approaches like dynamic programming are necessary.