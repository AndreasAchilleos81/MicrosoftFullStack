# Hash Table Implementation in .NET Core

## Overview

Hash tables are data structures that enable fast data storage and retrieval operations. By using a hash function to compute an index into an array of buckets, hash tables can achieve O(1) average-case time complexity for lookups, insertions, and deletions.

## Step 1: Project Setup

Create a new console application for the hash table demonstration:

```bash
dotnet new console -n HashTableDemo
cd HashTableDemo
```

## Step 2: Basic Hash Table Implementation

### HashTable.cs

```csharp
using System;
using System.Collections.Generic;

public class HashTable<TKey, TValue>
{
    private const int SIZE = 10;
    private readonly LinkedList<KeyValuePair<TKey, TValue>>[] buckets;

    public HashTable()
    {
        buckets = new LinkedList<KeyValuePair<TKey, TValue>>[SIZE];
        
        for (int i = 0; i < SIZE; i++)
        {
            buckets[i] = new LinkedList<KeyValuePair<TKey, TValue>>();
        }
    }

    private int GetBucketIndex(TKey key)
    {
        return Math.Abs(key.GetHashCode() % SIZE);
    }

    public void Add(TKey key, TValue value)
    {
        int index = GetBucketIndex(key);
        var bucket = buckets[index];

        foreach (var pair in bucket)
        {
            if (pair.Key.Equals(key))
            {
                throw new ArgumentException($"Key '{key}' already exists in the hash table.");
            }
        }

        bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
    }

    public TValue Get(TKey key)
    {
        int index = GetBucketIndex(key);
        var bucket = buckets[index];

        foreach (var pair in bucket)
        {
            if (pair.Key.Equals(key))
            {
                return pair.Value;
            }
        }

        throw new KeyNotFoundException($"Key '{key}' not found in the hash table.");
    }
}
```

## Step 3: Using the Hash Table

### Program.cs

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        var hashTable = new HashTable<string, int>();

        // Add records
        hashTable.Add("Alice", 25);
        hashTable.Add("Bob", 30);
        hashTable.Add("Charlie", 35);

        // Retrieve and display ages
        Console.WriteLine($"Alice's age: {hashTable.Get("Alice")}");
        Console.WriteLine($"Bob's age: {hashTable.Get("Bob")}");
        Console.WriteLine($"Charlie's age: {hashTable.Get("Charlie")}");
    }
}
```

## Step 4: Testing

Run the application:

```bash
dotnet run
```

**Expected Output:**
```
Alice's age: 25
Bob's age: 30
Charlie's age: 35
```

---

## Advanced Implementation Examples

### Example 1: Enhanced Hash Table with Update and Remove Operations

```csharp
public class AdvancedHashTable<TKey, TValue>
{
    private const int INITIAL_SIZE = 16;
    private const double LOAD_FACTOR_THRESHOLD = 0.75;
    
    private LinkedList<KeyValuePair<TKey, TValue>>[] buckets;
    private int count;
    private int capacity;

    public int Count => count;
    public int Capacity => capacity;

    public AdvancedHashTable(int initialCapacity = INITIAL_SIZE)
    {
        capacity = initialCapacity;
        buckets = new LinkedList<KeyValuePair<TKey, TValue>>[capacity];
        
        for (int i = 0; i < capacity; i++)
        {
            buckets[i] = new LinkedList<KeyValuePair<TKey, TValue>>();
        }
    }

    private int GetBucketIndex(TKey key, int size)
    {
        return Math.Abs(key.GetHashCode() % size);
    }

    public void Add(TKey key, TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        if ((double)count / capacity > LOAD_FACTOR_THRESHOLD)
        {
            Resize();
        }

        int index = GetBucketIndex(key, capacity);
        var bucket = buckets[index];

        foreach (var pair in bucket)
        {
            if (pair.Key.Equals(key))
            {
                throw new ArgumentException($"Key '{key}' already exists.");
            }
        }

        bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
        count++;
    }

    public bool TryGetValue(TKey key, out TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetBucketIndex(key, capacity);
        var bucket = buckets[index];

        foreach (var pair in bucket)
        {
            if (pair.Key.Equals(key))
            {
                value = pair.Value;
                return true;
            }
        }

        value = default(TValue);
        return false;
    }

    public bool Update(TKey key, TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetBucketIndex(key, capacity);
        var bucket = buckets[index];
        var node = bucket.First;

        while (node != null)
        {
            if (node.Value.Key.Equals(key))
            {
                bucket.Remove(node);
                bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
                return true;
            }
            node = node.Next;
        }

        return false;
    }

    public bool Remove(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetBucketIndex(key, capacity);
        var bucket = buckets[index];
        var node = bucket.First;

        while (node != null)
        {
            if (node.Value.Key.Equals(key))
            {
                bucket.Remove(node);
                count--;
                return true;
            }
            node = node.Next;
        }

        return false;
    }

    private void Resize()
    {
        int newCapacity = capacity * 2;
        var newBuckets = new LinkedList<KeyValuePair<TKey, TValue>>[newCapacity];

        for (int i = 0; i < newCapacity; i++)
        {
            newBuckets[i] = new LinkedList<KeyValuePair<TKey, TValue>>();
        }

        // Rehash all existing entries
        foreach (var bucket in buckets)
        {
            foreach (var pair in bucket)
            {
                int newIndex = GetBucketIndex(pair.Key, newCapacity);
                newBuckets[newIndex].AddLast(pair);
            }
        }

        buckets = newBuckets;
        capacity = newCapacity;
    }

    public IEnumerable<TKey> Keys
    {
        get
        {
            foreach (var bucket in buckets)
            {
                foreach (var pair in bucket)
                {
                    yield return pair.Key;
                }
            }
        }
    }

    public IEnumerable<TValue> Values
    {
        get
        {
            foreach (var bucket in buckets)
            {
                foreach (var pair in bucket)
                {
                    yield return pair.Value;
                }
            }
        }
    }
}
```

### Example 2: Thread-Safe Hash Table

```csharp
using System.Threading;

public class ConcurrentHashTable<TKey, TValue>
{
    private const int INITIAL_SIZE = 16;
    private LinkedList<KeyValuePair<TKey, TValue>>[] buckets;
    private readonly ReaderWriterLockSlim[] locks;
    private int count;
    private int capacity;

    public ConcurrentHashTable(int initialCapacity = INITIAL_SIZE)
    {
        capacity = initialCapacity;
        buckets = new LinkedList<KeyValuePair<TKey, TValue>>[capacity];
        locks = new ReaderWriterLockSlim[capacity];

        for (int i = 0; i < capacity; i++)
        {
            buckets[i] = new LinkedList<KeyValuePair<TKey, TValue>>();
            locks[i] = new ReaderWriterLockSlim();
        }
    }

    private int GetBucketIndex(TKey key)
    {
        return Math.Abs(key.GetHashCode() % capacity);
    }

    public void Add(TKey key, TValue value)
    {
        int index = GetBucketIndex(key);
        locks[index].EnterWriteLock();

        try
        {
            var bucket = buckets[index];

            foreach (var pair in bucket)
            {
                if (pair.Key.Equals(key))
                {
                    throw new ArgumentException($"Key '{key}' already exists.");
                }
            }

            bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
            Interlocked.Increment(ref count);
        }
        finally
        {
            locks[index].ExitWriteLock();
        }
    }

    public bool TryGetValue(TKey key, out TValue value)
    {
        int index = GetBucketIndex(key);
        locks[index].EnterReadLock();

        try
        {
            var bucket = buckets[index];

            foreach (var pair in bucket)
            {
                if (pair.Key.Equals(key))
                {
                    value = pair.Value;
                    return true;
                }
            }

            value = default(TValue);
            return false;
        }
        finally
        {
            locks[index].ExitReadLock();
        }
    }

    public bool Remove(TKey key)
    {
        int index = GetBucketIndex(key);
        locks[index].EnterWriteLock();

        try
        {
            var bucket = buckets[index];
            var node = bucket.First;

            while (node != null)
            {
                if (node.Value.Key.Equals(key))
                {
                    bucket.Remove(node);
                    Interlocked.Decrement(ref count);
                    return true;
                }
                node = node.Next;
            }

            return false;
        }
        finally
        {
            locks[index].ExitWriteLock();
        }
    }
}
```

### Example 3: Custom Hash Function Implementation

```csharp
public class CustomHashTable<TKey, TValue>
{
    private const int INITIAL_SIZE = 16;
    private LinkedList<KeyValuePair<TKey, TValue>>[] buckets;
    private readonly IEqualityComparer<TKey> comparer;
    private int count;

    public CustomHashTable(IEqualityComparer<TKey> customComparer = null)
    {
        comparer = customComparer ?? EqualityComparer<TKey>.Default;
        buckets = new LinkedList<KeyValuePair<TKey, TValue>>[INITIAL_SIZE];

        for (int i = 0; i < INITIAL_SIZE; i++)
        {
            buckets[i] = new LinkedList<KeyValuePair<TKey, TValue>>();
        }
    }

    private int GetBucketIndex(TKey key)
    {
        int hashCode = comparer.GetHashCode(key);
        return Math.Abs(hashCode % buckets.Length);
    }

    public void Add(TKey key, TValue value)
    {
        int index = GetBucketIndex(key);
        var bucket = buckets[index];

        foreach (var pair in bucket)
        {
            if (comparer.Equals(pair.Key, key))
            {
                throw new ArgumentException($"Key already exists.");
            }
        }

        bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
        count++;
    }

    public TValue this[TKey key]
    {
        get
        {
            int index = GetBucketIndex(key);
            var bucket = buckets[index];

            foreach (var pair in bucket)
            {
                if (comparer.Equals(pair.Key, key))
                {
                    return pair.Value;
                }
            }

            throw new KeyNotFoundException($"Key not found.");
        }
        set
        {
            int index = GetBucketIndex(key);
            var bucket = buckets[index];
            var node = bucket.First;

            while (node != null)
            {
                if (comparer.Equals(node.Value.Key, key))
                {
                    bucket.Remove(node);
                    bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
                    return;
                }
                node = node.Next;
            }

            // Key doesn't exist, add it
            bucket.AddLast(new KeyValuePair<TKey, TValue>(key, value));
            count++;
        }
    }
}

// Example custom comparer for case-insensitive string keys
public class CaseInsensitiveComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y)
    {
        return string.Equals(x, y, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode(string obj)
    {
        return obj.ToLowerInvariant().GetHashCode();
    }
}
```

### Example 4: Performance Testing and Benchmarking

```csharp
using System.Diagnostics;

class HashTableBenchmark
{
    static void Main(string[] args)
    {
        const int ITERATIONS = 100000;

        // Test Advanced Hash Table
        var advancedTable = new AdvancedHashTable<string, int>();
        var stopwatch = Stopwatch.StartNew();

        for (int i = 0; i < ITERATIONS; i++)
        {
            advancedTable.Add($"Key{i}", i);
        }

        stopwatch.Stop();
        Console.WriteLine($"Advanced Hash Table - Add {ITERATIONS} items: {stopwatch.ElapsedMilliseconds}ms");

        stopwatch.Restart();
        for (int i = 0; i < ITERATIONS; i++)
        {
            advancedTable.TryGetValue($"Key{i}", out _);
        }

        stopwatch.Stop();
        Console.WriteLine($"Advanced Hash Table - Get {ITERATIONS} items: {stopwatch.ElapsedMilliseconds}ms");

        // Compare with .NET Dictionary
        var dictionary = new Dictionary<string, int>();
        stopwatch.Restart();

        for (int i = 0; i < ITERATIONS; i++)
        {
            dictionary.Add($"Key{i}", i);
        }

        stopwatch.Stop();
        Console.WriteLine($"Dictionary - Add {ITERATIONS} items: {stopwatch.ElapsedMilliseconds}ms");

        stopwatch.Restart();
        for (int i = 0; i < ITERATIONS; i++)
        {
            dictionary.TryGetValue($"Key{i}", out _);
        }

        stopwatch.Stop();
        Console.WriteLine($"Dictionary - Get {ITERATIONS} items: {stopwatch.ElapsedMilliseconds}ms");

        // Display collision statistics
        Console.WriteLine($"\nHash Table Statistics:");
        Console.WriteLine($"Count: {advancedTable.Count}");
        Console.WriteLine($"Capacity: {advancedTable.Capacity}");
        Console.WriteLine($"Load Factor: {(double)advancedTable.Count / advancedTable.Capacity:P2}");
    }
}
```

## Key Concepts

### Collision Handling
The implementation uses **separate chaining** with linked lists to handle collisions. When multiple keys hash to the same index, they are stored in a linked list at that bucket.

### Time Complexity
- **Average Case**: O(1) for add, get, and remove operations
- **Worst Case**: O(n) when all keys collide into a single bucket
- **Load Factor**: Maintaining a load factor below 0.75 ensures good performance

### Dynamic Resizing
When the load factor exceeds the threshold, the hash table automatically doubles its capacity and rehashes all existing entries to maintain optimal performance.

## Best Practices

1. Choose an appropriate initial capacity based on expected data size
2. Implement proper null checking for keys
3. Use thread-safe implementations for concurrent access scenarios
4. Consider custom hash functions for domain-specific requirements
5. Monitor load factor and collision rates for performance optimization