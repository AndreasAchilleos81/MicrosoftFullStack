# Implementing Greedy Algorithms in .NET Back-End Systems

## Overview

Greedy algorithms attempt to accomplish a goal without looking ahead. They don't take an all-things-considered approachâ€”they simply work with the data they have to accomplish their goal as quickly as possible. While they may not always provide the most optimal solution, they excel in speed and efficiency.

## The Resource Allocation Problem

In this tutorial, we'll build a .NET console application that distributes a limited set of resources among multiple servers using a greedy algorithm approach.

## Basic Implementation (Beginner Level)

This implementation demonstrates the fundamental greedy algorithm for resource allocation:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    static void Main(string[] args)
    {
        // Define available resources
        List<int> resources = new List<int> { 25, 20, 15, 10, 5 };
        
        // Define server capacities
        List<int> servers = new List<int> { 30, 20, 50 };
        
        // Run the greedy allocation algorithm
        var allocations = GreedyAllocate(resources, servers);
        
        // Display results
        DisplayAllocations(allocations, servers);
    }
    
    static Dictionary<int, List<int>> GreedyAllocate(
        List<int> resources, 
        List<int> servers)
    {
        // Sort resources in descending order for greedy approach
        resources.Sort((a, b) => b.CompareTo(a));
        
        // Store original server capacities
        List<int> originalCapacity = new List<int>(servers);
        
        // Initialize allocation dictionary
        Dictionary<int, List<int>> allocation = new Dictionary<int, List<int>>();
        
        for (int i = 0; i < servers.Count; i++)
        {
            allocation[i] = new List<int>();
        }
        
        // Greedy allocation: try to fit each resource into servers
        foreach (int resource in resources)
        {
            for (int i = 0; i < servers.Count; i++)
            {
                if (servers[i] >= resource)
                {
                    allocation[i].Add(resource);
                    servers[i] -= resource;
                    break; // Move to next resource
                }
            }
        }
        
        return allocation;
    }
    
    static void DisplayAllocations(
        Dictionary<int, List<int>> allocations, 
        List<int> originalCapacities)
    {
        for (int i = 0; i < allocations.Count; i++)
        {
            Console.WriteLine($"Server {i + 1}:");
            Console.WriteLine($"  Initial Capacity: {originalCapacities[i]}");
            Console.WriteLine($"  Allocated Resources: {string.Join(", ", allocations[i])}");
            Console.WriteLine($"  Total Allocated: {allocations[i].Sum()}");
            Console.WriteLine($"  Remaining Capacity: {originalCapacities[i] - allocations[i].Sum()}");
            Console.WriteLine();
        }
    }
}
```

**Output:**
```
Server 1:
  Initial Capacity: 30
  Allocated Resources: 25, 5
  Total Allocated: 30
  Remaining Capacity: 0

Server 2:
  Initial Capacity: 20
  Allocated Resources: 20
  Total Allocated: 20
  Remaining Capacity: 0

Server 3:
  Initial Capacity: 50
  Allocated Resources: 15, 10
  Total Allocated: 25
  Remaining Capacity: 25
```

## Improved Implementation with Priority Queue (Intermediate Level)

This version uses a `SortedSet` to improve efficiency by maintaining servers in sorted order by remaining capacity:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    // Server class to track capacity and allocations
    class Server : IComparable<Server>
    {
        public int Id { get; set; }
        public int OriginalCapacity { get; set; }
        public int RemainingCapacity { get; set; }
        public List<int> AllocatedResources { get; set; }
        
        public Server(int id, int capacity)
        {
            Id = id;
            OriginalCapacity = capacity;
            RemainingCapacity = capacity;
            AllocatedResources = new List<int>();
        }
        
        // For SortedSet ordering
        public int CompareTo(Server other)
        {
            int result = other.RemainingCapacity.CompareTo(RemainingCapacity);
            return result != 0 ? result : Id.CompareTo(other.Id);
        }
    }
    
    static void Main(string[] args)
    {
        List<int> resources = new List<int> { 25, 20, 15, 10, 5 };
        List<int> serverCapacities = new List<int> { 30, 20, 50 };
        
        var allocations = OptimizedGreedyAllocate(resources, serverCapacities);
        
        DisplayOptimizedAllocations(allocations);
    }
    
    static List<Server> OptimizedGreedyAllocate(
        List<int> resources, 
        List<int> capacities)
    {
        // Sort resources in descending order
        resources.Sort((a, b) => b.CompareTo(a));
        
        // Create servers and add to sorted set (heap-like structure)
        SortedSet<Server> serverHeap = new SortedSet<Server>();
        List<Server> servers = new List<Server>();
        
        for (int i = 0; i < capacities.Count; i++)
        {
            Server server = new Server(i, capacities[i]);
            servers.Add(server);
            serverHeap.Add(server);
        }
        
        // Allocate resources using the sorted set
        foreach (int resource in resources)
        {
            // Get server with most remaining capacity
            Server bestServer = serverHeap.FirstOrDefault(s => s.RemainingCapacity >= resource);
            
            if (bestServer != null)
            {
                // Remove from set, update, and re-add (to maintain sort order)
                serverHeap.Remove(bestServer);
                bestServer.AllocatedResources.Add(resource);
                bestServer.RemainingCapacity -= resource;
                serverHeap.Add(bestServer);
            }
        }
        
        return servers;
    }
    
    static void DisplayOptimizedAllocations(List<Server> servers)
    {
        foreach (var server in servers)
        {
            Console.WriteLine($"Server {server.Id + 1}:");
            Console.WriteLine($"  Initial Capacity: {server.OriginalCapacity}");
            Console.WriteLine($"  Allocated Resources: {string.Join(", ", server.AllocatedResources)}");
            Console.WriteLine($"  Total Allocated: {server.AllocatedResources.Sum()}");
            Console.WriteLine($"  Remaining Capacity: {server.RemainingCapacity}");
            Console.WriteLine();
        }
    }
}
```

## Advanced Implementation with Metrics and Benchmarking

This version includes performance tracking, multiple allocation strategies, and comprehensive metrics:

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

class Program
{
    enum AllocationStrategy
    {
        FirstFit,      // First server that fits
        BestFit,       // Server with least remaining space after allocation
        WorstFit       // Server with most remaining space after allocation
    }
    
    class AllocationResult
    {
        public List<Server> Servers { get; set; }
        public long ExecutionTimeMs { get; set; }
        public double UtilizationRate { get; set; }
        public int WastedCapacity { get; set; }
        public int UnallocatedResources { get; set; }
    }
    
    class Server : IComparable<Server>
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public int OriginalCapacity { get; set; }
        public int RemainingCapacity { get; set; }
        public List<int> AllocatedResources { get; set; }
        public DateTime LastAllocationTime { get; set; }
        
        public Server(int id, string name, int capacity)
        {
            Id = id;
            Name = name;
            OriginalCapacity = capacity;
            RemainingCapacity = capacity;
            AllocatedResources = new List<int>();
        }
        
        public double UtilizationPercentage => 
            ((double)(OriginalCapacity - RemainingCapacity) / OriginalCapacity) * 100;
        
        public int CompareTo(Server other)
        {
            int result = other.RemainingCapacity.CompareTo(RemainingCapacity);
            return result != 0 ? result : Id.CompareTo(other.Id);
        }
        
        public Server Clone()
        {
            return new Server(Id, Name, OriginalCapacity)
            {
                RemainingCapacity = this.RemainingCapacity,
                AllocatedResources = new List<int>(this.AllocatedResources)
            };
        }
    }
    
    static void Main(string[] args)
    {
        // Test data
        List<int> resources = new List<int> { 25, 20, 15, 10, 5, 8, 12, 18, 22, 7 };
        List<(string name, int capacity)> serverConfigs = new List<(string, int)>
        {
            ("Web-Server-01", 50),
            ("App-Server-01", 40),
            ("DB-Server-01", 60),
            ("Cache-Server-01", 30)
        };
        
        Console.WriteLine("=== Greedy Resource Allocation Benchmark ===\n");
        Console.WriteLine($"Resources to allocate: {string.Join(", ", resources)}");
        Console.WriteLine($"Total resources: {resources.Sum()}\n");
        
        // Test all strategies
        foreach (AllocationStrategy strategy in Enum.GetValues(typeof(AllocationStrategy)))
        {
            var result = AllocateWithStrategy(resources, serverConfigs, strategy);
            DisplayDetailedResults(strategy, result);
        }
        
        // Compare strategies
        Console.WriteLine("\n=== Strategy Comparison ===");
        CompareStrategies(resources, serverConfigs);
    }
    
    static AllocationResult AllocateWithStrategy(
        List<int> resources,
        List<(string name, int capacity)> configs,
        AllocationStrategy strategy)
    {
        Stopwatch sw = Stopwatch.StartNew();
        
        // Sort resources in descending order
        List<int> sortedResources = resources.OrderByDescending(r => r).ToList();
        
        // Initialize servers
        List<Server> servers = new List<Server>();
        for (int i = 0; i < configs.Count; i++)
        {
            servers.Add(new Server(i, configs[i].name, configs[i].capacity));
        }
        
        int unallocatedCount = 0;
        
        // Allocate based on strategy
        foreach (int resource in sortedResources)
        {
            Server targetServer = null;
            
            switch (strategy)
            {
                case AllocationStrategy.FirstFit:
                    targetServer = servers.FirstOrDefault(s => s.RemainingCapacity >= resource);
                    break;
                    
                case AllocationStrategy.BestFit:
                    targetServer = servers
                        .Where(s => s.RemainingCapacity >= resource)
                        .OrderBy(s => s.RemainingCapacity - resource)
                        .FirstOrDefault();
                    break;
                    
                case AllocationStrategy.WorstFit:
                    targetServer = servers
                        .Where(s => s.RemainingCapacity >= resource)
                        .OrderByDescending(s => s.RemainingCapacity)
                        .FirstOrDefault();
                    break;
            }
            
            if (targetServer != null)
            {
                targetServer.AllocatedResources.Add(resource);
                targetServer.RemainingCapacity -= resource;
                targetServer.LastAllocationTime = DateTime.Now;
            }
            else
            {
                unallocatedCount++;
            }
        }
        
        sw.Stop();
        
        // Calculate metrics
        int totalCapacity = servers.Sum(s => s.OriginalCapacity);
        int usedCapacity = servers.Sum(s => s.OriginalCapacity - s.RemainingCapacity);
        int wastedCapacity = servers.Sum(s => s.RemainingCapacity);
        
        return new AllocationResult
        {
            Servers = servers,
            ExecutionTimeMs = sw.ElapsedMilliseconds,
            UtilizationRate = (double)usedCapacity / totalCapacity * 100,
            WastedCapacity = wastedCapacity,
            UnallocatedResources = unallocatedCount
        };
    }
    
    static void DisplayDetailedResults(AllocationStrategy strategy, AllocationResult result)
    {
        Console.WriteLine($"\n--- {strategy} Strategy ---");
        Console.WriteLine($"Execution Time: {result.ExecutionTimeMs}ms");
        Console.WriteLine($"Overall Utilization: {result.UtilizationRate:F2}%");
        Console.WriteLine($"Wasted Capacity: {result.WastedCapacity}");
        Console.WriteLine($"Unallocated Resources: {result.UnallocatedResources}\n");
        
        foreach (var server in result.Servers)
        {
            Console.WriteLine($"  {server.Name} (ID: {server.Id})");
            Console.WriteLine($"    Capacity: {server.OriginalCapacity}");
            Console.WriteLine($"    Allocated: [{string.Join(", ", server.AllocatedResources)}]");
            Console.WriteLine($"    Total Used: {server.OriginalCapacity - server.RemainingCapacity}");
            Console.WriteLine($"    Remaining: {server.RemainingCapacity}");
            Console.WriteLine($"    Utilization: {server.UtilizationPercentage:F2}%");
            Console.WriteLine();
        }
    }
    
    static void CompareStrategies(
        List<int> resources, 
        List<(string name, int capacity)> configs)
    {
        var results = new Dictionary<AllocationStrategy, AllocationResult>();
        
        foreach (AllocationStrategy strategy in Enum.GetValues(typeof(AllocationStrategy)))
        {
            results[strategy] = AllocateWithStrategy(resources, configs, strategy);
        }
        
        Console.WriteLine($"{"Strategy",-15} {"Time (ms)",-12} {"Utilization",-15} {"Wasted",-10} {"Unallocated",-15}");
        Console.WriteLine(new string('-', 70));
        
        foreach (var kvp in results.OrderByDescending(r => r.Value.UtilizationRate))
        {
            Console.WriteLine($"{kvp.Key,-15} {kvp.Value.ExecutionTimeMs,-12} " +
                            $"{kvp.Value.UtilizationRate + "%",-15:F2} " +
                            $"{kvp.Value.WastedCapacity,-10} " +
                            $"{kvp.Value.UnallocatedResources,-15}");
        }
    }
}
```

## Advanced: Thread-Safe Concurrent Allocation

For high-performance scenarios with concurrent resource requests:

```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

class ConcurrentResourceAllocator
{
    class ThreadSafeServer
    {
        private readonly object _lock = new object();
        public int Id { get; }
        public string Name { get; }
        public int OriginalCapacity { get; }
        private int _remainingCapacity;
        private readonly ConcurrentBag<int> _allocatedResources;
        
        public int RemainingCapacity
        {
            get { lock (_lock) { return _remainingCapacity; } }
        }
        
        public List<int> AllocatedResources => _allocatedResources.ToList();
        
        public ThreadSafeServer(int id, string name, int capacity)
        {
            Id = id;
            Name = name;
            OriginalCapacity = capacity;
            _remainingCapacity = capacity;
            _allocatedResources = new ConcurrentBag<int>();
        }
        
        public bool TryAllocate(int resource)
        {
            lock (_lock)
            {
                if (_remainingCapacity >= resource)
                {
                    _remainingCapacity -= resource;
                    _allocatedResources.Add(resource);
                    return true;
                }
                return false;
            }
        }
    }
    
    static async Task Main(string[] args)
    {
        // Initialize servers
        var servers = new List<ThreadSafeServer>
        {
            new ThreadSafeServer(0, "Server-A", 100),
            new ThreadSafeServer(1, "Server-B", 150),
            new ThreadSafeServer(2, "Server-C", 200)
        };
        
        // Simulate concurrent resource requests
        var resources = Enumerable.Range(1, 50).Select(i => Random.Shared.Next(5, 25)).ToList();
        
        Console.WriteLine($"Allocating {resources.Count} resources concurrently...\n");
        
        var allocationTasks = resources.Select(resource => 
            Task.Run(() => AllocateResource(resource, servers))
        ).ToArray();
        
        await Task.WhenAll(allocationTasks);
        
        // Display results
        Console.WriteLine("\n=== Concurrent Allocation Results ===\n");
        foreach (var server in servers)
        {
            int totalAllocated = server.AllocatedResources.Sum();
            Console.WriteLine($"{server.Name}:");
            Console.WriteLine($"  Capacity: {server.OriginalCapacity}");
            Console.WriteLine($"  Allocated: {totalAllocated}");
            Console.WriteLine($"  Remaining: {server.RemainingCapacity}");
            Console.WriteLine($"  Utilization: {(double)totalAllocated / server.OriginalCapacity * 100:F2}%");
            Console.WriteLine($"  Resource Count: {server.AllocatedResources.Count}\n");
        }
    }
    
    static bool AllocateResource(int resource, List<ThreadSafeServer> servers)
    {
        // Try to allocate to first available server (First Fit strategy)
        foreach (var server in servers)
        {
            if (server.TryAllocate(resource))
            {
                return true;
            }
        }
        
        Console.WriteLine($"Warning: Could not allocate resource of size {resource}");
        return false;
    }
}
```

## Key Takeaways

1. **Basic greedy algorithms** are fast but may not always produce optimal solutions
2. **Data structures matter**: Using `SortedSet` instead of repeated list iteration improves efficiency
3. **Different strategies** (First Fit, Best Fit, Worst Fit) can produce different results
4. **Benchmarking** helps compare implementations and choose the right approach
5. **Thread safety** is crucial for concurrent scenarios
6. **Always validate** LLM-generated code with testing and performance measurements

The greedy approach trades optimality for speed, making it ideal for real-time systems where quick decisions are more valuable than perfect solutions.