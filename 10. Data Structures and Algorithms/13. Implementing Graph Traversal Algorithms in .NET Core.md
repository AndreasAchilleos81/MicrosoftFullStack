# Implementing Graph Traversal Algorithms in .NET Core

## Overview

This lab demonstrates how to implement Depth-First Search (DFS) and Breadth-First Search (BFS) in a .NET Core application. These are two fundamental ways to traverse data structures like graphs and trees.

## Step 1: Define the Graph Structure

The graph is represented using an adjacency list, which stores each node and its connected neighbors.

### Graph Class Implementation

```csharp
using System;
using System.Collections.Generic;

public class Graph
{
    private Dictionary<int, List<int>> adjacencyList;

    public Graph()
    {
        adjacencyList = new Dictionary<int, List<int>>();
    }

    // Add an edge between two nodes (undirected graph)
    public void AddEdge(int node1, int node2)
    {
        // Add node1 to adjacency list if it doesn't exist
        if (!adjacencyList.ContainsKey(node1))
        {
            adjacencyList[node1] = new List<int>();
        }

        // Add node2 to adjacency list if it doesn't exist
        if (!adjacencyList.ContainsKey(node2))
        {
            adjacencyList[node2] = new List<int>();
        }

        // Add edges in both directions (undirected graph)
        adjacencyList[node1].Add(node2);
        adjacencyList[node2].Add(node1);
    }

    // Get the adjacency list
    public Dictionary<int, List<int>> GetGraph()
    {
        return adjacencyList;
    }
}
```

## Step 2: Implement Depth-First Search (DFS)

### What is DFS?

Depth-First Search explores as far as possible along each branch before backtracking. It visits as far as it can along the branches first, then backtracks as needed.

### DFS Characteristics
- Uses recursion or a stack
- Explores deep into the graph before exploring siblings
- Good for: pathfinding, cycle detection, topological sorting

### DFS Implementation

```csharp
public class GraphTraversalDFS
{
    // Depth-First Search traversal
    public void DFS(Graph graph, int start, HashSet<int> visited)
    {
        // If this node has already been visited, return
        if (visited.Contains(start))
        {
            return;
        }

        // Mark the current node as visited and print it
        Console.Write(start + " ");
        visited.Add(start);

        // Get the adjacency list
        Dictionary<int, List<int>> adjacencyList = graph.GetGraph();

        // Visit all neighbors of the current node
        if (adjacencyList.ContainsKey(start))
        {
            foreach (int neighbor in adjacencyList[start])
            {
                // Recursively call DFS for each unvisited neighbor
                DFS(graph, neighbor, visited);
            }
        }
    }

    // Helper method to start DFS from a given node
    public void StartDFS(Graph graph, int startNode)
    {
        HashSet<int> visited = new HashSet<int>();
        Console.WriteLine("DFS Traversal:");
        DFS(graph, startNode, visited);
        Console.WriteLine();
    }
}
```

## Step 3: Implement Breadth-First Search (BFS)

### What is BFS?

Breadth-First Search explores all neighbors at the current level before moving deeper. It processes nodes level by level.

### BFS Characteristics
- Uses a queue data structure
- Explores all neighbors at current depth before going deeper
- Good for: shortest path finding, level-order traversal, finding nearest neighbors

### BFS Implementation

```csharp
public class GraphTraversalBFS
{
    // Breadth-First Search traversal
    public void BFS(Graph graph, int start)
    {
        // Create a queue for BFS
        Queue<int> queue = new Queue<int>();
        
        // Create a hash set to track visited nodes
        HashSet<int> visited = new HashSet<int>();

        // Start by visiting the starting node
        visited.Add(start);
        queue.Enqueue(start);

        Console.WriteLine("BFS Traversal:");

        // Process nodes while queue is not empty
        while (queue.Count > 0)
        {
            // Dequeue a node from the queue
            int node = queue.Dequeue();
            Console.Write(node + " ");

            // Get the adjacency list
            Dictionary<int, List<int>> adjacencyList = graph.GetGraph();

            // Visit all neighbors of the current node
            if (adjacencyList.ContainsKey(node))
            {
                foreach (int neighbor in adjacencyList[node])
                {
                    // If neighbor hasn't been visited, add it to queue
                    if (!visited.Contains(neighbor))
                    {
                        visited.Add(neighbor);
                        queue.Enqueue(neighbor);
                    }
                }
            }
        }
        Console.WriteLine();
    }
}
```

## Complete Example: Using DFS and BFS

### Program.cs

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        // Create a graph
        Graph graph = new Graph();

        // Add edges to create the following graph:
        //     1
        //    / \
        //   2   3
        //  / \   \
        // 4   5   6
        graph.AddEdge(1, 2);
        graph.AddEdge(1, 3);
        graph.AddEdge(2, 4);
        graph.AddEdge(2, 5);
        graph.AddEdge(3, 6);

        Console.WriteLine("Graph Structure:");
        Console.WriteLine("     1");
        Console.WriteLine("    / \\");
        Console.WriteLine("   2   3");
        Console.WriteLine("  / \\   \\");
        Console.WriteLine(" 4   5   6");
        Console.WriteLine();

        // Perform DFS traversal
        GraphTraversalDFS dfsTraversal = new GraphTraversalDFS();
        dfsTraversal.StartDFS(graph, 1);

        Console.WriteLine();

        // Perform BFS traversal
        GraphTraversalBFS bfsTraversal = new GraphTraversalBFS();
        bfsTraversal.BFS(graph, 1);
    }
}
```

### Expected Output

```
Graph Structure:
     1
    / \
   2   3
  / \   \
 4   5   6

DFS Traversal:
1 2 4 5 3 6 

BFS Traversal:
1 2 3 4 5 6 
```

## Comparison: DFS vs BFS

| Aspect                 | Depth-First Search (DFS)                        | Breadth-First Search (BFS)                   |
| ---------------------- | ----------------------------------------------- | -------------------------------------------- |
| **Data Structure**     | Stack (recursion or explicit)                   | Queue                                        |
| **Traversal Strategy** | Go deep first, then backtrack                   | Visit all neighbors level by level           |
| **Memory Usage**       | Less memory (only stores path)                  | More memory (stores all nodes at level)      |
| **Path Found**         | Not necessarily shortest                        | Always shortest path                         |
| **Implementation**     | Recursive (simpler)                             | Iterative with queue                         |
| **Best For**           | Maze solving, cycle detection, topological sort | Shortest path, level-order, nearest neighbor |

## Detailed Algorithm Walkthrough

### DFS Traversal Order
Starting from node 1:
1. Visit 1, mark as visited
2. Go to neighbor 2, mark as visited
3. Go to neighbor 4 (deepest first), mark as visited
4. Backtrack to 2, go to neighbor 5, mark as visited
5. Backtrack to 1, go to neighbor 3, mark as visited
6. Go to neighbor 6, mark as visited

**Result:** 1 → 2 → 4 → 5 → 3 → 6

### BFS Traversal Order
Starting from node 1:
1. Visit 1, add neighbors (2, 3) to queue
2. Visit 2, add unvisited neighbors (4, 5) to queue
3. Visit 3, add unvisited neighbor (6) to queue
4. Visit 4 (no new neighbors)
5. Visit 5 (no new neighbors)
6. Visit 6 (no new neighbors)

**Result:** 1 → 2 → 3 → 4 → 5 → 6

## When to Use Each Algorithm

### Use DFS when:
- Finding if a path exists between two nodes
- Detecting cycles in a graph
- Performing topological sorting
- Solving maze or puzzle problems
- Memory is limited
- You need to explore all possible paths

### Use BFS when:
- Finding the shortest path between nodes
- Finding all nodes within a certain distance
- Level-order traversal is needed
- Finding the nearest neighbor
- You need the minimum number of steps to reach a goal

## Time and Space Complexity

Both algorithms have similar complexity:

- **Time Complexity:** O(V + E) where V is vertices and E is edges
- **Space Complexity:**
  - DFS: O(V) for the recursion stack
  - BFS: O(V) for the queue

## Key Takeaways

- DFS explores deeply before exploring siblings (uses recursion/stack)
- BFS explores all neighbors at the current level first (uses queue)
- Both visit all reachable nodes exactly once
- Choice depends on your specific use case and requirements
- DFS is simpler to implement with recursion
- BFS guarantees shortest path in unweighted graphs

## Conclusion

Understanding DFS and BFS is fundamental to working with graphs and trees. Which algorithm you choose depends entirely on your use case—whether you need the shortest path, want to explore all possibilities, or have specific memory constraints.