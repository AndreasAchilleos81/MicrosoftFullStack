# Tree Data Structures: Binary Trees, BSTs, and AVL Trees

## Introduction

Information needs to be organized in a way that makes it instantly accessible and efficient to store and retrieve, regardless of the amount of data involved. Tree structures help us accomplish this by creating logical pathways through complex data. This guide describes the key properties of binary trees, binary search trees, and AVL trees.

## Tree Data Structure Fundamentals

### What is a Tree?

A **tree data structure** is a hierarchical data structure where each node has a parent-child relationship. In this structure, a parent node has connections leading to one or more child nodes, which are directly below it in the hierarchy.

Think of it like a family tree, where each person has clear connections to others. This structure helps store data in an organized way, as each level is connected to the next.

### Key Elements of a Tree

```csharp
public class TreeNode<T>
{
    public T Value { get; set; }
    public TreeNode<T> Parent { get; set; }
    public List<TreeNode<T>> Children { get; set; }
    
    public TreeNode(T value)
    {
        Value = value;
        Children = new List<TreeNode<T>>();
    }
}
```

### Tree Terminology

- **Root Node**: The starting point at the top of the tree
- **Parent Node**: A node that has connections to child nodes below it
- **Child Node**: A node directly connected to a parent node above it
- **Leaf Node**: A node with no children
- **Subtree**: A portion of the tree structure

```csharp
// Example: Creating a simple tree structure
TreeNode<string> root = new TreeNode<string>("CEO");
TreeNode<string> cto = new TreeNode<string>("CTO");
TreeNode<string> cfo = new TreeNode<string>("CFO");

root.Children.Add(cto);
root.Children.Add(cfo);
cto.Parent = root;
cfo.Parent = root;
```

## Binary Trees

### Definition

A **binary tree** is a type of data tree where each node has **at most two children**, known respectively as the **left child** and **right child**.

This structure simplifies data organization since each decision point has only two branches, which is ideal for tasks that involve sorting and searching.

### Analogy

You can think of binary trees as decision flowcharts, where each choice leads to only two possible outcomes. This simple two-child rule makes binary trees useful for organizing data that naturally splits into two directions, like survey questions that offer only two options: yes and no.

### Binary Tree Implementation

```csharp
public class BinaryTreeNode<T>
{
    public T Value { get; set; }
    public BinaryTreeNode<T> Left { get; set; }
    public BinaryTreeNode<T> Right { get; set; }
    
    public BinaryTreeNode(T value)
    {
        Value = value;
        Left = null;
        Right = null;
    }
}

// Example: Creating a binary tree
public class BinaryTree<T>
{
    public BinaryTreeNode<T> Root { get; set; }
    
    public BinaryTree(T rootValue)
    {
        Root = new BinaryTreeNode<T>(rootValue);
    }
    
    // In-order traversal (Left -> Root -> Right)
    public void InOrderTraversal(BinaryTreeNode<T> node)
    {
        if (node != null)
        {
            InOrderTraversal(node.Left);
            Console.WriteLine(node.Value);
            InOrderTraversal(node.Right);
        }
    }
    
    // Pre-order traversal (Root -> Left -> Right)
    public void PreOrderTraversal(BinaryTreeNode<T> node)
    {
        if (node != null)
        {
            Console.WriteLine(node.Value);
            PreOrderTraversal(node.Left);
            PreOrderTraversal(node.Right);
        }
    }
    
    // Post-order traversal (Left -> Right -> Root)
    public void PostOrderTraversal(BinaryTreeNode<T> node)
    {
        if (node != null)
        {
            PostOrderTraversal(node.Left);
            PostOrderTraversal(node.Right);
            Console.WriteLine(node.Value);
        }
    }
}
```

### Binary Tree Example Usage

```csharp
// Creating a binary tree
BinaryTree<string> tree = new BinaryTree<string>("Root");
tree.Root.Left = new BinaryTreeNode<string>("Left Child");
tree.Root.Right = new BinaryTreeNode<string>("Right Child");
tree.Root.Left.Left = new BinaryTreeNode<string>("Left-Left Grandchild");
tree.Root.Left.Right = new BinaryTreeNode<string>("Left-Right Grandchild");

// Traversing the tree
Console.WriteLine("In-Order Traversal:");
tree.InOrderTraversal(tree.Root);
```

## Binary Search Trees (BST)

### Definition

A **Binary Search Tree (BST)** is a binary tree that maintains a sorted order, with each left child smaller than its parent, and each right child larger than its parent. This structure makes it easy to search for specific items quickly because of its sorted layout.

### The Dictionary Analogy

Imagine flipping through a dictionary where words are organized alphabetically. If you're trying to find a word starting with M, you know where to start. BSTs follow a similar principle, making them very efficient for managing ordered data.

Words in a dictionary are sorted alphabetically. This order provides a natural way to narrow down where to search for a word. Similarly, nodes in a BST are organized such that:
- The **left subtree** contains values **smaller** than the node
- The **right subtree** contains values **larger** than the node

This property allows efficient navigation to find a target value.

### BST Properties

```
        50
       /  \
      30   70
     / \   / \
   20  40 60  80
   
For any node N:
- All values in left subtree < N
- All values in right subtree > N
```

### BST Implementation

```csharp
public class BinarySearchTree
{
    public class Node
    {
        public int Value { get; set; }
        public Node Left { get; set; }
        public Node Right { get; set; }
        
        public Node(int value)
        {
            Value = value;
            Left = null;
            Right = null;
        }
    }
    
    public Node Root { get; set; }
    
    // Insert a value into the BST
    public void Insert(int value)
    {
        Root = InsertRecursive(Root, value);
    }
    
    private Node InsertRecursive(Node node, int value)
    {
        // If tree is empty, create new node
        if (node == null)
        {
            return new Node(value);
        }
        
        // Otherwise, recur down the tree
        if (value < node.Value)
        {
            node.Left = InsertRecursive(node.Left, value);
        }
        else if (value > node.Value)
        {
            node.Right = InsertRecursive(node.Right, value);
        }
        
        return node;
    }
    
    // Search for a value in the BST
    public bool Search(int value)
    {
        return SearchRecursive(Root, value);
    }
    
    private bool SearchRecursive(Node node, int value)
    {
        // Base case: empty tree or value not found
        if (node == null)
        {
            return false;
        }
        
        // Value found
        if (node.Value == value)
        {
            return true;
        }
        
        // Value is smaller, search left subtree
        if (value < node.Value)
        {
            return SearchRecursive(node.Left, value);
        }
        
        // Value is larger, search right subtree
        return SearchRecursive(node.Right, value);
    }
    
    // Find minimum value in the tree
    public int FindMin()
    {
        if (Root == null)
            throw new InvalidOperationException("Tree is empty");
            
        Node current = Root;
        while (current.Left != null)
        {
            current = current.Left;
        }
        return current.Value;
    }
    
    // Find maximum value in the tree
    public int FindMax()
    {
        if (Root == null)
            throw new InvalidOperationException("Tree is empty");
            
        Node current = Root;
        while (current.Right != null)
        {
            current = current.Right;
        }
        return current.Value;
    }
    
    // Delete a value from the BST
    public void Delete(int value)
    {
        Root = DeleteRecursive(Root, value);
    }
    
    private Node DeleteRecursive(Node node, int value)
    {
        if (node == null)
            return null;
            
        if (value < node.Value)
        {
            node.Left = DeleteRecursive(node.Left, value);
        }
        else if (value > node.Value)
        {
            node.Right = DeleteRecursive(node.Right, value);
        }
        else
        {
            // Node with only one child or no child
            if (node.Left == null)
                return node.Right;
            else if (node.Right == null)
                return node.Left;
                
            // Node with two children: get smallest in right subtree
            node.Value = FindMinValue(node.Right);
            node.Right = DeleteRecursive(node.Right, node.Value);
        }
        
        return node;
    }
    
    private int FindMinValue(Node node)
    {
        int minValue = node.Value;
        while (node.Left != null)
        {
            minValue = node.Left.Value;
            node = node.Left;
        }
        return minValue;
    }
}
```

### BST Example Usage

```csharp
BinarySearchTree bst = new BinarySearchTree();

// Insert values
bst.Insert(50);
bst.Insert(30);
bst.Insert(70);
bst.Insert(20);
bst.Insert(40);
bst.Insert(60);
bst.Insert(80);

// Search for values
Console.WriteLine(bst.Search(40));  // True
Console.WriteLine(bst.Search(90));  // False

// Find min and max
Console.WriteLine($"Min: {bst.FindMin()}");  // 20
Console.WriteLine($"Max: {bst.FindMax()}");  // 80

// Delete a value
bst.Delete(30);
```

### BST Time Complexity

| Operation | Average Case | Worst Case |
| --------- | ------------ | ---------- |
| Search    | O(log n)     | O(n)       |
| Insert    | O(log n)     | O(n)       |
| Delete    | O(log n)     | O(n)       |

**Note**: Worst case occurs when tree becomes unbalanced (like a linked list)

## AVL Trees

### Definition

An **Adelson-Velsky and Landis (AVL) tree** is a **self-balancing binary search tree** in which the heights of the left and right subtrees differ by no more than one level. This ensures that the tree remains balanced, providing efficient performance for search, insertion, and deletion operations.

### Why Balancing Matters

When data is added or removed, AVL trees make small adjustments to remain balanced, keeping search times quick and efficient. Without this balancing mechanism, a tree could grow unevenly, making one side much deeper and slowing down searches. AVL trees prevent this by automatically rebalancing so that retrieval times stay fast and reliable.

### Balance Factor

The **balance factor** of a node is calculated as:
```
Balance Factor = Height(Left Subtree) - Height(Right Subtree)
```

For an AVL tree, the balance factor must be **-1, 0, or 1** for every node.

```
Balanced AVL Tree:
        30
       /  \
      20   40
     /      \
    10       50
    
Balance factors: all nodes have BF âˆˆ {-1, 0, 1}
```

### AVL Tree Implementation

```csharp
public class AVLTree
{
    public class Node
    {
        public int Value { get; set; }
        public Node Left { get; set; }
        public Node Right { get; set; }
        public int Height { get; set; }
        
        public Node(int value)
        {
            Value = value;
            Height = 1;
        }
    }
    
    public Node Root { get; set; }
    
    // Get height of node
    private int Height(Node node)
    {
        return node == null ? 0 : node.Height;
    }
    
    // Get balance factor of node
    private int GetBalance(Node node)
    {
        return node == null ? 0 : Height(node.Left) - Height(node.Right);
    }
    
    // Right rotate subtree rooted with y
    private Node RightRotate(Node y)
    {
        Node x = y.Left;
        Node T2 = x.Right;
        
        // Perform rotation
        x.Right = y;
        y.Left = T2;
        
        // Update heights
        y.Height = Math.Max(Height(y.Left), Height(y.Right)) + 1;
        x.Height = Math.Max(Height(x.Left), Height(x.Right)) + 1;
        
        return x;
    }
    
    // Left rotate subtree rooted with x
    private Node LeftRotate(Node x)
    {
        Node y = x.Right;
        Node T2 = y.Left;
        
        // Perform rotation
        y.Left = x;
        x.Right = T2;
        
        // Update heights
        x.Height = Math.Max(Height(x.Left), Height(x.Right)) + 1;
        y.Height = Math.Max(Height(y.Left), Height(y.Right)) + 1;
        
        return y;
    }
    
    // Insert a value into the AVL tree
    public void Insert(int value)
    {
        Root = InsertRecursive(Root, value);
    }
    
    private Node InsertRecursive(Node node, int value)
    {
        // Perform normal BST insertion
        if (node == null)
        {
            return new Node(value);
        }
        
        if (value < node.Value)
        {
            node.Left = InsertRecursive(node.Left, value);
        }
        else if (value > node.Value)
        {
            node.Right = InsertRecursive(node.Right, value);
        }
        else
        {
            return node; // Duplicate values not allowed
        }
        
        // Update height of current node
        node.Height = 1 + Math.Max(Height(node.Left), Height(node.Right));
        
        // Get balance factor
        int balance = GetBalance(node);
        
        // Left Left Case
        if (balance > 1 && value < node.Left.Value)
        {
            return RightRotate(node);
        }
        
        // Right Right Case
        if (balance < -1 && value > node.Right.Value)
        {
            return LeftRotate(node);
        }
        
        // Left Right Case
        if (balance > 1 && value > node.Left.Value)
        {
            node.Left = LeftRotate(node.Left);
            return RightRotate(node);
        }
        
        // Right Left Case
        if (balance < -1 && value < node.Right.Value)
        {
            node.Right = RightRotate(node.Right);
            return LeftRotate(node);
        }
        
        return node;
    }
    
    // Search for a value
    public bool Search(int value)
    {
        return SearchRecursive(Root, value);
    }
    
    private bool SearchRecursive(Node node, int value)
    {
        if (node == null)
            return false;
            
        if (node.Value == value)
            return true;
            
        if (value < node.Value)
            return SearchRecursive(node.Left, value);
        else
            return SearchRecursive(node.Right, value);
    }
    
    // In-order traversal
    public void InOrderTraversal(Node node)
    {
        if (node != null)
        {
            InOrderTraversal(node.Left);
            Console.Write(node.Value + " ");
            InOrderTraversal(node.Right);
        }
    }
}
```

### AVL Tree Example Usage

```csharp
AVLTree avl = new AVLTree();

// Insert values - tree will auto-balance
avl.Insert(10);
avl.Insert(20);
avl.Insert(30);
avl.Insert(40);
avl.Insert(50);
avl.Insert(25);

// The tree automatically maintains balance
Console.WriteLine("In-order traversal:");
avl.InOrderTraversal(avl.Root);  // 10 20 25 30 40 50

// Search
Console.WriteLine($"\nSearch 25: {avl.Search(25)}");  // True
Console.WriteLine($"Search 100: {avl.Search(100)}");  // False
```

### AVL Tree Time Complexity

| Operation | Time Complexity |
| --------- | --------------- |
| Search    | O(log n)        |
| Insert    | O(log n)        |
| Delete    | O(log n)        |

**Guaranteed O(log n)** because the tree is always balanced!

## Comparison Summary

| Feature           | Binary Tree       | Binary Search Tree           | AVL Tree                   |
| ----------------- | ----------------- | ---------------------------- | -------------------------- |
| Children per node | Max 2             | Max 2                        | Max 2                      |
| Order maintained  | No                | Yes (sorted)                 | Yes (sorted)               |
| Self-balancing    | No                | No                           | Yes                        |
| Search time       | O(n)              | O(log n) average, O(n) worst | O(log n) guaranteed        |
| Insert time       | O(n)              | O(log n) average, O(n) worst | O(log n) guaranteed        |
| Complexity        | Simple            | Moderate                     | Complex                    |
| Best use case     | General hierarchy | Sorted data, fast search     | Critical performance needs |

## When to Use Each Structure

### Binary Tree
- General hierarchical data representation
- File systems
- Organization charts
- Expression parsing

### Binary Search Tree (BST)
- Dictionary implementations
- Database indexing (when balanced)
- Symbol tables in compilers
- Priority queues

### AVL Tree
- Applications requiring guaranteed O(log n) performance
- Real-time systems with strict performance requirements
- Frequently searched datasets
- When insertions/deletions are less frequent than searches

## Conclusion

Understanding the difference between binary trees, BSTs, and AVL trees helps you choose how data is organized, stored, and retrieved efficiently. Binary trees provide a simple two-child structure, BSTs add sorted ordering for faster searches, and AVL trees guarantee optimal performance through automatic balancing. Selecting the right tree structure depends on your specific needs for search speed, insertion frequency, and performance guarantees.