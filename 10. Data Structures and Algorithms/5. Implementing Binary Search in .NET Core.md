# Binary Search Lab - Product Catalog Implementation

## Overview

In this lab, we'll implement binary search within a .NET Core console application and apply it to a practical use case: searching for product IDs in a catalog.

## Real-World Scenario

Imagine you have a catalog full of product IDs, and you need to quickly find a specific ID in that list. Binary search provides an efficient solution for this common business problem.

---

## Step 1: Application Setup

### Main Method Implementation

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        // Create array of product IDs (our catalog)
        int[] productIDs = { 1001, 1023, 1045, 1055, 1067, 1089, 1099, 2001, 2034, 2056 };
        
        // Get test target - returns 1055 for "valid", 9999 for anything else
        int target = GetTestTarget("valid");
        
        // Perform binary search
        int index = BinarySearch(productIDs, target);
        
        // Display results
        if (index != -1)
        {
            Console.WriteLine($"Found product ID {target} at index {index}");
        }
        else
        {
            Console.WriteLine($"Product ID {target} not found");
        }
    }
    
    static int GetTestTarget(string testType)
    {
        return testType == "valid" ? 1055 : 9999;
    }
}
```

**Key Points:**
- `productIDs` array represents our product catalog
- `GetTestTarget()` uses ternary operator (`?`) to return different values based on input
- If `testType` equals "valid", returns 1055 (which exists in our array)
- Otherwise returns 9999 (which doesn't exist in our array)

---

## Step 2: Implement Binary Search Function

### Understanding Binary Tree Concepts

A binary tree has no more than two children. In our implementation:
- **left**: Represents the left branch of the tree
- **right**: Represents the right branch of the tree
- **mid**: Represents our current position in the tree

### Binary Search Implementation

```csharp
static int BinarySearch(int[] array, int target)
{
    int left = 0;
    int right = array.Length - 1;
    
    // Work through the array using a while loop
    while (left <= right)
    {
        // Calculate midpoint
        int mid = left + (right - left) / 2;
        
        // Check if we found the target
        if (array[mid] == target)
        {
            return mid; // Return the index where target was found
        }
        
        // Target is in the right half
        if (array[mid] < target)
        {
            left = mid + 1;
        }
        // Target is in the left half
        else
        {
            right = mid - 1;
        }
    }
    
    // Target not found
    return -1;
}
```

**How It Works:**
- The while loop constantly shifts `mid`, `left`, and `right` to traverse the tree
- When `array[mid]` equals the target, we return that index
- If not found after exhausting the search space, return -1

### Running the Initial Test

**Expected Output:**
```
Found product ID 1055 at index 3
```

This is correct because:
- We passed "valid" to `GetTestTarget()`, which returns 1055
- Index positions: 0, 1, 2, **3** (where 1055 is located)

---

## Step 3: Add Multiple Test Cases

### Expanded Testing Implementation

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        // Product catalog
        int[] productIDs = { 1001, 1023, 1045, 1055, 1067, 1089, 1099, 2001, 2034, 2056 };
        
        // Test Case 1: Valid product ID (should be found)
        Console.WriteLine("Test Case 1: Valid Product ID");
        int target1 = GetTestTarget("valid");
        int index1 = BinarySearch(productIDs, target1);
        
        if (index1 != -1)
        {
            Console.WriteLine($"Found product ID {target1} at index {index1}");
        }
        else
        {
            Console.WriteLine($"Product ID {target1} not found");
        }
        
        Console.WriteLine();
        
        // Test Case 2: Invalid product ID (should not be found)
        Console.WriteLine("Test Case 2: Invalid Product ID");
        int target2 = GetTestTarget("invalid");
        int index2 = BinarySearch(productIDs, target2);
        
        if (index2 != -1)
        {
            Console.WriteLine($"Found product ID {target2} at index {index2}");
        }
        else
        {
            Console.WriteLine($"Product ID {target2} not found");
        }
    }
    
    static int GetTestTarget(string testType)
    {
        return testType == "valid" ? 1055 : 9999;
    }
    
    static int BinarySearch(int[] array, int target)
    {
        int left = 0;
        int right = array.Length - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target)
            {
                return mid;
            }
            
            if (array[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

### Test Results

**Expected Output:**
```
Test Case 1: Valid Product ID
Found product ID 1055 at index 3

Test Case 2: Invalid Product ID
Product ID 9999 not found
```

**Analysis:**
- **Test Case 1**: Passes "valid", gets 1055 back, finds it at index 3 ✓
- **Test Case 2**: Passes "invalid", gets 9999 back, which isn't in the product IDs array, returns "not found" ✓

---

## Step 4: Scaling and Enhancement

### Testing with Larger Datasets

```csharp
// Create a larger product catalog
int[] largeProductCatalog = new int[10000];
for (int i = 0; i < largeProductCatalog.Length; i++)
{
    largeProductCatalog[i] = (i + 1) * 10; // Products: 10, 20, 30, ..., 100000
}

// Search for a product
int targetProduct = 5550;
int result = BinarySearch(largeProductCatalog, targetProduct);

if (result != -1)
{
    Console.WriteLine($"Found product ID {targetProduct} at index {result}");
}
else
{
    Console.WriteLine($"Product ID {targetProduct} not found");
}
```

### Performance Characteristics

- The current dataset is very limited and performs extremely fast
- As you increase the data size, binary search maintains excellent performance
- The foundational algorithm remains the same regardless of dataset size

---

## Next Steps for Enhancement

Once you've validated that the basic binary search algorithm works correctly, consider these improvements:

### 1. Add Error Handling

```csharp
static int BinarySearch(int[] array, int target)
{
    // Validate input
    if (array == null || array.Length == 0)
    {
        throw new ArgumentException("Array cannot be null or empty");
    }
    
    int left = 0;
    int right = array.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        
        if (array[mid] == target)
        {
            return mid;
        }
        
        if (array[mid] < target)
        {
            left = mid + 1;
        }
        else
        {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

### 2. Add Performance Monitoring

```csharp
using System.Diagnostics;

static void TestPerformance(int[] array, int target)
{
    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Start();
    
    int result = BinarySearch(array, target);
    
    stopwatch.Stop();
    Console.WriteLine($"Search completed in {stopwatch.ElapsedTicks} ticks");
    Console.WriteLine($"Result: {(result != -1 ? $"Found at index {result}" : "Not found")}");
}
```

### 3. Generic Implementation

```csharp
static int BinarySearch<T>(T[] array, T target) where T : IComparable<T>
{
    int left = 0;
    int right = array.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        int comparison = array[mid].CompareTo(target);
        
        if (comparison == 0)
        {
            return mid;
        }
        
        if (comparison < 0)
        {
            left = mid + 1;
        }
        else
        {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

---

## Summary

This lab demonstrates:
- Setting up a practical binary search implementation for product catalogs
- Testing with both valid and invalid test cases
- Validating algorithm correctness with a limited dataset
- Scalability considerations for larger datasets
- Opportunities for enhancement and robustifica