# Binary Tree Traversal Algorithms in .NET Core

## Overview

Binary trees can be traversed in multiple ways depending on your data and goals. This guide demonstrates how to implement and test tree traversal algorithms within a .NET Core console application.

## Application Structure

The application consists of two main files:
- **Program.cs** - Entry point to the program
- **BinarySearchTree.cs** - Contains the Node and BinarySearchTree classes

## Setting Up the Tree

In the main method, we create a binary search tree and populate it with sample data:

```csharp
// Program.cs
var bst = new BinarySearchTree();
int[] values = { 50, 30, 70, 20, 40, 60, 80 };

foreach (int value in values)
{
    bst.Insert(value);
}
```

## Core Classes

### Node Class

The Node class stores the tree data and references to left and right children:

```csharp
public class Node
{
    public int Data { get; set; }
    public Node Left { get; set; }
    public Node Right { get; set; }

    public Node(int data)
    {
        Data = data;
        Left = null;
        Right = null;
    }
}
```

### BinarySearchTree Class

```csharp
public class BinarySearchTree
{
    private Node root;

    public void Insert(int data)
    {
        root = InsertRec(root, data);
    }

    private Node InsertRec(Node root, int data)
    {
        if (root == null)
        {
            root = new Node(data);
            return root;
        }

        if (data < root.Data)
            root.Left = InsertRec(root.Left, data);
        else if (data > root.Data)
            root.Right = InsertRec(root.Right, data);

        return root;
    }
}
```

## Traversal Algorithms

### 1. Pre-Order Traversal

**Use Case:** Cloning or serializing a tree

**Order:** Root → Left → Right

```csharp
public void PreOrder(Node node)
{
    if (node == null)
        return;

    Console.Write(node.Data + " ");
    PreOrder(node.Left);
    PreOrder(node.Right);
}
```

**Output:** `50 30 20 40 70 60 80`

### 2. In-Order Traversal

**Use Case:** Displaying elements in ascending order

**Order:** Left → Root → Right

```csharp
public void InOrder(Node node)
{
    if (node == null)
        return;

    InOrder(node.Left);
    Console.Write(node.Data + " ");
    InOrder(node.Right);
}
```

**Output:** `20 30 40 50 60 70 80`

### 3. Post-Order Traversal

**Use Case:** Deleting nodes (delete children before parents)

**Order:** Left → Right → Root

```csharp
public void PostOrder(Node node)
{
    if (node == null)
        return;

    PostOrder(node.Left);
    PostOrder(node.Right);
    Console.Write(node.Data + " ");
}
```

**Output:** `20 40 30 60 80 70 50`

### 4. Level-Order Traversal

**Use Case:** Finding the shortest path through a tree (Breadth-First Search)

**Order:** Level by level, left to right

```csharp
public void LevelOrder(Node node)
{
    if (node == null)
        return;

    Queue<Node> queue = new Queue<Node>();
    queue.Enqueue(node);

    while (queue.Count > 0)
    {
        Node tempNode = queue.Dequeue();
        Console.Write(tempNode.Data + " ");

        if (tempNode.Left != null)
            queue.Enqueue(tempNode.Left);

        if (tempNode.Right != null)
            queue.Enqueue(tempNode.Right);
    }
}
```

**Output:** `50 30 70 20 40 60 80`

## Complete Example

```csharp
// Program.cs
using System;

class Program
{
    static void Main(string[] args)
    {
        var bst = new BinarySearchTree();
        int[] values = { 50, 30, 70, 20, 40, 60, 80 };

        foreach (int value in values)
        {
            bst.Insert(value);
        }

        Console.WriteLine("Pre-Order Traversal:");
        bst.PreOrder();
        Console.WriteLine();

        Console.WriteLine("In-Order Traversal:");
        bst.InOrder();
        Console.WriteLine();

        Console.WriteLine("Post-Order Traversal:");
        bst.PostOrder();
        Console.WriteLine();

        Console.WriteLine("Level-Order Traversal:");
        bst.LevelOrder();
        Console.WriteLine();
    }
}
```

## Summary

Each traversal algorithm serves a specific purpose:
- **Pre-Order**: Best for copying/serializing tree structures
- **In-Order**: Produces sorted output for binary search trees
- **Post-Order**: Ideal for deletion operations (children before parents)
- **Level-Order**: Finds shortest paths and processes trees by levels

Choose the appropriate algorithm based on your specific use case and data processing needs.