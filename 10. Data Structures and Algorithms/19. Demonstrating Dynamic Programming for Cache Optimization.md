# Memoization in .NET Core

## Introduction

Memoization is the ability of an application to remember commonly used or previously used calculations or data without having to recalculate or go back to a database or API call to get that data. It's a form of caching where the application does keep those items in memory and then reuses them as needed. In this guide, we're going to demonstrate how to implement memoization for cache optimization in .NET Core.

## Fibonacci Calculation Example

### Setup

In this application, we've got a dictionary that we're creating at the top called `memo`, and then we've got a Fibonacci method, and this just does a Fibonacci calculation. In this Fibonacci calculation, we're actually going to save the calculation to the memo at a specific point. If that memo does contain that calculation, then we're going to reuse it. Otherwise, we calculate it in the method.

The main method, which runs when the application runs, we're passing in 40, so that's the calculation we want to do. We're passing it into that method, and it's just going to do the calculation and then store it. Now, the first time through, it will do the calculation because it doesn't have anything in memory.

### How the Memoization Works

Here's where we have that memoization function in the if statement. If the memo contains the key N, which is what we're passing in, then it's going to return whatever's in the memo. And that's where it doesn't have to do the Fibonacci calculation again.

If that's not true, then it calculates the Fibonacci sequence, stores it in the memo (the dictionary that we created above), and then returns the result. This is a very simple example of how you can use a dictionary as a memoization technique to save your program from having to recalculate.

### Use Cases

Now, this is a very simple calculation. You can imagine that this could be something like an API call, a database lookup, or a very complex calculation, where once it's done, if it's a repetitive calculation or a repetitive call, you can store it in memory so that you don't have to do that again and save the time and effort of having to make that call or do that calculation.

### Debugging Through the Example

Let's put a breakpoint and run this in the debugger so we can see what this looks like. It will stop at the if statement. The memo does not contain n. The n is 40. That's what we're returning in. If the dictionary did contain that item, it would return immediately, but we're going to skip over that because it does need to do the calculation.

Calculate the Fibonacci sequence, and then it goes through again and checks to see if it's in the memo. You can see it's doing that calculation here again and again, which is what we would expect. This is the result of that calculation, and then it's going to return it to the calling program.

The Fibonacci of 40 is this sequence, and that's what we have now saved in the memo. If we were to call that again, it would skip over the calculation and just return the value that was in the memo. That's a version of memoization.

### Performance Considerations

Now, as we were stepping through, you can see it had to go through that sequence. It had to calculate that sequence over and over again on a computer like this with that simple calculation. It would seem almost instantaneous, but there's lots of scenarios where that process would take much longer. Storing it in memory would be a much better approach.

### Demonstrating the Cache Hit

To illustrate how this works, we're going to create another console write line. We have to do this twice because it has to stay in memory. We're not writing out to persistent storage for this example. Let's put a breakpoint and step into the code when it gets to this breakpoint.

We've got our first Fibonacci sequence, and now let's go ahead and step into the method again. It should evaluate if memo contains n. It should contain n, so it should return immediately. It returned. It didn't have to do the calculation again, and then it writes out to the console second Fibonacci 40. That's the example of how memoization works in this context.

## Simulated API Call Example

Now let's work with an API call. We're going to simulate an API cache using this memoization approach.

### Implementation

Here we have a `FetchData` method. We're creating a dictionary again with a cache, and we have a fetch data method. We're going to evaluate the cache to see if it contains the query that we're looking for. If it does contain the query that we're looking for, we're going to return the cached value for that query, and if it doesn't, then we're going to pretend like we're fetching data from the API, sleep for two seconds just to simulate that call, and then return the data for that query.

### Test Scenario

Here we have two of the same query, "user:123", twice. The first time through should be "data for user:123". The second time should be "return cache result for user:123", and then the third should be "data for product:456". It's using the cached data the second time because we're sending in the identical query, and then it's going to have to rerun that API call for "product:456".

### Running the Example

Let's run this in the terminal. There it's waiting for two seconds, and then it goes back and says "data for user:123" because it got it from the cache, and "return data for user:123", and then it's going to fetch data from the API for "product:456", and then return the data for "product:456". That second result was much quicker because it didn't have to sleep for two seconds while it made the simulated API call, it just returned data from the cache.

## Important Considerations

### Memory Impact

One impact of using memoization in this way is that you do take up memory, so you have to have a computer system that can actually be able to store the data that you need to store in the cache. You can run into resource issues like memory, and if you're storing it to disk, it could cause issues with the disk space as well, so you've got to think through those kinds of things.

### General Recommendation

In general, memoization techniques and caching always improves performance and is a good option when you're thinking about how to architect and design your application.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;

namespace MemoizationExamples
{
    /// <summary>
    /// Represents a cached data entry with metadata
    /// </summary>
    class CacheEntry
    {
        public string Data { get; set; }
        public DateTime CachedAt { get; set; }
        public int AccessCount { get; set; }

        public CacheEntry(string data)
        {
            Data = data;
            CachedAt = DateTime.Now;
            AccessCount = 0;
        }
    }

    class Program
    {
        // Dictionary to store cached API results with metadata
        private static Dictionary<string, CacheEntry> cache = new Dictionary<string, CacheEntry>();
        private static int apiCallCount = 0;
        private static int cacheHitCount = 0;

        static void Main(string[] args)
        {
            Console.WriteLine("=== Simulated API Call with Caching Demo ===\n");

            // Simulate multiple API calls
            var queries = new[]
            {
                "user:123",      // First call - cache miss
                "user:123",      // Second call - cache hit
                "product:456",   // Third call - cache miss
                "user:123",      // Fourth call - cache hit
                "product:456",   // Fifth call - cache hit
                "order:789"      // Sixth call - cache miss
            };

            Console.WriteLine("Making API calls...\n");

            foreach (var query in queries)
            {
                Console.WriteLine($">>> Requesting: {query}");
                Stopwatch sw = Stopwatch.StartNew();
                string result = FetchData(query);
                sw.Stop();
                Console.WriteLine($"    Response: {result}");
                Console.WriteLine($"    Time: {sw.ElapsedMilliseconds}ms\n");
            }

            // Display cache statistics
            DisplayCacheStatistics();

            // Demonstrate cache invalidation
            Console.WriteLine("\n--- Cache Management ---");
            Console.WriteLine($"Invalidating cache entry for 'user:123'...");
            InvalidateCache("user:123");
            
            Console.WriteLine($"Making another request for 'user:123'...");
            Stopwatch sw2 = Stopwatch.StartNew();
            FetchData("user:123");
            sw2.Stop();
            Console.WriteLine($"Time: {sw2.ElapsedMilliseconds}ms (cache was cleared, so it fetched from API)\n");

            // Display final statistics
            DisplayCacheStatistics();

            // Clear all cache
            Console.WriteLine("\n--- Clearing All Cache ---");
            ClearCache();
            DisplayCacheStatistics();
        }

        /// <summary>
        /// Fetches data with caching mechanism
        /// </summary>
        /// <param name="query">The query string for the API</param>
        /// <returns>The data response</returns>
        static string FetchData(string query)
        {
            // Check if data is in cache
            if (cache.ContainsKey(query))
            {
                Console.WriteLine($"    ✓ Cache HIT for '{query}'");
                cacheHitCount++;
                
                // Update access count
                cache[query].AccessCount++;
                
                return cache[query].Data;
            }

            // Cache miss - fetch from "API"
            Console.WriteLine($"    ✗ Cache MISS for '{query}'");
            Console.WriteLine($"    → Fetching from API...");
            
            // Simulate API call with 2-second delay
            Thread.Sleep(2000);
            apiCallCount++;
            
            // Simulate returned data
            string data = $"Data for {query}";
            
            // Store in cache with metadata
            cache[query] = new CacheEntry(data);
            
            Console.WriteLine($"    → Data cached successfully");
            
            return data;
        }

        /// <summary>
        /// Invalidates a specific cache entry
        /// </summary>
        /// <param name="query">The query to invalidate</param>
        static void InvalidateCache(string query)
        {
            if (cache.ContainsKey(query))
            {
                cache.Remove(query);
                Console.WriteLine($"Cache entry '{query}' removed.");
            }
            else
            {
                Console.WriteLine($"Cache entry '{query}' not found.");
            }
        }

        /// <summary>
        /// Clears all cache entries
        /// </summary>
        static void ClearCache()
        {
            int entriesCleared = cache.Count;
            cache.Clear();
            Console.WriteLine($"Cleared {entriesCleared} cache entries.");
        }

        /// <summary>
        /// Displays comprehensive cache statistics
        /// </summary>
        static void DisplayCacheStatistics()
        {
            Console.WriteLine("=== Cache Statistics ===");
            Console.WriteLine($"Total API calls made: {apiCallCount}");
            Console.WriteLine($"Total cache hits: {cacheHitCount}");
            Console.WriteLine($"Cache hit rate: {(cacheHitCount > 0 ? (double)cacheHitCount / (apiCallCount + cacheHitCount) * 100 : 0):F1}%");
            Console.WriteLine($"Current cache size: {cache.Count} entries");
            
            if (cache.Count > 0)
            {
                Console.WriteLine("\n--- Cached Entries ---");
                foreach (var entry in cache)
                {
                    Console.WriteLine($"  Key: {entry.Key}");
                    Console.WriteLine($"    Data: {entry.Value.Data}");
                    Console.WriteLine($"    Cached at: {entry.Value.CachedAt:yyyy-MM-dd HH:mm:ss}");
                    Console.WriteLine($"    Access count: {entry.Value.AccessCount}");
                    Console.WriteLine($"    Age: {(DateTime.Now - entry.Value.CachedAt).TotalSeconds:F1}s");
                }
            }
            Console.WriteLine();
        }
    }
}