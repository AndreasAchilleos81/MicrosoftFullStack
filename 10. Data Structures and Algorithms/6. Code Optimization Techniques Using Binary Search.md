# Binary Search Performance Analysis

## Overview

Binary search demonstrates its true power when operating against large datasets. Different search algorithms serve different needs, and binary search is optimal for larger, sorted datasets. This guide demonstrates binary search implementation in .NET Core to optimize search operations.

**Important Prerequisite:** Binary search requires the dataset to be sorted.

---

## Basic Binary Search Implementation

### Simple Version

```csharp
static int BinarySearch(int[] sortedArray, int target)
{
    int left = 0;
    int right = sortedArray.Length - 1;
    
    while (left <= right)
    {
        // Calculate midpoint
        int mid = left + (right - left) / 2;
        
        // Check if target is at midpoint
        if (sortedArray[mid] == target)
        {
            return mid;
        }
        
        // Target is in right half
        if (sortedArray[mid] < target)
        {
            left = mid + 1;
        }
        // Target is in left half
        else
        {
            right = mid - 1;
        }
    }
    
    return -1; // Not found
}
```

**How It Works:**
1. Set `left` to 0 and `right` to array length minus 1 (zero-based indexing)
2. Enter while loop that runs as long as `left <= right`
3. Calculate midpoint: `mid = left + (right - left) / 2`
4. Compare array value at midpoint with target
5. Adjust boundaries and repeat until target is found

---

## Handling Edge Cases

The simple version doesn't account for edge casesâ€”situations where circumstances differ from normal expectations. Here's a more robust implementation:

### Edge Case #1: Empty Array

```csharp
static int BinarySearch(int[] sortedArray, int target)
{
    // Check if array is empty
    if (sortedArray.Length == 0)
    {
        return -1; // No value found - nothing to search
    }
    
    int left = 0;
    int right = sortedArray.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        
        if (sortedArray[mid] == target)
        {
            return mid;
        }
        
        if (sortedArray[mid] < target)
        {
            left = mid + 1;
        }
        else
        {
            right = mid - 1;
        }
    }
    
    // Value not found in array
    return -1;
}
```

### Edge Case #2: Multiple Matching Values

The current implementation doesn't handle multiple occurrences of the target value. If your array contains multiple instances (e.g., two or more 5's), you might need:

```csharp
static int[] BinarySearchAll(int[] sortedArray, int target)
{
    List<int> indices = new List<int>();
    
    // Find first occurrence
    int index = BinarySearch(sortedArray, target);
    
    if (index == -1)
    {
        return new int[0]; // Not found
    }
    
    // Search left for additional occurrences
    int left = index - 1;
    while (left >= 0 && sortedArray[left] == target)
    {
        indices.Insert(0, left);
        left--;
    }
    
    // Add the found index
    indices.Add(index);
    
    // Search right for additional occurrences
    int right = index + 1;
    while (right < sortedArray.Length && sortedArray[right] == target)
    {
        indices.Add(right);
        right++;
    }
    
    return indices.ToArray();
}
```

**Key Consideration:** Think through edge cases to ensure you're addressing all user needs.

---

## Performance Testing: Small Dataset

### Basic Test with 7 Elements

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        int[] numbers = { 123, 234, 345, 456, 567, 678, 789 };
        int target = 456;
        
        int result = BinarySearch(numbers, target);
        
        if (result != -1)
        {
            Console.WriteLine($"Found at index {result}");
        }
        else
        {
            Console.WriteLine("Not found");
        }
    }
    
    static int BinarySearch(int[] sortedArray, int target)
    {
        if (sortedArray.Length == 0)
        {
            return -1;
        }
        
        int left = 0;
        int right = sortedArray.Length - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            
            if (sortedArray[mid] == target)
            {
                return mid;
            }
            
            if (sortedArray[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

**Expected Output:**
```
Found at index 3
```

Position breakdown: 0, 1, 2, **3** (456 is at index 3)

---

## Performance Testing: Large Dataset

### Testing with 100,000 Records

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        // Create array with 100,000 randomly generated records
        Random random = new Random();
        int[] largeArray = new int[100000];
        
        for (int i = 0; i < largeArray.Length; i++)
        {
            largeArray[i] = i;
        }
        
        // Randomly select an item from the array
        int randomIndex = random.Next(0, largeArray.Length);
        int target = largeArray[randomIndex];
        
        Console.WriteLine($"Searching for User ID: {target}");
        
        // Perform binary search
        int result = BinarySearch(largeArray, target);
        
        if (result != -1)
        {
            Console.WriteLine($"Found at index {result}");
        }
        else
        {
            Console.WriteLine("Not found");
        }
    }
    
    static int BinarySearch(int[] sortedArray, int target)
    {
        if (sortedArray.Length == 0)
        {
            return -1;
        }
        
        int left = 0;
        int right = sortedArray.Length - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            
            if (sortedArray[mid] == target)
            {
                return mid;
            }
            
            if (sortedArray[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

**Sample Output:**
```
Searching for User ID: 63818
Found at index 63818
```

**Performance:** Even with 100,000 records, binary search returns results very quickly.

### Scaling to 1 Million Records

```csharp
// Change array size to 1 million
int[] largeArray = new int[1000000];

for (int i = 0; i < largeArray.Length; i++)
{
    largeArray[i] = i;
}

// Rest of code remains the same
```

**Result:** Even with a million items, binary search operates extremely fast.

---

## Binary Search vs Linear Search Comparison

### Linear Search Implementation

```csharp
static int LinearSearch(int[] array, int target)
{
    // Start at beginning, go toward end
    for (int i = 0; i < array.Length; i++)
    {
        if (array[i] == target)
        {
            return i;
        }
    }
    
    return -1; // Not found
}
```

**How Linear Search Works:**
- Goes through each item sequentially from start to finish
- If the target is at the end of a million-record array, it checks every single item
- Performance varies greatly based on target position

---

## Performance Benchmarking with Stopwatch

### Complete Comparison Test

```csharp
using System;
using System.Diagnostics;

class Program
{
    static void Main(string[] args)
    {
        // Create test array
        int arraySize = 100000;
        int[] testArray = new int[arraySize];
        
        for (int i = 0; i < arraySize; i++)
        {
            testArray[i] = i;
        }
        
        // Randomly select target
        Random random = new Random();
        int target = testArray[random.Next(0, arraySize)];
        
        Console.WriteLine($"Array Size: {arraySize:N0}");
        Console.WriteLine($"Searching for: {target}");
        Console.WriteLine();
        
        // Test Binary Search
        Stopwatch binaryWatch = new Stopwatch();
        binaryWatch.Start();
        int binaryResult = BinarySearch(testArray, target);
        binaryWatch.Stop();
        
        Console.WriteLine("Binary Search:");
        Console.WriteLine($"  Found at index: {binaryResult}");
        Console.WriteLine($"  Time: {binaryWatch.ElapsedTicks} ticks");
        Console.WriteLine();
        
        // Test Linear Search
        Stopwatch linearWatch = new Stopwatch();
        linearWatch.Start();
        int linearResult = LinearSearch(testArray, target);
        linearWatch.Stop();
        
        Console.WriteLine("Linear Search:");
        Console.WriteLine($"  Found at index: {linearResult}");
        Console.WriteLine($"  Time: {linearWatch.ElapsedTicks} ticks");
        Console.WriteLine();
        
        // Calculate difference
        long difference = linearWatch.ElapsedTicks - binaryWatch.ElapsedTicks;
        double ratio = (double)linearWatch.ElapsedTicks / binaryWatch.ElapsedTicks;
        
        Console.WriteLine($"Difference: {difference} ticks");
        Console.WriteLine($"Linear search was {ratio:F2}x slower");
    }
    
    static int BinarySearch(int[] sortedArray, int target)
    {
        if (sortedArray.Length == 0) return -1;
        
        int left = 0;
        int right = sortedArray.Length - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            
            if (sortedArray[mid] == target)
                return mid;
            
            if (sortedArray[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        
        return -1;
    }
    
    static int LinearSearch(int[] array, int target)
    {
        for (int i = 0; i < array.Length; i++)
        {
            if (array[i] == target)
                return i;
        }
        return -1;
    }
}
```

---

## Performance Results Analysis

### Small Dataset (7 elements)

**Searching for 678 (at end of array):**
```
Binary Search: ~1,500 ticks
Linear Search: ~800 ticks
```

**Observation:** Linear search performs better on small datasets because:
- Binary search has overhead from the while loop and splitting operations
- Linear search simply iterates from start to finish quickly

---

### Medium Dataset (100,000 elements)

**Sample Result (target at index 25,097):**
```
Binary Search: 1,871 ticks
Linear Search: 2,146 ticks
```

**Observation:** Binary search begins showing performance improvements, though results vary based on target position.

---

### Large Dataset (1,000,000 elements)

**Sample Result #1:**
```
Found at index: 45,200
Binary Search: ~5,500 ticks
Linear Search: ~12,000 ticks (2x slower)
```

**Sample Result #2 (target deep in array at 647,350):**
```
Binary Search: ~4,800 ticks
Linear Search: ~18,000 ticks (3.75x slower)
```

**Observation:** Binary search's divide-and-conquer approach excels with larger arrays. Linear search, starting from the beginning, takes significantly longer when targets are deep in the array.

---

### Very Large Dataset (10,000,000 elements)

**Sample Result (target at index 8,202,000):**
```
Binary Search: 3,200 ticks
Linear Search: 216,000 ticks (67.5x slower!)
```

**Observation:** The performance gap becomes dramatic. Binary search maintains consistent speed regardless of target position, while linear search degrades proportionally with target depth.

---

## Performance Comparison Table

| Dataset Size | Target Position | Binary Search | Linear Search  | Winner               |
| ------------ | --------------- | ------------- | -------------- | -------------------- |
| 7            | End             | ~1,500 ticks  | ~800 ticks     | Linear               |
| 1,000        | Variable        | ~1,200 ticks  | ~900 ticks     | Linear               |
| 10,000       | Variable        | ~2,000 ticks  | ~2,200 ticks   | Binary               |
| 100,000      | Middle          | ~1,900 ticks  | ~2,100 ticks   | Binary               |
| 1,000,000    | Deep (647K)     | ~5,000 ticks  | ~18,000 ticks  | Binary (3.6x faster) |
| 10,000,000   | Deep (8.2M)     | ~3,200 ticks  | ~216,000 ticks | Binary (67x faster)  |

---

## Key Takeaways

### When to Use Binary Search
- Large datasets (10,000+ elements)
- Sorted data
- Need consistent performance regardless of target position
- Real-world applications: databases, product catalogs, user records

### When to Use Linear Search
- Small datasets (under 1,000 elements)
- Unsorted data
- Simple implementations with minimal overhead
- When target is likely near the beginning

### Performance Characteristics

**Binary Search:**
- Time Complexity: O(log n)
- Space Complexity: O(1)
- Requires sorted data
- Consistent performance

**Linear Search:**
- Time Complexity: O(n)
- Space Complexity: O(1)
- Works with unsorted data
- Performance varies with target position

---

## Conclusion

The choice of search algorithm depends on your specific scenario:
- **Small datasets:** Linear search's simplicity often wins
- **Large datasets:** Binary search's efficiency becomes essential
- **Real-world applications:** As data grows, binary search provides dramatic performance improvements

The dramatic difference in performance (67x faster with 10 million records) demonstrates why understanding and implementing the right algorithm matters for production systems.