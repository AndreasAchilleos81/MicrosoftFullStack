# Round-Robin Load Balancer Lab

## Overview

In this lab, you'll implement a simple load balancer algorithm in a .NET Core application. You'll work with the round-robin algorithm, which balances load by distributing requests evenly across multiple servers in sequential order.

## Step 1: Set Up the Application

First, set up the basic structure of your application with the proper namespace and main method.

### Requirements

- Create a namespace called `LoadBalancer` to group classes together
- Set up the `Program.cs` file with a main method
- Initialize the application and create server instances
- Implement a request simulation loop

### What the Main Method Does

1. Writes a startup message to the console
2. Creates a list of servers to balance load across
3. Instantiates a round-robin load balancer object
4. Simulates incoming requests using a loop (0-9, total of 10 requests)
5. Routes each request to the next available server using `getNextServer()`
6. Processes the request on the selected server

## Step 2: Create the Server Class

The server class represents individual servers that will handle requests.

### Server Class Components

**Properties:**
- `ID` - A unique identifier for each server

**Methods:**
- `processRequest()` - A public void method that simulates request processing

### Functionality

The `processRequest()` method:
- Takes no parameters
- Returns no value (void)
- Writes to the console which server is processing the request
- Displays the server ID to show which server handled the request

## Step 3: Implement the Round-Robin Load Balancer

This is where the core load balancing logic resides.

### Class Structure

**Private Variables:**
- `servers` - List of available servers
- `currentIndex` - Tracks which server should receive the next request

### Constructor

The round-robin load balancer constructor:
- Accepts a list of servers as a parameter
- Assigns the servers to the private `servers` variable
- Makes the server list available to the `getNextServer()` method

### The getNextServer() Method

This method manages request distribution among servers.

**How It Works:**

1. Returns a `Server` object to the calling method
2. Sets the server to `servers[currentIndex]`
3. Updates `currentIndex` to `currentIndex + 1`
4. Uses the modulo operator to ensure the index stays within bounds
5. Returns the selected server

**The Modulo Operator:**
- Ensures the index wraps around when it reaches the end of the server list
- For 3 servers (indexes 0, 1, 2), it cycles: 0 → 1 → 2 → 0 → 1 → 2...
- Prevents index out of bounds errors

### Request Flow

1. Request comes in
2. `getNextServer()` is called
3. Current server is selected based on `currentIndex`
4. Index is incremented for the next request
5. Server is returned and processes the request
6. Next request goes to the next server in line

## Testing the Application

When you run the application, you'll see:

1. "Load balancer simulation has started" message
2. Sequential processing through servers:
   - Request 1 → Server 1
   - Request 2 → Server 2
   - Request 3 → Server 3
   - Request 4 → Server 1
   - Request 5 → Server 2
   - Request 6 → Server 3
   - (Pattern continues...)
   - Request 10 → Server 1

The pattern shows even distribution across all servers in order.

## Round-Robin Load Balancer Characteristics

### Advantages

- Simple to implement
- Predictable behavior
- Even distribution of requests
- Works well in controlled environments
- Efficient for similar server capacities

### Limitations

- Not intelligent about server load
- Cannot adapt if a server becomes overloaded
- Doesn't handle server failures automatically
- May need additional code for high-traffic scenarios (millions of requests)
- Doesn't account for varying request complexity

### Best Use Cases

Round-robin load balancers work best when:
- Servers have similar processing power
- Requests are relatively uniform in complexity
- The environment is tightly controlled
- Simple, even distribution is the primary goal

### Potential Improvements

For production environments with high traffic, consider adding:
- Health checks to detect server failures
- Load monitoring to avoid overloaded servers
- Weighted distribution for servers with different capacities
- Fallback mechanisms for failed requests

## Summary

This lab demonstrates a fundamental load balancing technique. While round-robin is simple, it provides a solid foundation for understanding more complex load balancing algorithms. In specific contexts with controlled environments and similar server capabilities, round-robin can be highly effective for distributing load evenly across your infrastructure.


using System;
using System.Collections.Generic;

namespace LoadBalancer
{
    // Step 2: Server Class
    class Server
    {
        public int ID { get; set; }

        public void ProcessRequest()
        {
            Console.WriteLine($"Processing request on Server {ID}");
        }
    }

    // Step 3: Round-Robin Load Balancer Class
    class RoundRobinLoadBalancer
    {
        private List<Server> servers;
        private int currentIndex = 0;

        // Constructor - initializes the load balancer with a list of servers
        public RoundRobinLoadBalancer(List<Server> servers)
        {
            this.servers = servers;
        }

        // Method to get the next server in the round-robin sequence
        public Server GetNextServer()
        {
            // Get the server at the current index
            Server server = servers[currentIndex];
            
            // Update the current index for the next request
            // Modulo operator ensures we wrap around to 0 when we reach the end
            currentIndex = (currentIndex + 1) % servers.Count;
            
            // Return the selected server
            return server;
        }
    }

    // Step 1: Main Program
    class Program
    {
        static void Main(string[] args)
        {
            // Start the simulation
            Console.WriteLine("Load balancer simulation has started");
            Console.WriteLine("=====================================\n");

            // Create a list of servers
            List<Server> servers = new List<Server>
            {
                new Server { ID = 1 },
                new Server { ID = 2 },
                new Server { ID = 3 }
            };

            // Create the round-robin load balancer
            RoundRobinLoadBalancer loadBalancer = new RoundRobinLoadBalancer(servers);

            // Simulate 10 incoming requests
            for (int i = 0; i < 10; i++)
            {
                // Get the next server in the round-robin sequence
                Server server = loadBalancer.GetNextServer();
                
                // Process the request on the selected server
                server.ProcessRequest();
            }

            Console.WriteLine("\n=====================================");
            Console.WriteLine("Load balancer simulation completed");
            Console.ReadLine();
        }
    }
}

/* 
 * Expected Output:
 * =====================================
 * Load balancer simulation has started
 * =====================================
 * 
 * Processing request on Server 1
 * Processing request on Server 2
 * Processing request on Server 3
 * Processing request on Server 1
 * Processing request on Server 2
 * Processing request on Server 3
 * Processing request on Server 1
 * Processing request on Server 2
 * Processing request on Server 3
 * Processing request on Server 1
 * 
 * =====================================
 * Load balancer simulation completed
 */