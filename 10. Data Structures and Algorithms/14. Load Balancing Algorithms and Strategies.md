# Load Balancing Algorithms Guide

## Introduction

When writing algorithms to balance load, particularly in the context of servers where you're trying to send traffic based on specific needs, the approach depends on your goals and requirements. This guide demonstrates how load balancing algorithms work and their role in improving application performance.

## 1. Round Robin Algorithm

The round robin algorithm assigns each incoming request to the next server in a loop. This approach is simple and effective when servers have similar processing power or when you want to evenly spread the load across all servers.

### How It Works

- Assigns requests sequentially to each server
- Loops back to the first server after reaching the last one
- Best for environments with similar server capabilities

### Key Features

- Simple implementation
- Equal distribution of load
- No monitoring of server state required
- Predictable traffic patterns

## 2. Least Connections Algorithm

This algorithm finds the server with the least amount of active connections and routes new requests to it. It's ideal when you want to balance load based on actual server utilization.

### How It Works

- Monitors the number of connections on each server
- Routes new requests to the server with the fewest connections
- Dynamically adjusts based on real-time connection counts

### Example Scenario

Starting state:
- Server A: 7 connections
- Server B: 9 connections
- Server C: 5 connections

The algorithm will prioritize Server C first, then Server A, avoiding Server B until it has fewer connections than the others.

## 3. Weighted Round Robin Algorithm

This algorithm extends the basic round robin by assigning weights to servers based on their capabilities (CPU power, network capacity, etc.). Higher-weighted servers receive more traffic.

### How It Works

- Assigns a weight to each server (e.g., 1 = most powerful, 2 = second, 3 = third)
- Favors higher-weight servers more frequently
- Distributes load proportionally to server capacity

### Example Weight Configuration

- Server A: Weight 2 (second most powerful)
- Server B: Weight 1 (most powerful)
- Server C: Weight 3 (least powerful)

More powerful servers receive proportionally more requests based on their weight.

## 4. IP Hash Algorithm

This algorithm uses hashing to ensure that requests from the same IP address always route to the same server. This improves performance by maintaining session affinity and reducing lookup overhead.

### How It Works

- Creates a hash from the client's IP address
- Uses modulo operation to map hash to a server index
- Guarantees the same IP always connects to the same server

### Benefits

- Consistent server assignment per client
- Improved session management
- Reduced server lookup time
- Better for stateful applications

### Example Behavior

- IP 192.168.1.1 → Always routes to Server A
- IP 192.168.1.2 → Always routes to Server B
- Subsequent requests from the same IP maintain server affinity

## Algorithm Selection Guide

Choose your load balancing algorithm based on your needs:

- **Round Robin**: Uniform server capabilities, simple distribution needs
- **Least Connections**: Varying request durations, need to balance actual load
- **Weighted Round Robin**: Servers with different capacities or capabilities
- **IP Hash**: Session persistence requirements, stateful applications

## Performance Considerations

Each algorithm offers different performance characteristics:

- Round robin provides predictable, even distribution
- Least connections adapts to actual server load dynamically
- Weighted round robin optimizes for heterogeneous server environments
- IP hash minimizes connection overhead and supports session affinity

These algorithms can be applied not only to server load balancing but to many distributed system scenarios where work needs to be distributed across multiple resources.


using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace LoadBalancingAlgorithms
{
    // 1. Round Robin Load Balancer
    class RoundRobinLB
    {
        private List<string> servers;
        private int index = 0;

        public RoundRobinLB(string[] servers)
        {
            this.servers = new List<string>(servers);
        }

        public string GetServer()
        {
            string server = servers[index % servers.Count];
            index++;
            return server;
        }
    }

    // 2. Least Connections Load Balancer
    class LeastConnectionsLB
    {
        private Dictionary<string, int> serverConnections;

        public LeastConnectionsLB(string[] servers)
        {
            serverConnections = new Dictionary<string, int>();
            foreach (var server in servers)
            {
                serverConnections[server] = 0;
            }
        }

        public void SetInitialLoad()
        {
            // Simulate pre-existing connections
            if (serverConnections.ContainsKey("Server-A"))
                serverConnections["Server-A"] = 7;
            if (serverConnections.ContainsKey("Server-B"))
                serverConnections["Server-B"] = 9;
            if (serverConnections.ContainsKey("Server-C"))
                serverConnections["Server-C"] = 5;
        }

        public string GetServer()
        {
            // Find server with minimum connections
            var server = serverConnections.OrderBy(x => x.Value).First().Key;
            serverConnections[server]++; // Add new connection
            return server;
        }
    }

    // 3. Weighted Round Robin Load Balancer
    class WeightedRoundRobinLB
    {
        private List<string> servers;
        private int index = 0;

        public WeightedRoundRobinLB(Dictionary<string, int> serverWeights)
        {
            servers = new List<string>();
            // Add servers to list based on their weight
            foreach (var server in serverWeights.OrderBy(x => x.Value))
            {
                for (int i = 0; i < server.Value; i++)
                {
                    servers.Add(server.Key);
                }
            }
        }

        public string GetServer()
        {
            string server = servers[index % servers.Count];
            index++;
            return server;
        }
    }

    // 4. IP Hash Load Balancer
    class IPHashLB
    {
        private string[] servers;

        public IPHashLB(string[] servers)
        {
            this.servers = servers;
        }

        private int GetHash(string ipAddress)
        {
            using (MD5 md5 = MD5.Create())
            {
                byte[] hash = md5.ComputeHash(Encoding.UTF8.GetBytes(ipAddress));
                return BitConverter.ToInt32(hash, 0);
            }
        }

        public string GetServer(string ipAddress)
        {
            int hash = Math.Abs(GetHash(ipAddress));
            int index = hash % servers.Length;
            return servers[index];
        }
    }

    // Main Program
    class Program
    {
        static void Main(string[] args)
        {
            // Demo 1: Round Robin
            Console.WriteLine("=== Round Robin Load Balancer ===");
            string[] servers = { "Server-A", "Server-B", "Server-C" };
            RoundRobinLB rrLB = new RoundRobinLB(servers);
            
            for (int i = 0; i < 6; i++)
            {
                Console.WriteLine($"Request {i + 1}: {rrLB.GetServer()}");
            }

            // Demo 2: Least Connections
            Console.WriteLine("\n=== Least Connections Load Balancer ===");
            LeastConnectionsLB lcLB = new LeastConnectionsLB(servers);
            lcLB.SetInitialLoad();
            
            for (int i = 0; i < 6; i++)
            {
                Console.WriteLine($"Request {i + 1}: {lcLB.GetServer()}");
            }

            // Demo 3: Weighted Round Robin
            Console.WriteLine("\n=== Weighted Round Robin Load Balancer ===");
            Dictionary<string, int> serverWeights = new Dictionary<string, int>
            {
                { "Server-A", 2 },  // Weight 2
                { "Server-B", 1 },  // Weight 1 (most powerful)
                { "Server-C", 3 }   // Weight 3
            };
            WeightedRoundRobinLB wrLB = new WeightedRoundRobinLB(serverWeights);
            
            for (int i = 0; i < 6; i++)
            {
                Console.WriteLine($"Request {i + 1}: {wrLB.GetServer()}");
            }

            // Demo 4: IP Hash
            Console.WriteLine("\n=== IP Hash Load Balancer ===");
            IPHashLB ipLB = new IPHashLB(servers);
            
            string[] ipAddresses = {
                "192.168.1.1",
                "192.168.1.2",
                "192.168.1.1",
                "192.168.1.2"
            };

            foreach (var ip in ipAddresses)
            {
                Console.WriteLine($"IP {ip}: {ipLB.GetServer(ip)}");
            }

            Console.ReadLine();
        }
    }
}