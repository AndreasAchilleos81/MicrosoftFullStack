# Directed vs Undirected Graphs in C#

## Overview

Connections shape how we understand the world, from the order of tasks in a project to the friendships we build. By understanding directed and undirected graphs, we can organize and represent these connections in powerful ways.

## What is a Graph?

In back-end development, a **graph** is a data structure consisting of:
- **Nodes** (or vertices): Points representing items like tasks or people
- **Edges**: Lines representing relationships or connections between nodes

Graphs help us organize relationships, such as tasks in a project or connections between friends.

## Directed Graphs

### Definition

A **directed graph** (or digraph) shows connections with edges that have a specific direction, indicating one-way relationships between nodes. This makes them perfect for organizing steps or tasks that follow one another.

### Use Case: Project Task Management

Imagine you're managing a project with tasks that must be completed in a specific order:
- Task 1 must happen before Task 2
- Task 2 must happen before Task 3

In a directed graph, each task points to the next, showing the sequence clearly.

### C# Implementation

```csharp
public class DirectedGraph
{
    private Dictionary<string, List<string>> adjacencyList;

    public DirectedGraph()
    {
        adjacencyList = new Dictionary<string, List<string>>();
    }

    // Add a node to the graph
    public void AddNode(string node)
    {
        if (!adjacencyList.ContainsKey(node))
        {
            adjacencyList[node] = new List<string>();
        }
    }

    // Add a directed edge from source to destination
    public void AddEdge(string source, string destination)
    {
        if (!adjacencyList.ContainsKey(source))
        {
            AddNode(source);
        }
        if (!adjacencyList.ContainsKey(destination))
        {
            AddNode(destination);
        }

        adjacencyList[source].Add(destination);
    }

    // Display the graph
    public void Display()
    {
        foreach (var node in adjacencyList)
        {
            Console.Write($"{node.Key} -> ");
            Console.WriteLine(string.Join(", ", node.Value));
        }
    }
}
```

### Example Usage: Task Dependencies

```csharp
class Program
{
    static void Main(string[] args)
    {
        var taskGraph = new DirectedGraph();

        // Add tasks
        taskGraph.AddNode("Task 1");
        taskGraph.AddNode("Task 2");
        taskGraph.AddNode("Task 3");

        // Define task dependencies
        taskGraph.AddEdge("Task 1", "Task 2");
        taskGraph.AddEdge("Task 2", "Task 3");

        Console.WriteLine("Project Task Flow (Directed Graph):");
        taskGraph.Display();
    }
}
```

**Output:**
```
Task 1 -> Task 2
Task 2 -> Task 3
Task 3 -> 
```

## Undirected Graphs

### Definition

An **undirected graph** is a graph where edges have no specific direction, representing mutual or bidirectional relationships between nodes. Undirected graphs are perfect for equal relationships or those without a set order, like friendships or shared interests.

### Use Case: Friendship Network

Consider a friendship network:
- If Person 1 is friends with Person 2
- Then Person 2 is also friends with Person 1

This relationship is mutual and bidirectional. An undirected graph represents this scenario perfectly with each connection equal in both directions.

### C# Implementation

```csharp
public class UndirectedGraph
{
    private Dictionary<string, List<string>> adjacencyList;

    public UndirectedGraph()
    {
        adjacencyList = new Dictionary<string, List<string>>();
    }

    // Add a node to the graph
    public void AddNode(string node)
    {
        if (!adjacencyList.ContainsKey(node))
        {
            adjacencyList[node] = new List<string>();
        }
    }

    // Add an undirected edge between two nodes
    public void AddEdge(string node1, string node2)
    {
        if (!adjacencyList.ContainsKey(node1))
        {
            AddNode(node1);
        }
        if (!adjacencyList.ContainsKey(node2))
        {
            AddNode(node2);
        }

        // Add edge in both directions
        adjacencyList[node1].Add(node2);
        adjacencyList[node2].Add(node1);
    }

    // Display the graph
    public void Display()
    {
        foreach (var node in adjacencyList)
        {
            Console.Write($"{node.Key} <-> ");
            Console.WriteLine(string.Join(", ", node.Value));
        }
    }
}
```

### Example Usage: Friendship Network

```csharp
class Program
{
    static void Main(string[] args)
    {
        var friendshipGraph = new UndirectedGraph();

        // Add people
        friendshipGraph.AddNode("Person 1");
        friendshipGraph.AddNode("Person 2");
        friendshipGraph.AddNode("Person 3");

        // Define friendships (bidirectional)
        friendshipGraph.AddEdge("Person 1", "Person 2");
        friendshipGraph.AddEdge("Person 2", "Person 3");
        friendshipGraph.AddEdge("Person 1", "Person 3");

        Console.WriteLine("Friendship Network (Undirected Graph):");
        friendshipGraph.Display();
    }
}
```

**Output:**
```
Person 1 <-> Person 2, Person 3
Person 2 <-> Person 1, Person 3
Person 3 <-> Person 2, Person 1
```

## Real-World Application: Social Media Platform

Both graph types can be used together to model complex systems. Consider a social media platform:

### Mixed Graph Implementation

```csharp
public class SocialMediaPlatform
{
    private UndirectedGraph friendships;    // Facebook-style mutual friendships
    private DirectedGraph followings;        // Twitter/X-style one-way follows

    public SocialMediaPlatform()
    {
        friendships = new UndirectedGraph();
        followings = new DirectedGraph();
    }

    // Add a mutual friendship (bidirectional)
    public void AddFriendship(string user1, string user2)
    {
        friendships.AddEdge(user1, user2);
        Console.WriteLine($"{user1} and {user2} are now friends!");
    }

    // Add a follow relationship (unidirectional)
    public void AddFollower(string follower, string followee)
    {
        followings.AddEdge(follower, followee);
        Console.WriteLine($"{follower} is now following {followee}");
    }

    // Display all connections
    public void DisplayAllConnections()
    {
        Console.WriteLine("\n=== Mutual Friendships (Undirected) ===");
        friendships.Display();

        Console.WriteLine("\n=== Follow Relationships (Directed) ===");
        followings.Display();
    }
}
```

### Example Usage: Social Network

```csharp
class Program
{
    static void Main(string[] args)
    {
        var platform = new SocialMediaPlatform();

        // Facebook-style mutual friendships
        platform.AddFriendship("Alice", "Bob");
        platform.AddFriendship("Bob", "Charlie");

        // Twitter/X-style one-way follows
        platform.AddFollower("Alice", "Celebrity");
        platform.AddFollower("Bob", "Celebrity");
        platform.AddFollower("Charlie", "Celebrity");

        // Display all connections
        platform.DisplayAllConnections();
    }
}
```

**Output:**
```
Alice and Bob are now friends!
Bob and Charlie are now friends!
Alice is now following Celebrity
Bob is now following Celebrity
Charlie is now following Celebrity

=== Mutual Friendships (Undirected) ===
Alice <-> Bob
Bob <-> Alice, Charlie
Charlie <-> Bob

=== Follow Relationships (Directed) ===
Alice -> Celebrity
Bob -> Celebrity
Charlie -> Celebrity
Celebrity -> 
```

## Key Differences Summary

| Aspect                | Directed Graph                          | Undirected Graph                 |
| --------------------- | --------------------------------------- | -------------------------------- |
| **Edge Direction**    | One-way (A → B)                         | Two-way (A ↔ B)                  |
| **Relationship Type** | Hierarchical, sequential                | Mutual, equal                    |
| **Use Cases**         | Task dependencies, web links, following | Friendships, roads, partnerships |
| **Implementation**    | Add edge in one direction               | Add edge in both directions      |
| **Examples**          | Project workflow, food chains           | Social networks, collaboration   |

## When to Use Each Type

**Use Directed Graphs when:**
- Relationships have a clear direction or flow
- Order matters (task dependencies, prerequisites)
- One-way relationships exist (following, citations)

**Use Undirected Graphs when:**
- Relationships are mutual or bidirectional
- Order doesn't matter (friendships, partnerships)
- Equal connections exist (roads, collaborations)

## Conclusion

Understanding when to use directed and undirected graphs helps us organize information clearly and logically. By combining both types, you can effectively model complex relationships in real-world systems like social networks, project management tools, and recommendation engines.