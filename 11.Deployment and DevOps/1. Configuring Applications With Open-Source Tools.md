# Application Deployment Preparation Guide

## Overview
Building a successful application involves more than writing great code. It's also about preparing it to run securely and efficiently in different environments. By learning to configure, manage, and build your app, you set the stage for reliable and seamless deployments.

This guide explains how to prepare your applications for deployment using Visual Studio Code and Open Source tools.

---

## Key Tasks for Application Deployment

### 1. Managing Environment Variables

**Environment variables** are key-value pairs used by an operating system to store configuration settings that applications and processes can access. They help manage system-wide or application-specific settings without hard-coding values into the code.

`.env` files are commonly used in development to manage environment variables. However, different systems and platforms handle them in various ways.

#### Steps to Configure Environment Variables:

1. Navigate to your project's directory in the Visual Studio Code terminal
2. Install the required library by running `dotnet add package DotNetEnv`
3. Create a `.env` file in your project folder using Visual Studio Code
4. Inside the `.env` file, add variables such as `API_KEY=12345secure`
5. In your `Program.cs` file, use the `Env.Load()` method to load the environment variables from the `.env` file

**Benefits:**
- Separates sensitive data from source code
- Reduces risk of exposing credentials in repositories or logs
- Allows for environment-specific configurations without modifying code
- Ensures flexibility across development, testing, and production setups

---

### 2. Managing Dependencies

**Dependencies** are pre-built libraries that add functionality to your app, such as handling JSON data.

**Dependency management** is the process of adding, updating, and maintaining extra libraries and packages, often using tools like NuGet.

#### Steps to Manage Dependencies:

1. Open VSCode and use its terminal to install needed dependencies
2. Run `dotnet add package Newtonsoft.Json` to add a package
3. To ensure all dependencies are up to date, run `dotnet restore`

This approach ensures compatibility and functionality in your application.

---

### 3. Configuring the Build

A **build configuration** is a set of predefined settings and rules that dictate how a software project is compiled, packaged, and deployed. It defines aspects such as:
- Target environment
- Optimization level
- Dependencies
- Build scripts

#### Steps to Configure Build:

1. In the VSCode terminal, run `dotnet build` to generate the compiled files in your `project/bin` folder
2. After the build completes, check the terminal output for any errors or warnings
3. If successful, find the executable files in the `/bin/Debug/netx.x` directory (where x.x represents the .NET version)

The `bin` folder contains:
- Compiled binaries
- Dependencies
- Necessary files for running the application

These files allow you to test the applications locally before deployment.

---

## Conclusion

Getting your application deployment-ready is about building a secure, efficient, and reliable foundation for any environment. By mastering environment variable management, dependency configuration, and build processes, you ensure your applications are prepared for successful deployment.

---

# Code Examples

## Beginner Level

### 1. Basic Environment Variable Configuration

**.env file:**
```
API_KEY=12345secure
DATABASE_URL=localhost:5432
APP_NAME=MyApplication
```

**Program.cs:**
```csharp
using DotNetEnv;
using System;

class Program
{
    static void Main(string[] args)
    {
        // Load environment variables from .env file
        Env.Load();
        
        // Access environment variables
        string apiKey = Environment.GetEnvironmentVariable("API_KEY");
        string dbUrl = Environment.GetEnvironmentVariable("DATABASE_URL");
        
        Console.WriteLine($"API Key: {apiKey}");
        Console.WriteLine($"Database URL: {dbUrl}");
    }
}
```

### 2. Installing and Using Dependencies

**Terminal commands:**
```bash
# Add Newtonsoft.Json package
dotnet add package Newtonsoft.Json

# Restore all dependencies
dotnet restore
```

**Using the dependency:**
```csharp
using Newtonsoft.Json;
using System;

class Program
{
    static void Main(string[] args)
    {
        var product = new { Name = "Laptop", Price = 999.99 };
        
        // Serialize object to JSON
        string json = JsonConvert.SerializeObject(product);
        Console.WriteLine(json);
    }
}
```

### 3. Basic Build Configuration

**Terminal commands:**
```bash
# Build the project
dotnet build

# Run the built application
dotnet run
```

---

## Intermediate Level

### 1. Environment-Specific Configuration

**.env.development:**
```
ASPNETCORE_ENVIRONMENT=Development
API_KEY=dev-key-12345
DATABASE_URL=localhost:5432
LOG_LEVEL=Debug
ENABLE_SWAGGER=true
```

**.env.production:**
```
ASPNETCORE_ENVIRONMENT=Production
API_KEY=prod-key-67890
DATABASE_URL=prod-server:5432
LOG_LEVEL=Warning
ENABLE_SWAGGER=false
```

**Program.cs with configuration validation:**
```csharp
using DotNetEnv;
using System;

class Program
{
    static void Main(string[] args)
    {
        // Determine environment
        string environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") 
                           ?? "Development";
        
        // Load appropriate .env file
        string envFile = $".env.{environment.ToLower()}";
        
        if (File.Exists(envFile))
        {
            Env.Load(envFile);
            Console.WriteLine($"Loaded configuration for: {environment}");
        }
        else
        {
            Console.WriteLine($"Warning: {envFile} not found, using default configuration");
        }
        
        // Validate required variables
        ValidateEnvironmentVariable("API_KEY");
        ValidateEnvironmentVariable("DATABASE_URL");
        
        // Use configuration
        RunApplication();
    }
    
    static void ValidateEnvironmentVariable(string key)
    {
        string value = Environment.GetEnvironmentVariable(key);
        if (string.IsNullOrEmpty(value))
        {
            throw new InvalidOperationException($"Required environment variable '{key}' is not set");
        }
    }
    
    static void RunApplication()
    {
        string apiKey = Environment.GetEnvironmentVariable("API_KEY");
        Console.WriteLine($"Application started with API Key: {apiKey.Substring(0, 5)}...");
    }
}
```

### 2. Advanced Dependency Management

**Creating a custom NuGet.config:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
    <add key="myget" value="https://www.myget.org/F/myfeed/api/v3/index.json" />
  </packageSources>
</configuration>
```

**Project file (.csproj) with version management:**
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="Serilog" Version="3.1.1" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
    <PackageReference Include="DotNetEnv" Version="2.5.0" />
  </ItemGroup>
</Project>
```

### 3. Build Configuration with Multiple Targets

**Terminal commands:**
```bash
# Build for Debug configuration
dotnet build --configuration Debug

# Build for Release configuration
dotnet build --configuration Release

# Build for specific runtime
dotnet build --runtime win-x64

# Publish self-contained application
dotnet publish --configuration Release --self-contained true --runtime win-x64
```

**Custom build script (build.sh):**
```bash
#!/bin/bash

echo "Starting build process..."

# Clean previous builds
dotnet clean

# Restore dependencies
dotnet restore

# Build Debug
echo "Building Debug configuration..."
dotnet build --configuration Debug

# Build Release
echo "Building Release configuration..."
dotnet build --configuration Release

# Run tests
echo "Running tests..."
dotnet test

echo "Build completed successfully!"
```

---

## Senior Level

### 1. Advanced Environment Configuration with Configuration Builder

**appsettings.json:**
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": ""
  },
  "ApiSettings": {
    "BaseUrl": "",
    "Timeout": 30,
    "RetryPolicy": {
      "MaxRetries": 3,
      "BackoffMultiplier": 2
    }
  }
}
```

**Configuration service implementation:**
```csharp
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using DotNetEnv;
using System;
using System.IO;

public class Program
{
    public static void Main(string[] args)
    {
        // Load .env file
        Env.Load();
        
        var host = CreateHostBuilder(args).Build();
        
        // Validate configuration
        var config = host.Services.GetRequiredService<IConfiguration>();
        ValidateConfiguration(config);
        
        host.Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((context, config) =>
            {
                var env = context.HostingEnvironment;
                
                config
                    .SetBasePath(Directory.GetCurrentDirectory())
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true, reloadOnChange: true)
                    .AddEnvironmentVariables()
                    .AddCommandLine(args);
            })
            .ConfigureServices((context, services) =>
            {
                // Bind configuration to strongly-typed objects
                services.Configure<ApiSettings>(context.Configuration.GetSection("ApiSettings"));
                services.AddSingleton<IConfigurationService, ConfigurationService>();
            });

    private static void ValidateConfiguration(IConfiguration config)
    {
        var requiredSettings = new[] 
        { 
            "ConnectionStrings:DefaultConnection",
            "ApiSettings:BaseUrl"
        };

        foreach (var setting in requiredSettings)
        {
            var value = config[setting];
            if (string.IsNullOrEmpty(value))
            {
                throw new InvalidOperationException(
                    $"Required configuration '{setting}' is missing");
            }
        }
    }
}

// Strongly-typed configuration
public class ApiSettings
{
    public string BaseUrl { get; set; }
    public int Timeout { get; set; }
    public RetryPolicySettings RetryPolicy { get; set; }
}

public class RetryPolicySettings
{
    public int MaxRetries { get; set; }
    public int BackoffMultiplier { get; set; }
}

public interface IConfigurationService
{
    T GetSetting<T>(string key);
    void ReloadConfiguration();
}

public class ConfigurationService : IConfigurationService
{
    private readonly IConfiguration _configuration;
    
    public ConfigurationService(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    
    public T GetSetting<T>(string key)
    {
        return _configuration.GetValue<T>(key);
    }
    
    public void ReloadConfiguration()
    {
        if (_configuration is IConfigurationRoot root)
        {
            root.Reload();
        }
    }
}
```

### 2. Advanced Dependency Management with Central Package Management

**Directory.Packages.props:**
```xml
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageVersion Include="Serilog" Version="3.1.1" />
    <PackageVersion Include="Serilog.Sinks.Console" Version="5.0.1" />
    <PackageVersion Include="AutoMapper" Version="12.0.1" />
    <PackageVersion Include="FluentValidation" Version="11.8.0" />
  </ItemGroup>
</Project>
```

**Project file without version numbers:**
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Newtonsoft.Json" />
    <PackageReference Include="Serilog" />
  </ItemGroup>
</Project>
```

### 3. Advanced Build Pipeline with CI/CD Integration

**azure-pipelines.yml:**
```yaml
trigger:
  branches:
    include:
      - main
      - develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  dotnetVersion: '8.0.x'

stages:
- stage: Build
  jobs:
  - job: BuildJob
    steps:
    - task: UseDotNet@2
      inputs:
        version: $(dotnetVersion)
        
    - task: DotNetCoreCLI@2
      displayName: 'Restore dependencies'
      inputs:
        command: 'restore'
        
    - task: DotNetCoreCLI@2
      displayName: 'Build solution'
      inputs:
        command: 'build'
        arguments: '--configuration $(buildConfiguration) --no-restore'
        
    - task: DotNetCoreCLI@2
      displayName: 'Run tests'
      inputs:
        command: 'test'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage"'
        
    - task: DotNetCoreCLI@2
      displayName: 'Publish application'
      inputs:
        command: 'publish'
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'
        publishWebProjects: false
        
    - task: PublishBuildArtifacts@1
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'drop'
```

**Custom MSBuild targets file (Directory.Build.targets):**
```xml
<Project>
  <Target Name="PreBuild" BeforeTargets="PreBuildEvent">
    <Message Text="Running pre-build validation..." Importance="high" />
    <Exec Command="dotnet format --verify-no-changes" />
  </Target>

  <Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <Message Text="Running post-build tasks..." Importance="high" />
    <Exec Command="dotnet test --no-build --logger trx" />
  </Target>

  <PropertyGroup>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <CodeAnalysisRuleSet>$(MSBuildThisFileDirectory)analyzers.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
</Project>
```

**Dockerfile for containerized deployment:**
```dockerfile
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copy csproj and restore dependencies
COPY ["MyApp/MyApp.csproj", "MyApp/"]
RUN dotnet restore "MyApp/MyApp.csproj"

# Copy everything else and build
COPY . .
WORKDIR "/src/MyApp"
RUN dotnet build "MyApp.csproj" -c Release -o /app/build

# Publish stage
FROM build AS publish
RUN dotnet publish "MyApp.csproj" -c Release -o /app/publish /p:UseAppHost=false

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app
COPY --from=publish /app/publish .

# Set environment variables
ENV ASPNETCORE_URLS=http://+:80
ENV ASPNETCORE_ENVIRONMENT=Production

EXPOSE 80
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

**Advanced build script (build.ps1):**
```powershell
param(
    [string]$Configuration = "Release",
    [string]$Runtime = "win-x64",
    [switch]$SelfContained,
    [switch]$RunTests,
    [switch]$CreatePackage
)

Write-Host "Starting advanced build process..." -ForegroundColor Green

# Clean
Write-Host "Cleaning previous builds..." -ForegroundColor Yellow
dotnet clean --configuration $Configuration

# Restore
Write-Host "Restoring dependencies..." -ForegroundColor Yellow
dotnet restore

# Build
Write-Host "Building solution..." -ForegroundColor Yellow
$buildArgs = @(
    "build",
    "--configuration", $Configuration,
    "--no-restore",
    "/p:TreatWarningsAsErrors=true"
)
dotnet @buildArgs

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed!"
    exit 1
}

# Run tests
if ($RunTests) {
    Write-Host "Running tests..." -ForegroundColor Yellow
    dotnet test --configuration $Configuration --no-build --collect:"XPlat Code Coverage"
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Tests failed!"
        exit 1
    }
}

# Publish
Write-Host "Publishing application..." -ForegroundColor Yellow
$publishArgs = @(
    "publish",
    "--configuration", $Configuration,
    "--runtime", $Runtime,
    "--output", "./publish"
)

if ($SelfContained) {
    $publishArgs += "--self-contained", "true"
    $publishArgs += "/p:PublishSingleFile=true"
    $publishArgs += "/p:IncludeNativeLibrariesForSelfExtract=true"
}

dotnet @publishArgs

# Create package
if ($CreatePackage) {
    Write-Host "Creating deployment package..." -ForegroundColor Yellow
    $packageName = "MyApp-$Configuration-$(Get-Date -Format 'yyyyMMdd-HHmmss').zip"
    Compress-Archive -Path "./publish/*" -DestinationPath $packageName
    Write-Host "Package created: $packageName" -ForegroundColor Green
}

Write-Host "Build process completed successfully!" -ForegroundColor Green
```

These examples demonstrate production-ready practices for configuration management, dependency handling, and build automation at a senior level.