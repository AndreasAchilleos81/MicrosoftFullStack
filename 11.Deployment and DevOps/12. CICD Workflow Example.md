# Configuring and Running a Basic CI/CD Pipeline Workflow

## Overview

Using **Continuous Integration and Continuous Deployment (CI/CD)** workflows can help ensure that your code is kept secure, that you're creating regular versions of all the code you're writing, and can help you integrate code from various developers as well as distribute and deploy your code to your users as it changes.

This guide explains how to configure and run a basic CI/CD pipeline workflow using Git, GitHub, and Azure workflows.

---

## Prerequisites

Before starting, ensure you have the following installed:

- **Git Command Line Interface (CLI)** - for version control commands
- **GitHub CLI (gh)** - for GitHub repository operations
- **Visual Studio Code** or any terminal/PowerShell window
- A GitHub account

You can run these commands from Visual Studio Code's integrated terminal, a regular terminal window, or PowerShell on Windows.

---

## Step 1: Initialize a Local Git Repository

Create a Git repository for your application using the `git init` command.

```bash
# Navigate to your project directory
cd /path/to/your/project

# Initialize a new Git repository
git init
```

This command creates a local Git repository in your project folder.

---

## Step 2: Add Files to the Repository

Add all the files in your project to the Git repository staging area.

```bash
# Add all files in the current directory to staging
git add .
```

The `.` tells Git that you want to add everything in the project to the repository. If the command returns nothing, it means it worked successfully.

---

## Step 3: Commit Files to the Repository

Commit the staged files to your local repository with a descriptive message.

```bash
# Commit the staged files with a message
git commit -m "Initial commit"
```

The `commit` command actually puts the files into the repository. The `add` command just stages them—it tells Git which files you want to commit.

---

## Step 4: Create and Push to GitHub Repository

Use the GitHub CLI to create a remote repository and push your local code to GitHub.

```bash
# Create a GitHub repository and push local files
gh repo create HelloCICD --private --source=. --push
```

**Command breakdown:**
- `gh repo create` - Creates a new GitHub repository
- `HelloCICD` - The name of the GitHub repository
- `--private` - Creates a private repository (use `--public` for public repositories)
- `--source=.` - Specifies the source as everything in your local Git repository (current directory)
- `--push` - Pushes everything to the remote repository when the command runs

**Expected output:**
```
✓ Created repository YourUsername/HelloCICD on GitHub
✓ Added remote https://github.com/YourUsername/HelloCICD.git
Enumerating objects: 30, done.
Counting objects: 100% (30/30), done.
Compressing objects: 100% (25/25), done.
Writing objects: 100% (30/30), done.
Total 30 (delta 5), reused 0 (delta 0)
✓ Pushed commits to https://github.com/YourUsername/HelloCICD.git
```

---

## Step 5: Verify Repository on GitHub

Navigate to your GitHub account in a web browser to verify the repository was created successfully.

```
https://github.com/YourUsername/HelloCICD
```

All the files from your local folder should now be visible in your GitHub repository. You can continue to interact with this repository and ensure all your files are stored securely. Every version you create can be pushed to GitHub for safe storage.

---

## Step 6: Create the CI/CD Pipeline Structure

Create the necessary folder structure for GitHub Actions workflows.

```bash
# Create the .github/workflows directory
mkdir -p .github/workflows

# Navigate to the workflows directory
cd .github/workflows
```

**Important:** This folder structure must be exactly `.github/workflows` for GitHub Actions to recognize your workflow files.

---

## Step 7: Create the Workflow YAML File

Create a YAML file to define your CI/CD pipeline. This file uses a specific format with key-value pairs.

```bash
# Create the workflow file
touch dotnet.yml
```

Now edit the `dotnet.yml` file with the following content:

```yaml
# Workflow name
name: .NET Build and Deploy

# Define triggers - when should this workflow run?
on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

# Define the jobs to run
jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    # Checkout the repository code
    - name: Checkout code
      uses: actions/checkout@v3
    
    # Setup .NET environment
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '6.0.x'
    
    # Restore dependencies
    - name: Restore dependencies
      run: dotnet restore
    
    # Build the application
    - name: Build
      run: dotnet build --configuration Release --no-restore
    
    # Run tests
    - name: Test
      run: dotnet test --no-build --verbosity normal
    
    # Publish the application
    - name: Publish
      run: dotnet publish --configuration Release --output ./publish
    
    # Upload artifacts
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: dotnet-app
        path: ./publish

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    
    steps:
    # Download artifacts from build job
    - name: Download artifacts
      uses: actions/download-artifact@v3
      with:
        name: dotnet-app
        path: ./publish
    
    # Deploy to Azure Web App (example)
    - name: Deploy to Azure
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'your-app-name'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ./publish
```

---

## Workflow File Explanation

### Key Components:

**1. Name:**
```yaml
name: .NET Build and Deploy
```
Gives the workflow a descriptive name.

**2. Triggers:**
```yaml
on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
```
Defines when the workflow runs. This workflow triggers on:
- Every `push` to the `master` branch
- Every `pull_request` targeting the `master` branch

**3. Jobs:**
The workflow contains two jobs: `build` and `deploy`

**4. Build Job Steps:**
- Checkout code from repository
- Setup .NET environment
- Restore dependencies
- Build the application
- Run automated tests
- Publish the application
- Upload build artifacts

**5. Deploy Job:**
- Runs only after successful build
- Downloads build artifacts
- Deploys to Azure Web App

---

## Step 8: Commit and Push the Workflow File

Add the workflow file to your repository and push it to GitHub.

```bash
# Add the workflow file
git add .github/workflows/dotnet.yml

# Commit the workflow file
git commit -m "Add CI/CD workflow"

# Push to GitHub
git push origin master
```

---

## Step 9: Monitor Workflow Execution

Once pushed, GitHub Actions will automatically detect and run your workflow.

**To view workflow runs:**

1. Navigate to your GitHub repository
2. Click on the **Actions** tab
3. You'll see your workflow runs listed with their status

**Using GitHub CLI:**
```bash
# View workflow runs
gh run list

# View details of a specific run
gh run view <run-id>

# Watch a workflow run in real-time
gh run watch
```

---

## Step 10: Configure Azure Deployment Secrets

To deploy to Azure, you need to add your Azure credentials to GitHub Secrets.

```bash
# Login to Azure
az login

# Get publish profile for your Azure Web App
az webapp deployment list-publishing-profiles \
  --name your-app-name \
  --resource-group your-resource-group \
  --xml
```

**Add the secret to GitHub:**

1. Go to your GitHub repository
2. Navigate to **Settings** → **Secrets and variables** → **Actions**
3. Click **New repository secret**
4. Name: `AZURE_WEBAPP_PUBLISH_PROFILE`
5. Value: Paste the XML output from the Azure CLI command
6. Click **Add secret**

---

## Complete Example Workflow for Azure

Here's a complete workflow file for a .NET application deploying to Azure:

```yaml
name: Build and Deploy to Azure

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

env:
  AZURE_WEBAPP_NAME: your-app-name
  DOTNET_VERSION: '6.0.x'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --configuration Release --no-restore
    
    - name: Test
      run: dotnet test --configuration Release --no-build --logger trx
    
    - name: Publish
      run: dotnet publish --configuration Release --output ${{github.workspace}}/myapp
    
    - name: Upload artifact for deployment
      uses: actions/upload-artifact@v3
      with:
        name: .net-app
        path: ${{github.workspace}}/myapp

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
    - name: Download artifact
      uses: actions/download-artifact@v3
      with:
        name: .net-app
    
    - name: Deploy to Azure Web App
      id: deploy-to-webapp
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: .
```

---

## Summary

You have now configured a complete CI/CD pipeline that:

1. **Tracks code changes** using Git and GitHub
2. **Automatically builds** your application on every push
3. **Runs automated tests** to ensure code quality
4. **Deploys to Azure** when tests pass
5. **Maintains version history** for rollback capabilities

Every time you push code to the `master` branch or create a pull request, this workflow automatically runs, ensuring your code is built, tested, and deployed consistently and reliably.