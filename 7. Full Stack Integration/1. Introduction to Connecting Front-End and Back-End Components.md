# Connecting Front End and Back End Components with C# and Blazor

**An essential part of the full stack integration course using C#, Blazor, and ASP.NET Core.**

In this module, you'll learn how to connect the pieces of a full stack C# application from setting up a development environment to integrating Blazor front end components with ASP.NET Core back end services. You'll explore building and consuming RESTful APIs using C# and .NET technologies, while applying real world scenarios to solidify your skills. Get ready to bridge the gap and create seamless full stack solutions using the .NET ecosystem.

## Course Overview

### 1. Full Stack Architecture Fundamentals with .NET

We will begin by exploring the architecture of full stack development using C# and understanding the critical role it plays in creating modern applications. We'll break down how Blazor components, ASP.NET Core APIs, and Entity Framework work together, and why mastering this architecture is essential for building cohesive and user friendly applications.

This foundational knowledge will help you see the big picture of .NET full stack workflows and prepare you for the technical details ahead.

**Example Architecture:**
```csharp
// Blazor Client-side (Frontend)
@inject HttpClient Http
@using System.Net.Http.Json

private async Task<User> GetUserDataAsync(int userId)
{
    var user = await Http.GetFromJsonAsync<User>($"api/users/{userId}");
    return user;
}

// ASP.NET Core Controller (Backend)
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;

    public UsersController(IUserService userService)
    {
        _userService = userService;
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(int id)
    {
        var user = await _userService.GetUserByIdAsync(id);
        if (user == null)
            return NotFound();
        
        return Ok(user);
    }
}
```

### 2. Development Environment Setup for .NET Full Stack

Next, we will examine the steps for setting up a robust .NET full stack development environment. You will learn how to configure essential tools, manage NuGet packages, and structure your solution to ensure a smooth workflow.

This lesson highlights why a properly configured .NET environment is crucial for minimizing errors and maximizing productivity as you build full stack applications.

**Example Solution Structure:**
```xml
<!-- Server project (.csproj) -->
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Shared\MyApp.Shared.csproj" />
  </ItemGroup>
</Project>

<!-- Blazor Client project (.csproj) -->
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="8.0.0" />
    <PackageReference Include="System.Net.Http.Json" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Shared\MyApp.Shared.csproj" />
  </ItemGroup>
</Project>
```

### 3. Building RESTful APIs with ASP.NET Core

Then we will build an understanding of how to create RESTful APIs using ASP.NET Core that enable seamless communication between Blazor front end and back end components. We'll focus on designing efficient, secure and scalable APIs using C# features like dependency injection, middleware, and Entity Framework.

This knowledge will give you the skills needed to connect your Blazor frontend and ASP.NET Core backend systems effectively.

**Example RESTful API with Entity Framework:**
```csharp
// Data Model (Shared project)
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public string Description { get; set; } = string.Empty;
}

// DbContext
public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
    
    public DbSet<Product> Products { get; set; }
}

// Products Controller
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly AppDbContext _context;

    public ProductsController(AppDbContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> GetProducts()
    {
        return await _context.Products.ToListAsync();
    }

    [HttpPost]
    public async Task<ActionResult<Product>> CreateProduct(Product product)
    {
        _context.Products.Add(product);
        await _context.SaveChangesAsync();
        
        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<Product>> GetProduct(int id)
    {
        var product = await _context.Products.FindAsync(id);
        if (product == null)
            return NotFound();
            
        return product;
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateProduct(int id, Product product)
    {
        if (id != product.Id)
            return BadRequest();

        _context.Entry(product).State = EntityState.Modified;
        await _context.SaveChangesAsync();
        
        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteProduct(int id)
    {
        var product = await _context.Products.FindAsync(id);
        if (product == null)
            return NotFound();

        _context.Products.Remove(product);
        await _context.SaveChangesAsync();
        
        return NoContent();
    }
}
```

### 4. Blazor Frontend API Integration

After understanding how to create APIs with ASP.NET Core, we'll turn our attention to integrating them into Blazor applications. This lesson will guide you through making HTTP calls using HttpClient, handling responses with proper error management, and displaying data dynamically using Blazor components.

By mastering these processes, you'll learn to build Blazor applications that provide users with real time data driven functionality.

**Example Blazor Component with API Integration:**
```csharp
@page "/products"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@using System.Net.Http.Json

<PageTitle>Products</PageTitle>

<h3>Product Management</h3>

@if (loading)
{
    <p><em>Loading products...</em></p>
}
else
{
    <div class="mb-3">
        <button class="btn btn-primary" @onclick="ShowAddProductForm">Add New Product</button>
    </div>

    @if (showAddForm)
    {
        <div class="card mb-3">
            <div class="card-body">
                <h5 class="card-title">Add New Product</h5>
                <EditForm Model="newProduct" OnValidSubmit="HandleValidSubmit">
                    <DataAnnotationsValidator />
                    <ValidationSummary />
                    
                    <div class="mb-3">
                        <label for="name" class="form-label">Name</label>
                        <InputText id="name" class="form-control" @bind-Value="newProduct.Name" />
                    </div>
                    
                    <div class="mb-3">
                        <label for="price" class="form-label">Price</label>
                        <InputNumber id="price" class="form-control" @bind-Value="newProduct.Price" />
                    </div>
                    
                    <div class="mb-3">
                        <label for="description" class="form-label">Description</label>
                        <InputTextArea id="description" class="form-control" @bind-Value="newProduct.Description" />
                    </div>
                    
                    <button type="submit" class="btn btn-success">Save Product</button>
                    <button type="button" class="btn btn-secondary" @onclick="CancelAdd">Cancel</button>
                </EditForm>
            </div>
        </div>
    }

    <div class="row">
        @foreach (var product in products)
        {
            <div class="col-md-4 mb-3">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">@product.Name</h5>
                        <p class="card-text">@product.Description</p>
                        <p class="card-text"><strong>$@product.Price</strong></p>
                        <button class="btn btn-danger btn-sm" @onclick="() => DeleteProduct(product.Id)">
                            Delete
                        </button>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    private List<Product> products = new();
    private Product newProduct = new();
    private bool loading = true;
    private bool showAddForm = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadProducts();
    }

    private async Task LoadProducts()
    {
        try
        {
            loading = true;
            products = await Http.GetFromJsonAsync<List<Product>>("api/products") ?? new();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error loading products: {ex.Message}");
        }
        finally
        {
            loading = false;
        }
    }

    private async Task HandleValidSubmit()
    {
        try
        {
            var response = await Http.PostAsJsonAsync("api/products", newProduct);
            if (response.IsSuccessStatusCode)
            {
                await LoadProducts();
                newProduct = new Product();
                showAddForm = false;
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error creating product: {ex.Message}");
        }
    }

    private async Task DeleteProduct(int productId)
    {
        try
        {
            var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this product?");
            if (confirmed)
            {
                var response = await Http.DeleteAsync($"api/products/{productId}");
                if (response.IsSuccessStatusCode)
                {
                    await LoadProducts();
                }
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error deleting product: {ex.Message}");
        }
    }

    private void ShowAddProductForm()
    {
        showAddForm = true;
        newProduct = new Product();
    }

    private void CancelAdd()
    {
        showAddForm = false;
        newProduct = new Product();
    }
}
```

### 5. Real-World Case Studies with .NET Technologies

Finally, we'll tie everything together by examining real world examples of full stack integration using C#, Blazor, and ASP.NET Core. From e-commerce platforms to business applications, we'll analyze how Blazor components and ASP.NET Core APIs are seamlessly combined to deliver exceptional user experiences.

These case studies will inspire you to apply your .NET skills in practical, impactful ways.

**Example: E-commerce Shopping Cart with SignalR Integration**
```csharp
// SignalR Hub for real-time updates
public class CartHub : Hub
{
    public async Task JoinGroup(string userId)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, $"user_{userId}");
    }
}

// Cart Service
public interface ICartService
{
    Task<Cart> GetCartAsync(string userId);
    Task<Cart> AddToCartAsync(string userId, int productId, int quantity);
    Task<Cart> RemoveFromCartAsync(string userId, int productId);
}

public class CartService : ICartService
{
    private readonly AppDbContext _context;
    private readonly IHubContext<CartHub> _hubContext;

    public CartService(AppDbContext context, IHubContext<CartHub> hubContext)
    {
        _context = context;
        _hubContext = hubContext;
    }

    public async Task<Cart> AddToCartAsync(string userId, int productId, int quantity)
    {
        var cart = await GetCartAsync(userId);
        var existingItem = cart.Items.FirstOrDefault(i => i.ProductId == productId);

        if (existingItem != null)
        {
            existingItem.Quantity += quantity;
        }
        else
        {
            cart.Items.Add(new CartItem
            {
                ProductId = productId,
                Quantity = quantity,
                CartId = cart.Id
            });
        }

        await _context.SaveChangesAsync();
        
        // Notify client of cart update via SignalR
        await _hubContext.Clients.Group($"user_{userId}")
            .SendAsync("CartUpdated", cart);

        return cart;
    }
}

// Cart Controller
[ApiController]
[Route("api/[controller]")]
public class CartController : ControllerBase
{
    private readonly ICartService _cartService;

    public CartController(ICartService cartService)
    {
        _cartService = cartService;
    }

    [HttpPost("add")]
    public async Task<ActionResult<Cart>> AddToCart([FromBody] AddToCartRequest request)
    {
        try
        {
            var cart = await _cartService.AddToCartAsync(
                request.UserId, 
                request.ProductId, 
                request.Quantity);
            
            return Ok(cart);
        }
        catch (Exception ex)
        {
            return BadRequest($"Failed to add item to cart: {ex.Message}");
        }
    }
}

// Blazor Cart Component with SignalR
@page "/cart"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@using Microsoft.AspNetCore.SignalR.Client

<h3>Shopping Cart</h3>

@if (cart != null && cart.Items.Any())
{
    <div class="cart-items">
        @foreach (var item in cart.Items)
        {
            <div class="cart-item card mb-2">
                <div class="card-body d-flex justify-content-between align-items-center">
                    <div>
                        <h6>@item.Product.Name</h6>
                        <p>Quantity: @item.Quantity</p>
                        <p>Price: $@(item.Product.Price * item.Quantity)</p>
                    </div>
                    <button class="btn btn-danger btn-sm" 
                            @onclick="() => RemoveFromCart(item.ProductId)">
                        Remove
                    </button>
                </div>
            </div>
        }
    </div>
    
    <div class="cart-total mt-3">
        <h4>Total: $@cart.Items.Sum(i => i.Product.Price * i.Quantity)</h4>
        <button class="btn btn-primary">Proceed to Checkout</button>
    </div>
}
else
{
    <p>Your cart is empty.</p>
}

@code {
    private Cart? cart;
    private HubConnection? hubConnection;
    private string userId = "user123"; // In real app, get from authentication

    protected override async Task OnInitializedAsync()
    {
        // Initialize SignalR connection
        hubConnection = new HubConnectionBuilder()
            .WithUrl("/carthub")
            .Build();

        hubConnection.On<Cart>("CartUpdated", (updatedCart) =>
        {
            cart = updatedCart;
            InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
        await hubConnection.SendAsync("JoinGroup", userId);
        
        // Load initial cart data
        await LoadCart();
    }

    private async Task LoadCart()
    {
        try
        {
            cart = await Http.GetFromJsonAsync<Cart>($"api/cart/{userId}");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error loading cart: {ex.Message}");
        }
    }

    private async Task RemoveFromCart(int productId)
    {
        try
        {
            var response = await Http.DeleteAsync($"api/cart/{userId}/items/{productId}");
            if (!response.IsSuccessStatusCode)
            {
                await JSRuntime.InvokeVoidAsync("alert", "Failed to remove item from cart");
            }
            // Cart will be updated via SignalR
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error removing item: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}
```

**Program.cs Configuration:**
```csharp
// Program.cs for ASP.NET Core backend
var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddSignalR();
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
builder.Services.AddScoped<ICartService, CartService>();

// Add CORS for Blazor WebAssembly
builder.Services.AddCors(options =>
{
    options.AddPolicy("BlazorWasm", policy =>
        policy.WithOrigins("https://localhost:7001")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials());
});

var app = builder.Build();

// Configure pipeline
app.UseCors("BlazorWasm");
app.UseRouting();
app.MapControllers();
app.MapHub<CartHub>("/carthub");

app.Run();
```

## Conclusion

As we conclude this introduction to connecting front end and back end components using C#, Blazor, and ASP.NET Core, you can see how vital full stack integration is for creating modern, user friendly applications within the .NET ecosystem. By gaining an understanding of .NET full stack architecture, configuring your development environment with proper project references, building and integrating APIs using ASP.NET Core controllers, and analyzing real world examples with advanced features like SignalR, you'll gain the skills to seamlessly connect every layer of a .NET application.

Get ready to bridge the gap between Blazor frontend and ASP.NET Core backend systems as you take a big step towards becoming a competent .NET full stack developer. The power of C# across the entire stack provides type safety, performance, and developer productivity that makes building robust full stack applications both efficient and maintainable.