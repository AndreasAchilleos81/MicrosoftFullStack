# Full Stack Application Architectural Patterns with C# and .NET

**Understanding how web applications communicate and organize their parts with C#, Blazor, and ASP.NET Core**

How a web application communicates and organizes its parts determines how efficient, scalable, and user-friendly it can be. By understanding these foundational structures, developers create systems that are both powerful and maintainable. In this section, we'll describe different architectural patterns for full-stack applications using C# technologies such as MVC with ASP.NET Core and microservices with .NET.

## Common Architectural Patterns in Full-Stack .NET Applications

### 1. Monolithic Architecture

Let's begin by exploring monolithic architecture, a cohesive approach where all parts of an application—Blazor frontend, ASP.NET Core backend, and business logic—work together as a unified whole. This simplicity makes it an excellent starting point for understanding how .NET applications are structured.

Monolithic architecture programs are single codebase applications with tightly integrated frontend and backend components.

**Example: Monolithic To-Do List Application**
```csharp
// Single ASP.NET Core project with integrated Blazor Server
// Program.cs - Single application startup
var builder = WebApplication.CreateBuilder(args);

// Add services for the entire application
builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();
builder.Services.AddDbContext<TodoDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
builder.Services.AddScoped<ITodoService, TodoService>();

var app = builder.Build();

// Configure the HTTP request pipeline
app.UseRouting();
app.MapRazorPages();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

app.Run();

// Todo Service (Business Logic)
public class TodoService : ITodoService
{
    private readonly TodoDbContext _context;

    public TodoService(TodoDbContext context)
    {
        _context = context;
    }

    public async Task<List<TodoItem>> GetAllTodosAsync()
    {
        return await _context.TodoItems.ToListAsync();
    }

    public async Task<TodoItem> CreateTodoAsync(string title, string description)
    {
        var todo = new TodoItem
        {
            Title = title,
            Description = description,
            IsCompleted = false,
            CreatedDate = DateTime.Now
        };

        _context.TodoItems.Add(todo);
        await _context.SaveChangesAsync();
        return todo;
    }
}

// Blazor Component (UI Layer)
@page "/todos"
@inject ITodoService TodoService

<h3>Todo List</h3>

<div class="mb-3">
    <EditForm Model="newTodo" OnValidSubmit="CreateTodo">
        <div class="row">
            <div class="col-md-8">
                <InputText @bind-Value="newTodo.Title" class="form-control" placeholder="Enter todo title" />
            </div>
            <div class="col-md-4">
                <button type="submit" class="btn btn-primary">Add Todo</button>
            </div>
        </div>
    </EditForm>
</div>

@if (todos != null)
{
    @foreach (var todo in todos)
    {
        <div class="card mb-2">
            <div class="card-body">
                <h5 class="card-title">@todo.Title</h5>
                <p class="card-text">@todo.Description</p>
                <small class="text-muted">Created: @todo.CreatedDate.ToString("MMM dd, yyyy")</small>
            </div>
        </div>
    }
}

@code {
    private List<TodoItem> todos = new();
    private TodoItem newTodo = new();

    protected override async Task OnInitializedAsync()
    {
        todos = await TodoService.GetAllTodosAsync();
    }

    private async Task CreateTodo()
    {
        if (!string.IsNullOrWhiteSpace(newTodo.Title))
        {
            await TodoService.CreateTodoAsync(newTodo.Title, newTodo.Description);
            todos = await TodoService.GetAllTodosAsync();
            newTodo = new TodoItem();
        }
    }
}
```

Imagine a to-do list app where everything—tasks, UI, and logic—work as a single unit. Each part of the application is tightly integrated with the others, and the application needs to be tested and deployed as a single entity. This approach is great for small projects, but becomes harder to manage as the app grows. For example, when using a monolithic architecture, it's difficult to update one part of the application, like the Blazor frontend, without fully testing and deploying the entire ASP.NET Core application.

### 2. Client-Server Architecture

While monolithic architecture emphasizes a tightly integrated approach, the client-server model focuses on separating the Blazor frontend and the ASP.NET Core backend into distinct roles. A client-server architecture enables communication between a Blazor WebAssembly client and an ASP.NET Core Web API server. This separation forms the basic structure of how most modern .NET web applications function, allowing for more flexibility in development and deployment.

**Example: Blazor WebAssembly Client with ASP.NET Core API Server**
```csharp
// ASP.NET Core Web API (Server)
[ApiController]
[Route("api/[controller]")]
public class LibraryController : ControllerBase
{
    private readonly ILibraryService _libraryService;

    public LibraryController(ILibraryService libraryService)
    {
        _libraryService = libraryService;
    }

    [HttpGet("search/{title}")]
    public async Task<ActionResult<IEnumerable<Book>>> SearchBooks(string title)
    {
        var books = await _libraryService.SearchBooksByTitleAsync(title);
        return Ok(books);
    }

    [HttpGet("book/{id}")]
    public async Task<ActionResult<Book>> GetBookDetails(int id)
    {
        var book = await _libraryService.GetBookByIdAsync(id);
        if (book == null)
            return NotFound();
        
        return Ok(book);
    }
}

// Blazor WebAssembly Client
@page "/library"
@inject HttpClient Http

<h3>Library Search</h3>

<div class="mb-3">
    <div class="input-group">
        <input type="text" class="form-control" @bind="searchTitle" @onkeypress="@((e) => { if (e.Key == "Enter") SearchBooks(); })" placeholder="Search for books..." />
        <button class="btn btn-primary" @onclick="SearchBooks">Search</button>
    </div>
</div>

@if (loading)
{
    <div class="d-flex justify-content-center">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else if (books.Any())
{
    <div class="row">
        @foreach (var book in books)
        {
            <div class="col-md-6 mb-3">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">@book.Title</h5>
                        <p class="card-text">@book.Author</p>
                        <p class="card-text"><small class="text-muted">ISBN: @book.ISBN</small></p>
                        <button class="btn btn-info btn-sm" @onclick="() => GetBookDetails(book.Id)">
                            View Details
                        </button>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    private string searchTitle = "";
    private List<Book> books = new();
    private bool loading = false;

    private async Task SearchBooks()
    {
        if (string.IsNullOrWhiteSpace(searchTitle)) return;

        loading = true;
        try
        {
            // Client requests book information from the server
            books = await Http.GetFromJsonAsync<List<Book>>($"api/library/search/{searchTitle}") ?? new();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error searching books: {ex.Message}");
            books = new List<Book>();
        }
        finally
        {
            loading = false;
        }
    }

    private async Task GetBookDetails(int bookId)
    {
        try
        {
            // Server responds with detailed book information
            var book = await Http.GetFromJsonAsync<Book>($"api/library/book/{bookId}");
            // Handle book details display logic
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting book details: {ex.Message}");
        }
    }
}
```

For example, when you search for a book in a library system, your Blazor WebAssembly app (the client) asks for the book details. The ASP.NET Core Web API (the server) responds by providing the information from the database. Understanding the client-server model is essential for establishing communication between .NET components.

### 3. Model-View-Controller (MVC) Pattern

But efficiently organizing the application's backend logic requires a structured approach. This is where the Model-View-Controller, or MVC, design pattern comes in. ASP.NET Core MVC is a design pattern that separates an application into three interconnected parts: the model, the view, and the controller. This structure helps organize application logic, user interface, and control logic, making the application more maintainable and scalable.

**Example: Online Store with ASP.NET Core MVC**
```csharp
// Model - Handles data and business logic
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public string Description { get; set; } = string.Empty;
    public int StockQuantity { get; set; }
}

public class CartItem
{
    public int Id { get; set; }
    public int ProductId { get; set; }
    public Product Product { get; set; } = null!;
    public int Quantity { get; set; }
    public string UserId { get; set; } = string.Empty;
}

// Controller - Acts as a bridge between Model and View
[Controller]
public class ProductController : Controller
{
    private readonly IProductService _productService;
    private readonly ICartService _cartService;

    public ProductController(IProductService productService, ICartService cartService)
    {
        _productService = productService;
        _cartService = cartService;
    }

    // Processes user input and updates the model
    public async Task<IActionResult> Index()
    {
        var products = await _productService.GetAllProductsAsync();
        return View(products);
    }

    [HttpGet]
    public async Task<IActionResult> Details(int id)
    {
        var product = await _productService.GetProductByIdAsync(id);
        if (product == null)
            return NotFound();

        return View(product);
    }

    [HttpPost]
    public async Task<IActionResult> AddToCart(int productId, int quantity = 1)
    {
        try
        {
            var userId = User.Identity?.Name ?? "guest";
            await _cartService.AddToCartAsync(userId, productId, quantity);
            
            TempData["Success"] = "Product added to cart successfully!";
            return RedirectToAction(nameof(Details), new { id = productId });
        }
        catch (Exception ex)
        {
            TempData["Error"] = $"Failed to add product to cart: {ex.Message}";
            return RedirectToAction(nameof(Details), new { id = productId });
        }
    }
}

// Service Layer - Business Logic
public interface IProductService
{
    Task<IEnumerable<Product>> GetAllProductsAsync();
    Task<Product?> GetProductByIdAsync(int id);
}

public class ProductService : IProductService
{
    private readonly AppDbContext _context;

    public ProductService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<Product>> GetAllProductsAsync()
    {
        return await _context.Products
            .Where(p => p.StockQuantity > 0)
            .ToListAsync();
    }

    public async Task<Product?> GetProductByIdAsync(int id)
    {
        return await _context.Products.FindAsync(id);
    }
}
```

**View - Presents data to users (Razor View)**
```html
@model Product
@{
    ViewData["Title"] = Model.Name;
}

<!-- View presents product details to users -->
<div class="container">
    <div class="row">
        <div class="col-md-8">
            <h2>@Model.Name</h2>
            <p class="lead">@Model.Description</p>
            <h3 class="text-success">$@Model.Price</h3>
            <p>Stock: @Model.StockQuantity units available</p>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Purchase Options</h5>
                    
                    <!-- Form to add product to cart -->
                    <form asp-action="AddToCart" asp-controller="Product" method="post">
                        <input type="hidden" asp-for="Id" />
                        <div class="mb-3">
                            <label for="quantity" class="form-label">Quantity</label>
                            <select name="quantity" id="quantity" class="form-select">
                                @for (int i = 1; i <= Math.Min(10, Model.StockQuantity); i++)
                                {
                                    <option value="@i">@i</option>
                                }
                            </select>
                        </div>
                        <button type="submit" class="btn btn-primary btn-lg w-100">
                            Add to Cart
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

@if (TempData["Success"] != null)
{
    <div class="alert alert-success alert-dismissible fade show" role="alert">
        @TempData["Success"]
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
}
```

To understand how these parts work together, let's break them down:

- **The Model** handles the data and business logic of the application through Entity Framework and service classes
- **The View** is responsible for presenting this data to users using Razor pages, such as displaying product details or a shopping cart
- **The Controller** acts as a bridge, processing user input, updating the model through services, and refreshing the view to reflect the changes

Think of an online store built with ASP.NET Core MVC. The model holds product information like names and prices in Entity Framework entities. The view presents those details to users on the Razor pages. When you select "Add to Cart", the controller processes this action, updates the cart through the service layer, and ensures both the model and the view reflect this action. This separation makes the system easier to manage and scale.

### 4. Microservices Architecture

For larger projects, breaking applications into smaller, independent parts can make them easier to work with, which is where the microservices architectural pattern can be used with .NET technologies. Microservices are small, independently deployable .NET services that communicate with each other over HTTP APIs to perform specific functions within a larger system.

**Example: Movie Streaming Platform Microservices**
```csharp
// User Service (Separate ASP.NET Core Web API)
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;

    public UsersController(IUserService userService)
    {
        _userService = userService;
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(int id)
    {
        var user = await _userService.GetUserByIdAsync(id);
        return user != null ? Ok(user) : NotFound();
    }

    [HttpPost("authenticate")]
    public async Task<ActionResult<AuthResponse>> Authenticate([FromBody] LoginRequest request)
    {
        var response = await _userService.AuthenticateAsync(request.Email, request.Password);
        return Ok(response);
    }
}

// Streaming Service (Separate ASP.NET Core Web API)
[ApiController]
[Route("api/[controller]")]
public class StreamingController : ControllerBase
{
    private readonly IStreamingService _streamingService;
    private readonly HttpClient _userServiceClient;

    public StreamingController(IStreamingService streamingService, HttpClient userServiceClient)
    {
        _streamingService = streamingService;
        _userServiceClient = userServiceClient;
    }

    [HttpGet("movie/{movieId}/stream")]
    public async Task<ActionResult> GetStreamUrl(int movieId, [FromHeader] string authorization)
    {
        try
        {
            // Validate user with User Service
            var userResponse = await _userServiceClient.GetAsync($"api/users/validate", 
                new RequestHeaders { { "Authorization", authorization } });
            
            if (!userResponse.IsSuccessStatusCode)
                return Unauthorized();

            var streamUrl = await _streamingService.GetStreamUrlAsync(movieId);
            return Ok(new { StreamUrl = streamUrl });
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Error retrieving stream: {ex.Message}");
        }
    }
}

// Payment Service (Separate ASP.NET Core Web API)
[ApiController]
[Route("api/[controller]")]
public class PaymentController : ControllerBase
{
    private readonly IPaymentService _paymentService;

    public PaymentController(IPaymentService paymentService)
    {
        _paymentService = paymentService;
    }

    [HttpPost("process")]
    public async Task<ActionResult<PaymentResult>> ProcessPayment([FromBody] PaymentRequest request)
    {
        try
        {
            var result = await _paymentService.ProcessPaymentAsync(request);
            return Ok(result);
        }
        catch (Exception ex)
        {
            return BadRequest($"Payment processing failed: {ex.Message}");
        }
    }

    [HttpGet("subscription/{userId}")]
    public async Task<ActionResult<Subscription>> GetSubscription(int userId)
    {
        var subscription = await _paymentService.GetUserSubscriptionAsync(userId);
        return subscription != null ? Ok(subscription) : NotFound();
    }
}

// API Gateway (ASP.NET Core with YARP - Yet Another Reverse Proxy)
// Program.cs for API Gateway
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));

builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowBlazorClient", policy =>
        policy.WithOrigins("https://localhost:7001")
              .AllowAnyHeader()
              .AllowAnyMethod());
});

var app = builder.Build();

app.UseCors("AllowBlazorClient");
app.MapReverseProxy();

app.Run();

// Blazor WebAssembly Client consuming microservices
@page "/movies"
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<h3>Movie Streaming</h3>

@if (movies.Any())
{
    <div class="row">
        @foreach (var movie in movies)
        {
            <div class="col-md-4 mb-3">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">@movie.Title</h5>
                        <p class="card-text">@movie.Description</p>
                        <button class="btn btn-primary" @onclick="() => StartStreaming(movie.Id)">
                            Watch Now
                        </button>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    private List<Movie> movies = new();
    private string authToken = "";

    protected override async Task OnInitializedAsync()
    {
        // Load movies from catalog service
        movies = await Http.GetFromJsonAsync<List<Movie>>("api/catalog/movies") ?? new();
    }

    private async Task StartStreaming(int movieId)
    {
        try
        {
            // Check subscription status via Payment Service
            var subscriptionResponse = await Http.GetAsync($"api/payment/subscription/{GetUserId()}");
            if (!subscriptionResponse.IsSuccessStatusCode)
            {
                await JSRuntime.InvokeVoidAsync("alert", "Please subscribe to watch movies");
                return;
            }

            // Get streaming URL from Streaming Service
            var request = new HttpRequestMessage(HttpMethod.Get, $"api/streaming/movie/{movieId}/stream");
            request.Headers.Add("Authorization", $"Bearer {authToken}");
            
            var response = await Http.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                var streamData = await response.Content.ReadFromJsonAsync<StreamResponse>();
                await JSRuntime.InvokeVoidAsync("window.open", streamData.StreamUrl, "_blank");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error starting stream: {ex.Message}");
        }
    }

    private int GetUserId()
    {
        // In a real app, get from authentication state
        return 123;
    }
}
```

**Docker Compose Configuration for Microservices:**
```yaml
version: '3.8'
services:
  user-service:
    build: ./UserService
    ports:
      - "5001:80"
    environment:
      - ConnectionStrings__DefaultConnection=Server=user-db;Database=UserDb;User=sa;Password=YourPassword123;
    depends_on:
      - user-db

  streaming-service:
    build: ./StreamingService
    ports:
      - "5002:80"
    environment:
      - ConnectionStrings__DefaultConnection=Server=streaming-db;Database=StreamingDb;User=sa;Password=YourPassword123;
    depends_on:
      - streaming-db

  payment-service:
    build: ./PaymentService
    ports:
      - "5003:80"
    environment:
      - ConnectionStrings__DefaultConnection=Server=payment-db;Database=PaymentDb;User=sa;Password=YourPassword123;
    depends_on:
      - payment-db

  api-gateway:
    build: ./ApiGateway
    ports:
      - "5000:80"
    depends_on:
      - user-service
      - streaming-service
      - payment-service

  blazor-client:
    build: ./BlazorClient
    ports:
      - "7001:80"
    depends_on:
      - api-gateway
```

For example, a movie streaming platform could have separate .NET services for user accounts, streaming, and payments. Each service runs independently with its own database and can be deployed, scaled, and maintained separately. This setup makes it easier to manage and scale each service independently while maintaining the benefits of the .NET ecosystem across all services.

## Conclusion

In this section, you learned about different architectural patterns for full-stack .NET applications, such as monolithic ASP.NET Core apps, client-server separation with Blazor WebAssembly and Web APIs, MVC pattern implementation, and microservices architecture using multiple .NET services. Understanding these patterns equips you to choose the right structure for any .NET project, ensuring your applications remain flexible, efficient, and ready to grow with future demands while leveraging the power and consistency of the C# language and .NET platform across your entire stack.