# SignalR in .NET: Real-Time Client-Server Communication

SignalR is a powerful library in the .NET framework that enables real-time broadcasting of messages to multiple clients simultaneously. This guide demonstrates how to implement SignalR in a client-server application using Blazor.

## Project Structure

The solution consists of three projects:
- **Server Project**: Handles message broadcasting using SignalR
- **Client Project**: Receives and sends messages through SignalR connection
- **Shared Project**: Contains common data models used by both client and server

## Shared Project

The shared project contains the common data model used across the application:

```csharp
// ChatMessages.cs
public class ChatMessage
{
    public string User { get; set; }
    public string Message { get; set; }
    public DateTime Timestamp { get; set; }
}
```

## Server Implementation

### Program.cs Configuration

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Add SignalR service
builder.Services.AddSignalR();

// Configure CORS for client trust
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(builder =>
    {
        builder.AllowAnyOrigin()
               .AllowAnyMethod()
               .AllowAnyHeader();
    });
});

var app = builder.Build();

app.UseCors();

// Map the SignalR hub
// implementation ChatHub on the server side has the "/chathub" url attached to it:
// and the cliend side implementation has the _hubConnection = new HubConnectionBuilder().WithUrl("https://localhost:5137/chathub") so that it links server and client 
app.MapHub<ChatHub>("/chathub");

app.Run();
```

### ChatHub Implementation

The ChatHub is the core component that handles message broadcasting:

```csharp
// ChatHub.cs
using Microsoft.AspNetCore.SignalR;

public class ChatHub : Hub
{
    public async Task SendMessage(ChatMessage message)
    {
        // Set timestamp for the message
        message.Timestamp = DateTime.Now;
        
        // Broadcast message to all connected clients
        // this sends to all clients listening to "ReceiveMessage"
        await Clients.All.SendAsync("ReceiveMessage", message);
    }
}
```

## Client Implementation

### Chat Service

The chat service manages the SignalR connection on the client side:

```csharp
// ChatService.cs
using Microsoft.AspNetCore.SignalR.Client;

public class ChatService
{
    private HubConnection _hubConnection;
    
    // Event handler for received messages
    public Action<ChatMessage> OnMessageReceived { get; set; }

    public ChatService()
    {
        // Initialize hub connection
        _hubConnection = new HubConnectionBuilder()
            .WithUrl("https://localhost:5137/chathub") // Server URL with hub route
            .WithAutomaticReconnect() // Auto-reconnect if connection drops
            .Build();

        // Set up event handler for incoming messages
        // This event handler is for channel "ReceiveMessage"on the /chathub
        _hubConnection.On<ChatMessage>("ReceiveMessage", (message) =>
        {
            OnMessageReceived?.Invoke(message);
        });
    }

    public async Task StartAsync()
    {
        await _hubConnection.StartAsync();
    }

    public async Task SendMessage(ChatMessage message)
    {
        await _hubConnection.SendAsync("SendMessage", message);
    }
}
```

### Razor Page Implementation

The chat interface is implemented in a Blazor component:

```razor
@* Chat.razor *@
@page "/chat"
@using Microsoft.AspNetCore.SignalR.Client
@inject ChatService chatService
@implements IAsyncDisposable

<h3>Real-Time Chat</h3>

<div class="chat-container">
    <div class="messages">
        @foreach (var message in messages)
        {
            <div class="message">
                <strong>@message.User:</strong> @message.Message 
                <small>(@message.Timestamp.ToString("HH:mm:ss"))</small>
            </div>
        }
    </div>

    <div class="input-section">
        <input @bind="username" placeholder="Username" />
        <input @bind="messageText" placeholder="Type a message..." @onkeypress="@(async (e) => { if (e.Key == "Enter") await Send(); })" />
        <button @onclick="Send">Send</button>
    </div>
</div>

@code {
    private List<ChatMessage> messages = new();
    private string username = "";
    private string messageText = "";

    protected override async Task OnInitializedAsync()
    {
        // Set up message received handler
        chatService.OnMessageReceived += (message) =>
        {
            messages.Add(message);
            InvokeAsync(StateHasChanged); // Update UI when new message arrives
        };

        // Start the SignalR connection
        await chatService.StartAsync();
    }

    private async Task Send()
    {
        if (!string.IsNullOrWhiteSpace(username) && !string.IsNullOrWhiteSpace(messageText))
        {
            var message = new ChatMessage
            {
                User = username,
                Message = messageText,
                Timestamp = DateTime.Now
            };

            await chatService.SendMessage(message);
            messageText = ""; // Clear the input after sending
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (chatService != null)
        {
            await chatService.DisposeAsync();
        }
    }
}
```

## How It Works

1. **Server Setup**: The server runs SignalR hub at a specific endpoint (`/chathub`) and listens for incoming messages
2. **Client Connection**: Each client establishes a real-time connection to the server using `HubConnection`
3. **Message Flow**: 
   - Client sends message to server via `SendMessage` method
   - Server receives message in `ChatHub.SendMessage`
   - Server broadcasts message to all connected clients using `Clients.All.SendAsync`
   - All clients receive the message through their `OnMessageReceived` event handler
4. **Real-Time Updates**: No polling required - messages are pushed to clients instantly

## Key Features

- **Real-Time Communication**: Messages are broadcast instantly to all connected clients
- **Automatic Reconnection**: Clients automatically reconnect if the connection drops  
- **Scalable**: Can handle multiple clients simultaneously
- **Cross-Platform**: Works across different devices and browsers
- **Event-Driven**: Uses event handlers for clean message processing

## Running the Application

1. Start the server project (typically runs on `localhost:5137`)
2. Start one or more client instances (typically on `localhost:5132`)
3. Open multiple browser tabs to simulate different clients
4. Send messages from any client - they'll appear in all connected clients in real-time

This demonstrates the power of SignalR for creating responsive, real-time applications where multiple users need to see updates instantly without manual page refreshes or polling.


### Signal run message individual clients

# SignalR: Sending Messages to Specific Clients

While broadcasting to all clients is useful, SignalR also allows you to send messages to specific clients, groups, or users. Here's how to implement targeted messaging.

## Methods for Targeting Specific Clients

SignalR provides several ways to send messages to specific recipients:

1. **Specific Client by Connection ID**
2. **Specific User by User ID**
3. **Specific Group of Clients**
4. **All Clients Except Specific Ones**

## Server Implementation

### Enhanced ChatHub with Targeted Messaging

```csharp
// ChatHub.cs
using Microsoft.AspNetCore.SignalR;
using Microsoft.AspNetCore.Authorization;

public class ChatHub : Hub
{
    // Send to ALL clients (broadcast)
    public async Task SendMessageToAll(ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        await Clients.All.SendAsync("ReceiveMessage", message);
    }

    // Send to a SPECIFIC CLIENT by Connection ID
    public async Task SendMessageToClient(string connectionId, ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        await Clients.Client(connectionId).SendAsync("ReceiveMessage", message);
    }

    // Send to a SPECIFIC USER by User ID
    public async Task SendMessageToUser(string userId, ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        await Clients.User(userId).SendAsync("ReceiveMessage", message);
    }

    // Send to ALL EXCEPT the sender
    public async Task SendMessageToOthers(ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        await Clients.Others.SendAsync("ReceiveMessage", message);
    }

    // Send to ALL EXCEPT specific clients
    public async Task SendMessageExceptClients(ChatMessage message, List<string> excludedConnectionIds)
    {
        message.Timestamp = DateTime.Now;
        await Clients.AllExcept(excludedConnectionIds).SendAsync("ReceiveMessage", message);
    }

    // Send to a GROUP
    public async Task SendMessageToGroup(string groupName, ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        await Clients.Group(groupName).SendAsync("ReceiveMessage", message);
    }

    // Private message between two users
    public async Task SendPrivateMessage(string recipientUserId, ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        
        // Send to recipient
        await Clients.User(recipientUserId).SendAsync("ReceivePrivateMessage", message);
        
        // Also send to sender for confirmation
        await Clients.Caller.SendAsync("ReceivePrivateMessage", message);
    }

    // Connection management
    public override async Task OnConnectedAsync()
    {
        // Store connection info when client connects
        var connectionId = Context.ConnectionId;
        var userId = Context.UserIdentifier; // Available if using authentication
        
        // You can store this mapping in a database or in-memory store
        await Groups.AddToGroupAsync(connectionId, "OnlineUsers");
        
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception exception)
    {
        var connectionId = Context.ConnectionId;
        await Groups.RemoveFromGroupAsync(connectionId, "OnlineUsers");
        
        await base.OnDisconnectedAsync(exception);
    }
}
```

## Enhanced Data Models

```csharp
// Enhanced ChatMessage.cs
public class ChatMessage
{
    public string User { get; set; }
    public string Message { get; set; }
    public DateTime Timestamp { get; set; }
    public string RecipientId { get; set; } // For private messages
    public MessageType Type { get; set; } = MessageType.Public;
}

public enum MessageType
{
    Public,
    Private,
    System
}

// For managing connected clients
public class ConnectedUser
{
    public string ConnectionId { get; set; }
    public string UserId { get; set; }
    public string Username { get; set; }
    public DateTime ConnectedAt { get; set; }
}
```

## Client Service Implementation

### Enhanced ChatService

```csharp
// ChatService.cs
using Microsoft.AspNetCore.SignalR.Client;

public class ChatService : IAsyncDisposable
{
    private HubConnection _hubConnection;
    private readonly List<ConnectedUser> _connectedUsers = new();
    
    // Event handlers
    public Action<ChatMessage> OnMessageReceived { get; set; }
    public Action<ChatMessage> OnPrivateMessageReceived { get; set; }
    public Action<List<ConnectedUser>> OnUsersUpdated { get; set; }
    public Action<string> OnConnectionIdReceived { get; set; }

    public string ConnectionId => _hubConnection?.ConnectionId;
    public string CurrentUserId { get; private set; }

    public ChatService()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl("https://localhost:5137/chathub")
            .WithAutomaticReconnect()
            .Build();

        SetupEventHandlers();
    }

    private void SetupEventHandlers()
    {
        // Handle public messages
        _hubConnection.On<ChatMessage>("ReceiveMessage", (message) =>
        {
            OnMessageReceived?.Invoke(message);
        });

        // Handle private messages
        _hubConnection.On<ChatMessage>("ReceivePrivateMessage", (message) =>
        {
            OnPrivateMessageReceived?.Invoke(message);
        });

        // Handle connection ID updates
        _hubConnection.On<string>("ConnectionIdUpdate", (connectionId) =>
        {
            OnConnectionIdReceived?.Invoke(connectionId);
        });

        // Handle user list updates
        _hubConnection.On<List<ConnectedUser>>("UsersUpdated", (users) =>
        {
            _connectedUsers.Clear();
            _connectedUsers.AddRange(users);
            OnUsersUpdated?.Invoke(users);
        });
    }

    public async Task StartAsync(string userId)
    {
        CurrentUserId = userId;
        await _hubConnection.StartAsync();
    }

    // Send to all clients
    public async Task SendMessageToAll(ChatMessage message)
    {
        await _hubConnection.SendAsync("SendMessageToAll", message);
    }

    // Send to specific client by connection ID
    public async Task SendMessageToClient(string connectionId, ChatMessage message)
    {
        await _hubConnection.SendAsync("SendMessageToClient", connectionId, message);
    }

    // Send to specific user by user ID
    public async Task SendMessageToUser(string userId, ChatMessage message)
    {
        await _hubConnection.SendAsync("SendMessageToUser", userId, message);
    }

    // Send private message
    public async Task SendPrivateMessage(string recipientUserId, ChatMessage message)
    {
        message.Type = MessageType.Private;
        message.RecipientId = recipientUserId;
        await _hubConnection.SendAsync("SendPrivateMessage", recipientUserId, message);
    }

    // Send to others (not self)
    public async Task SendMessageToOthers(ChatMessage message)
    {
        await _hubConnection.SendAsync("SendMessageToOthers", message);
    }

    public List<ConnectedUser> GetConnectedUsers() => _connectedUsers.ToList();

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}
```

## Enhanced Razor Component

```razor
@* EnhancedChat.razor *@
@page "/enhanced-chat"
@inject ChatService chatService
@implements IAsyncDisposable

<h3>Enhanced SignalR Chat</h3>

<div class="chat-layout">
    <!-- Connected Users Panel -->
    <div class="users-panel">
        <h4>Online Users (@connectedUsers.Count)</h4>
        <ul class="user-list">
            @foreach (var user in connectedUsers)
            {
                <li class="user-item @(user.UserId == currentUserId ? "current-user" : "")" 
                    @onclick="() => SelectUser(user)">
                    @user.Username
                    @if (selectedUser?.UserId == user.UserId)
                    {
                        <span class="selected">üìù</span>
                    }
                </li>
            }
        </ul>
    </div>

    <!-- Chat Area -->
    <div class="chat-area">
        <!-- Message Display -->
        <div class="messages-container">
            @foreach (var message in messages)
            {
                <div class="message @GetMessageClass(message)">
                    <div class="message-header">
                        <strong>@message.User</strong>
                        <small>@message.Timestamp.ToString("HH:mm:ss")</small>
                        @if (message.Type == MessageType.Private)
                        {
                            <span class="private-indicator">üîí Private</span>
                        }
                    </div>
                    <div class="message-content">@message.Message</div>
                </div>
            }
        </div>

        <!-- Message Input -->
        <div class="input-section">
            <div class="input-row">
                <input @bind="username" placeholder="Your username" disabled="@isConnected" />
                <button @onclick="Connect" disabled="@isConnected">
                    @(isConnected ? "Connected" : "Connect")
                </button>
            </div>
            
            @if (isConnected)
            {
                <div class="input-row">
                    <select @bind="messageTarget" class="target-select">
                        <option value="all">Everyone</option>
                        <option value="others">Others (not me)</option>
                        @if (selectedUser != null && selectedUser.UserId != currentUserId)
                        {
                            <option value="private">Private to @selectedUser.Username</option>
                        }
                    </select>
                </div>
                
                <div class="input-row">
                    <input @bind="messageText" placeholder="Type a message..." 
                           @onkeypress="@(async (e) => { if (e.Key == "Enter") await SendMessage(); })" 
                           class="message-input" />
                    <button @onclick="SendMessage" class="send-button">Send</button>
                </div>
            }
        </div>
    </div>
</div>

<div class="connection-info">
    <small>Connection ID: @connectionId</small>
</div>

@code {
    private List<ChatMessage> messages = new();
    private List<ConnectedUser> connectedUsers = new();
    private ConnectedUser selectedUser;
    private string username = "";
    private string messageText = "";
    private string messageTarget = "all";
    private string connectionId = "";
    private string currentUserId = "";
    private bool isConnected = false;

    protected override async Task OnInitializedAsync()
    {
        // Set up event handlers
        chatService.OnMessageReceived = (message) =>
        {
            messages.Add(message);
            InvokeAsync(StateHasChanged);
        };

        chatService.OnPrivateMessageReceived = (message) =>
        {
            messages.Add(message);
            InvokeAsync(StateHasChanged);
        };

        chatService.OnUsersUpdated = (users) =>
        {
            connectedUsers = users;
            InvokeAsync(StateHasChanged);
        };

        chatService.OnConnectionIdReceived = (id) =>
        {
            connectionId = id;
            InvokeAsync(StateHasChanged);
        };
    }

    private async Task Connect()
    {
        if (!string.IsNullOrWhiteSpace(username))
        {
            currentUserId = Guid.NewGuid().ToString();
            await chatService.StartAsync(currentUserId);
            connectionId = chatService.ConnectionId;
            isConnected = true;
            StateHasChanged();
        }
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(messageText) && isConnected)
        {
            var message = new ChatMessage
            {
                User = username,
                Message = messageText,
                Timestamp = DateTime.Now
            };

            switch (messageTarget)
            {
                case "all":
                    await chatService.SendMessageToAll(message);
                    break;
                case "others":
                    await chatService.SendMessageToOthers(message);
                    break;
                case "private":
                    if (selectedUser != null)
                    {
                        await chatService.SendPrivateMessage(selectedUser.UserId, message);
                    }
                    break;
            }

            messageText = "";
        }
    }

    private void SelectUser(ConnectedUser user)
    {
        selectedUser = user;
        if (user.UserId != currentUserId)
        {
            messageTarget = "private";
        }
    }

    private string GetMessageClass(ChatMessage message)
    {
        var classes = new List<string>();
        
        if (message.User == username)
            classes.Add("own-message");
        
        if (message.Type == MessageType.Private)
            classes.Add("private-message");
            
        return string.Join(" ", classes);
    }

    public async ValueTask DisposeAsync()
    {
        await chatService.DisposeAsync();
    }
}

<style>
    .chat-layout { display: flex; height: 500px; border: 1px solid #ccc; }
    .users-panel { width: 200px; border-right: 1px solid #ccc; padding: 10px; }
    .chat-area { flex: 1; display: flex; flex-direction: column; }
    .messages-container { flex: 1; overflow-y: auto; padding: 10px; }
    .message { margin: 5px 0; padding: 8px; border-radius: 5px; }
    .own-message { background-color: #e3f2fd; margin-left: 20%; }
    .private-message { background-color: #fff3e0; border-left: 3px solid #ff9800; }
    .user-item { cursor: pointer; padding: 5px; border-radius: 3px; }
    .user-item:hover { background-color: #f0f0f0; }
    .user-item.current-user { font-weight: bold; }
    .selected { color: #2196f3; }
    .private-indicator { color: #ff9800; font-size: 0.8em; }
    .input-section { border-top: 1px solid #ccc; padding: 10px; }
    .input-row { display: flex; margin: 5px 0; gap: 5px; }
    .message-input { flex: 1; }
    .connection-info { margin-top: 10px; color: #666; }
</style>
```

## Key Differences from Broadcasting

| Method                         | Recipient                             | Use Case                          |
| ------------------------------ | ------------------------------------- | --------------------------------- |
| `Clients.All`                  | All connected clients                 | Public announcements              |
| `Clients.Client(connectionId)` | Specific connection                   | Direct connection-based messaging |
| `Clients.User(userId)`         | Specific user (all their connections) | User-specific notifications       |
| `Clients.Others`               | All except sender                     | Echo prevention                   |
| `Clients.Group(groupName)`     | All clients in a group                | Room-based chat                   |
| `Clients.AllExcept(list)`      | All except specified                  | Selective broadcasting            |

## Connection Management

For user-specific messaging, you'll often need to track connections:

```csharp
// ConnectionManager.cs
public class ConnectionManager
{
    private readonly Dictionary<string, ConnectedUser> _connections = new();
    
    public void AddConnection(string connectionId, string userId, string username)
    {
        _connections[connectionId] = new ConnectedUser
        {
            ConnectionId = connectionId,
            UserId = userId,
            Username = username,
            ConnectedAt = DateTime.Now
        };
    }
    
    public void RemoveConnection(string connectionId)
    {
        _connections.Remove(connectionId);
    }
    
    public ConnectedUser GetUser(string connectionId)
    {
        return _connections.GetValueOrDefault(connectionId);
    }
    
    public List<ConnectedUser> GetAllUsers()
    {
        return _connections.Values.ToList();
    }
    
    public string GetConnectionId(string userId)
    {
        return _connections.Values
            .FirstOrDefault(u => u.UserId == userId)?.ConnectionId;
    }
}
```

This approach allows you to send targeted messages instead of broadcasting to everyone, enabling features like private messaging, user-specific notifications, and selective communication.


### Hub Method Name/SignalR Method Identifier:

# SignalR Method Names: Understanding the Terminology

The string `"ReceiveMessage"` is called a **Hub Method Name** or **SignalR Method Identifier**. This is the key terminology used in SignalR documentation and development.

## What is a Hub Method Name?

- **Definition**: A string identifier that represents a specific message type or event in SignalR communication
- **Purpose**: Acts as a "channel" or "event name" that both client and server use to identify what type of message is being sent/received
- **Analogy**: Think of it like a radio frequency - both sender and receiver must be tuned to the same frequency to communicate

## Multiple Method Names on Same Connection

**Yes, absolutely!** You can have multiple different method names on the same hub connection. This is actually a best practice for organizing different types of messages.

## Example: Multiple Method Names

### Server Hub with Multiple Methods

```csharp
// ChatHub.cs
public class ChatHub : Hub
{
    // Different server methods that send different types of messages
    
    // Public chat messages
    public async Task SendPublicMessage(ChatMessage message)
    {
        await Clients.All.SendAsync("ReceivePublicMessage", message);
    }
    
    // Private messages
    public async Task SendPrivateMessage(string recipientUserId, PrivateMessage message)
    {
        await Clients.User(recipientUserId).SendAsync("ReceivePrivateMessage", message);
        await Clients.Caller.SendAsync("ReceivePrivateMessage", message); // Echo to sender
    }
    
    // System notifications
    public async Task SendSystemNotification(SystemNotification notification)
    {
        await Clients.All.SendAsync("ReceiveSystemNotification", notification);
    }
    
    // User status updates
    public async Task UpdateUserStatus(string userId, UserStatus status)
    {
        await Clients.Others.SendAsync("ReceiveUserStatusUpdate", userId, status);
    }
    
    // File sharing notifications
    public async Task ShareFile(string recipientUserId, FileInfo fileInfo)
    {
        await Clients.User(recipientUserId).SendAsync("ReceiveFileShare", fileInfo);
    }
    
    // Typing indicators
    public async Task SendTypingIndicator(string userId, bool isTyping)
    {
        await Clients.Others.SendAsync("ReceiveTypingIndicator", userId, isTyping);
    }
    
    // Connection events
    public override async Task OnConnectedAsync()
    {
        var userId = Context.UserIdentifier ?? Context.ConnectionId;
        var userInfo = new UserInfo { UserId = userId, Username = "User" + userId[..8] };
        
        // Notify others about new user
        await Clients.Others.SendAsync("ReceiveUserJoined", userInfo);
        
        await base.OnConnectedAsync();
    }
    
    public override async Task OnDisconnectedAsync(Exception exception)
    {
        var userId = Context.UserIdentifier ?? Context.ConnectionId;
        
        // Notify others about user leaving
        await Clients.Others.SendAsync("ReceiveUserLeft", userId);
        
        await base.OnDisconnectedAsync(exception);
    }
}
```

### Client Service Handling Multiple Method Names

```csharp
// ChatService.cs
public class ChatService : IAsyncDisposable
{
    private HubConnection _hubConnection;
    
    // Different event handlers for different message types
    public Action<ChatMessage> OnPublicMessageReceived { get; set; }
    public Action<PrivateMessage> OnPrivateMessageReceived { get; set; }
    public Action<SystemNotification> OnSystemNotificationReceived { get; set; }
    public Action<string, UserStatus> OnUserStatusUpdateReceived { get; set; }
    public Action<FileInfo> OnFileShareReceived { get; set; }
    public Action<string, bool> OnTypingIndicatorReceived { get; set; }
    public Action<UserInfo> OnUserJoinedReceived { get; set; }
    public Action<string> OnUserLeftReceived { get; set; }

    public ChatService()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl("https://localhost:5137/chathub")
            .WithAutomaticReconnect()
            .Build();

        SetupEventHandlers();
    }

    private void SetupEventHandlers()
    {
        // Register handlers for different method names
        
        _hubConnection.On<ChatMessage>("ReceivePublicMessage", (message) =>
        {
            OnPublicMessageReceived?.Invoke(message);
        });

        _hubConnection.On<PrivateMessage>("ReceivePrivateMessage", (message) =>
        {
            OnPrivateMessageReceived?.Invoke(message);
        });

        _hubConnection.On<SystemNotification>("ReceiveSystemNotification", (notification) =>
        {
            OnSystemNotificationReceived?.Invoke(notification);
        });

        _hubConnection.On<string, UserStatus>("ReceiveUserStatusUpdate", (userId, status) =>
        {
            OnUserStatusUpdateReceived?.Invoke(userId, status);
        });

        _hubConnection.On<FileInfo>("ReceiveFileShare", (fileInfo) =>
        {
            OnFileShareReceived?.Invoke(fileInfo);
        });

        _hubConnection.On<string, bool>("ReceiveTypingIndicator", (userId, isTyping) =>
        {
            OnTypingIndicatorReceived?.Invoke(userId, isTyping);
        });

        _hubConnection.On<UserInfo>("ReceiveUserJoined", (userInfo) =>
        {
            OnUserJoinedReceived?.Invoke(userInfo);
        });

        _hubConnection.On<string>("ReceiveUserLeft", (userId) =>
        {
            OnUserLeftReceived?.Invoke(userId);
        });
    }

    // Client methods to send different types of messages
    
    public async Task SendPublicMessage(ChatMessage message)
    {
        await _hubConnection.SendAsync("SendPublicMessage", message);
    }

    public async Task SendPrivateMessage(string recipientUserId, PrivateMessage message)
    {
        await _hubConnection.SendAsync("SendPrivateMessage", recipientUserId, message);
    }

    public async Task SendSystemNotification(SystemNotification notification)
    {
        await _hubConnection.SendAsync("SendSystemNotification", notification);
    }

    public async Task UpdateUserStatus(string userId, UserStatus status)
    {
        await _hubConnection.SendAsync("UpdateUserStatus", userId, status);
    }

    public async Task ShareFile(string recipientUserId, FileInfo fileInfo)
    {
        await _hubConnection.SendAsync("ShareFile", recipientUserId, fileInfo);
    }

    public async Task SendTypingIndicator(string userId, bool isTyping)
    {
        await _hubConnection.SendAsync("SendTypingIndicator", userId, isTyping);
    }

    public async Task StartAsync()
    {
        await _hubConnection.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}
```

### Data Models for Different Message Types

```csharp
// Different message models
public class ChatMessage
{
    public string User { get; set; }
    public string Message { get; set; }
    public DateTime Timestamp { get; set; }
}

public class PrivateMessage
{
    public string SenderId { get; set; }
    public string SenderName { get; set; }
    public string RecipientId { get; set; }
    public string Message { get; set; }
    public DateTime Timestamp { get; set; }
    public bool IsEncrypted { get; set; }
}

public class SystemNotification
{
    public string Title { get; set; }
    public string Message { get; set; }
    public NotificationLevel Level { get; set; }
    public DateTime Timestamp { get; set; }
}

public class UserInfo
{
    public string UserId { get; set; }
    public string Username { get; set; }
    public UserStatus Status { get; set; }
    public DateTime LastSeen { get; set; }
}

public enum UserStatus
{
    Online,
    Away,
    Busy,
    Offline
}

public enum NotificationLevel
{
    Info,
    Warning,
    Error,
    Success
}

public class FileInfo
{
    public string FileName { get; set; }
    public string FileUrl { get; set; }
    public long FileSize { get; set; }
    public string MimeType { get; set; }
    public string SenderId { get; set; }
}
```

### Enhanced Razor Component

```razor
@* MultiMethodChat.razor *@
@page "/multi-method-chat"
@inject ChatService chatService
@implements IAsyncDisposable

<h3>Multi-Method SignalR Chat</h3>

<div class="chat-container">
    <!-- System Notifications -->
    <div class="notifications">
        @foreach (var notification in systemNotifications.TakeLast(3))
        {
            <div class="notification @GetNotificationClass(notification.Level)">
                <strong>@notification.Title:</strong> @notification.Message
            </div>
        }
    </div>

    <!-- Messages Area -->
    <div class="messages-area">
        <!-- Public Messages -->
        <div class="public-messages">
            <h4>Public Chat</h4>
            @foreach (var message in publicMessages.TakeLast(10))
            {
                <div class="message public">
                    <strong>@message.User:</strong> @message.Message
                    <small>(@message.Timestamp.ToString("HH:mm"))</small>
                </div>
            }
        </div>

        <!-- Private Messages -->
        <div class="private-messages">
            <h4>Private Messages</h4>
            @foreach (var message in privateMessages.TakeLast(5))
            {
                <div class="message private">
                    <strong>@message.SenderName ‚Üí You:</strong> @message.Message
                    <small>(@message.Timestamp.ToString("HH:mm"))</small>
                </div>
            }
        </div>
    </div>

    <!-- User Status -->
    <div class="user-status">
        <h4>Online Users</h4>
        @foreach (var user in onlineUsers)
        {
            <div class="user @user.Status.ToString().ToLower()">
                @user.Username (@user.Status)
                @if (typingUsers.Contains(user.UserId))
                {
                    <span class="typing">‚úèÔ∏è</span>
                }
            </div>
        }
    </div>

    <!-- Input Section -->
    <div class="input-section">
        <select @bind="messageType">
            <option value="public">Public Message</option>
            <option value="private">Private Message</option>
            <option value="system">System Notification</option>
        </select>
        
        @if (messageType == "private")
        {
            <select @bind="privateRecipient">
                @foreach (var user in onlineUsers.Where(u => u.UserId != currentUserId))
                {
                    <option value="@user.UserId">@user.Username</option>
                }
            </select>
        }
        
        <input @bind="messageText" 
               @oninput="OnTyping"
               @onkeypress="@(async (e) => { if (e.Key == "Enter") await SendMessage(); })" 
               placeholder="Type a message..." />
        <button @onclick="SendMessage">Send</button>
    </div>
</div>

@code {
    private List<ChatMessage> publicMessages = new();
    private List<PrivateMessage> privateMessages = new();
    private List<SystemNotification> systemNotifications = new();
    private List<UserInfo> onlineUsers = new();
    private HashSet<string> typingUsers = new();
    
    private string messageText = "";
    private string messageType = "public";
    private string privateRecipient = "";
    private string currentUserId = Guid.NewGuid().ToString();
    private DateTime lastTypingTime = DateTime.MinValue;

    protected override async Task OnInitializedAsync()
    {
        // Set up all the different event handlers
        
        chatService.OnPublicMessageReceived = (message) =>
        {
            publicMessages.Add(message);
            InvokeAsync(StateHasChanged);
        };

        chatService.OnPrivateMessageReceived = (message) =>
        {
            privateMessages.Add(message);
            InvokeAsync(StateHasChanged);
        };

        chatService.OnSystemNotificationReceived = (notification) =>
        {
            systemNotifications.Add(notification);
            InvokeAsync(StateHasChanged);
        };

        chatService.OnUserStatusUpdateReceived = (userId, status) =>
        {
            var user = onlineUsers.FirstOrDefault(u => u.UserId == userId);
            if (user != null)
            {
                user.Status = status;
                InvokeAsync(StateHasChanged);
            }
        };

        chatService.OnTypingIndicatorReceived = (userId, isTyping) =>
        {
            if (isTyping)
                typingUsers.Add(userId);
            else
                typingUsers.Remove(userId);
            
            InvokeAsync(StateHasChanged);
        };

        chatService.OnUserJoinedReceived = (userInfo) =>
        {
            onlineUsers.Add(userInfo);
            InvokeAsync(StateHasChanged);
        };

        chatService.OnUserLeftReceived = (userId) =>
        {
            onlineUsers.RemoveAll(u => u.UserId == userId);
            typingUsers.Remove(userId);
            InvokeAsync(StateHasChanged);
        };

        await chatService.StartAsync();
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(messageText)) return;

        switch (messageType)
        {
            case "public":
                await chatService.SendPublicMessage(new ChatMessage
                {
                    User = "User" + currentUserId[..8],
                    Message = messageText,
                    Timestamp = DateTime.Now
                });
                break;

            case "private":
                if (!string.IsNullOrEmpty(privateRecipient))
                {
                    await chatService.SendPrivateMessage(privateRecipient, new PrivateMessage
                    {
                        SenderId = currentUserId,
                        SenderName = "User" + currentUserId[..8],
                        RecipientId = privateRecipient,
                        Message = messageText,
                        Timestamp = DateTime.Now
                    });
                }
                break;

            case "system":
                await chatService.SendSystemNotification(new SystemNotification
                {
                    Title = "System",
                    Message = messageText,
                    Level = NotificationLevel.Info,
                    Timestamp = DateTime.Now
                });
                break;
        }

        messageText = "";
    }

    private async Task OnTyping()
    {
        var now = DateTime.Now;
        if ((now - lastTypingTime).TotalSeconds > 1) // Throttle typing indicators
        {
            lastTypingTime = now;
            await chatService.SendTypingIndicator(currentUserId, true);
            
            // Stop typing indicator after 3 seconds
            _ = Task.Delay(3000).ContinueWith(async _ =>
            {
                await chatService.SendTypingIndicator(currentUserId, false);
            });
        }
    }

    private string GetNotificationClass(NotificationLevel level)
    {
        return level switch
        {
            NotificationLevel.Error => "error",
            NotificationLevel.Warning => "warning",
            NotificationLevel.Success => "success",
            _ => "info"
        };
    }

    public async ValueTask DisposeAsync()
    {
        await chatService.DisposeAsync();
    }
}

<style>
    .chat-container { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; height: 600px; }
    .notifications { background: #f5f5f5; padding: 10px; border-radius: 5px; margin-bottom: 10px; }
    .notification { padding: 5px; margin: 2px 0; border-radius: 3px; }
    .notification.error { background: #ffebee; color: #c62828; }
    .notification.warning { background: #fff3e0; color: #ef6c00; }
    .notification.success { background: #e8f5e8; color: #2e7d32; }
    .notification.info { background: #e3f2fd; color: #1565c0; }
    .messages-area { display: flex; flex-direction: column; gap: 10px; }
    .public-messages, .private-messages { border: 1px solid #ccc; padding: 10px; flex: 1; overflow-y: auto; }
    .message { margin: 5px 0; padding: 5px; border-radius: 3px; }
    .message.public { background: #f0f8ff; }
    .message.private { background: #fff0f5; }
    .user-status { border: 1px solid #ccc; padding: 10px; }
    .user { margin: 2px 0; padding: 2px; }
    .user.online { color: #4caf50; }
    .user.away { color: #ff9800; }
    .user.busy { color: #f44336; }
    .typing { animation: pulse 1s infinite; }
    .input-section { grid-column: 1 / -1; display: flex; gap: 5px; margin-top: 10px; }
    .input-section input { flex: 1; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
</style>
```

## Key Benefits of Multiple Method Names

1. **Type Safety**: Different message types can have different data structures
2. **Separation of Concerns**: Each message type handles specific functionality
3. **Selective Handling**: Clients can choose which message types to listen for
4. **Performance**: Avoid processing irrelevant messages
5. **Maintainability**: Easier to debug and extend specific message types
6. **UI Organization**: Different UI components can handle different message types

## Best Practices for Method Names

1. **Be Descriptive**: Use clear, descriptive names like `ReceivePrivateMessage` rather than `Msg1`
2. **Use Consistent Naming**: Follow a pattern like `Receive[MessageType]` or `On[EventType]`
3. **Verb-Noun Structure**: Start with action verbs: `Receive`, `Update`, `Notify`, `Send`
4. **Case Sensitivity**: Method names are case-sensitive, so be consistent
5. **Group Related Methods**: Use prefixes for related functionality (`Chat_`, `User_`, `System_`)

The method name is essentially the "contract" between client and server - both sides must use the exact same string to communicate successfully.


### Signal R with authentication:

SignalR authentication in ASP.NET Core works by integrating with the standard ASP.NET Core authentication system. Here's how it works and how to set it up:

## How SignalR Authentication Works

SignalR authentication leverages ASP.NET Core's authentication middleware. When a client connects to a hub:

1. **Initial Authentication**: The client must authenticate through standard HTTP authentication (cookies, JWT, etc.)
2. **Context Propagation**: The authenticated user context is automatically available in the hub through `Context.User` and `Context.UserIdentifier`
3. **Per-Connection**: Each SignalR connection maintains the authenticated user's identity throughout the connection lifecycle

## Setting Up Authentication

### 1. Configure Authentication in Program.cs (or Startup.cs)

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add authentication services
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
})
.AddCookie(options =>
{
    options.LoginPath = "/Account/Login";
    options.LogoutPath = "/Account/Logout";
});

// Or for JWT authentication:
// .AddJwtBearer(options => { ... });

builder.Services.AddSignalR();

var app = builder.Build();

// Enable authentication middleware (must be before SignalR)
app.UseAuthentication();
app.UseAuthorization();

// Map SignalR hub
app.MapHub<ChatHub>("/chathub");
```

### 2. Enhanced Hub with Authentication

```csharp
using Microsoft.AspNetCore.SignalR;
using Microsoft.AspNetCore.Authorization;
using System.Security.Claims;

[Authorize] // Require authentication for the entire hub
public class ChatHub : Hub
{
    private readonly IUserConnectionManager _connectionManager;
    
    public ChatHub(IUserConnectionManager connectionManager)
    {
        _connectionManager = connectionManager;
    }

    // Method-level authorization
    [Authorize(Roles = "Admin")]
    public async Task SendAdminMessage(ChatMessage message)
    {
        message.Timestamp = DateTime.Now;
        await Clients.All.SendAsync("ReceiveAdminMessage", message);
    }

    public async Task SendMessageToAll(ChatMessage message)
    {
        // Access authenticated user info
        var userId = Context.UserIdentifier; // User ID
        var userName = Context.User?.Identity?.Name; // Username
        var userClaims = Context.User?.Claims; // All claims
        
        message.SenderId = userId;
        message.SenderName = userName;
        message.Timestamp = DateTime.Now;
        
        await Clients.All.SendAsync("ReceiveMessage", message);
    }

    public override async Task OnConnectedAsync()
    {
        var connectionId = Context.ConnectionId;
        var userId = Context.UserIdentifier;
        var userName = Context.User?.Identity?.Name;
        
        if (userId != null)
        {
            // Store user-connection mapping
            await _connectionManager.AddConnectionAsync(userId, connectionId);
            
            // Add to authenticated users group
            await Groups.AddToGroupAsync(connectionId, "AuthenticatedUsers");
            
            // Notify others that user is online
            await Clients.Others.SendAsync("UserOnline", new { UserId = userId, UserName = userName });
        }
        
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception exception)
    {
        var connectionId = Context.ConnectionId;
        var userId = Context.UserIdentifier;
        
        if (userId != null)
        {
            await _connectionManager.RemoveConnectionAsync(userId, connectionId);
            await Groups.RemoveFromGroupAsync(connectionId, "AuthenticatedUsers");
            
            // Check if user has other active connections
            var hasOtherConnections = await _connectionManager.HasConnectionsAsync(userId);
            if (!hasOtherConnections)
            {
                await Clients.Others.SendAsync("UserOffline", new { UserId = userId });
            }
        }
        
        await base.OnDisconnectedAsync(exception);
    }
}
```

### 3. User Connection Management Service

```csharp
public interface IUserConnectionManager
{
    Task AddConnectionAsync(string userId, string connectionId);
    Task RemoveConnectionAsync(string userId, string connectionId);
    Task<List<string>> GetConnectionsAsync(string userId);
    Task<bool> HasConnectionsAsync(string userId);
}

public class InMemoryUserConnectionManager : IUserConnectionManager
{
    private readonly ConcurrentDictionary<string, HashSet<string>> _connections = new();

    public Task AddConnectionAsync(string userId, string connectionId)
    {
        _connections.AddOrUpdate(userId, 
            new HashSet<string> { connectionId },
            (key, existing) => 
            {
                existing.Add(connectionId);
                return existing;
            });
        return Task.CompletedTask;
    }

    public Task RemoveConnectionAsync(string userId, string connectionId)
    {
        if (_connections.TryGetValue(userId, out var connections))
        {
            connections.Remove(connectionId);
            if (!connections.Any())
            {
                _connections.TryRemove(userId, out _);
            }
        }
        return Task.CompletedTask;
    }

    public Task<List<string>> GetConnectionsAsync(string userId)
    {
        var connections = _connections.TryGetValue(userId, out var userConnections) 
            ? userConnections.ToList() 
            : new List<string>();
        return Task.FromResult(connections);
    }

    public Task<bool> HasConnectionsAsync(string userId)
    {
        return Task.FromResult(_connections.ContainsKey(userId) && _connections[userId].Any());
    }
}
```

## Client-Side Authentication

### JavaScript Client
```javascript
// Ensure user is authenticated before connecting
const connection = new signalR.HubConnectionBuilder()
    .withUrl("/chathub", {
        // For cookie authentication, credentials are sent automatically
        // For JWT, you might need to send the token in headers or query string
    })
    .build();

// Or for JWT authentication:
const connection = new signalR.HubConnectionBuilder()
    .withUrl("/chathub", {
        accessTokenFactory: () => {
            // Return the JWT token
            return localStorage.getItem('jwt-token');
        }
    })
    .build();
```

### .NET Client
```csharp
var connection = new HubConnectionBuilder()
    .WithUrl("https://localhost:5001/chathub", options =>
    {
        // For cookie authentication
        options.Cookies.Add(authCookie);
        
        // Or for JWT
        options.AccessTokenProvider = () => Task.FromResult(jwtToken);
    })
    .Build();
```

## Key Points About SignalR Authentication

1. **Context.UserIdentifier**: This is automatically populated from the authenticated user's `ClaimTypes.NameIdentifier` claim
2. **Hub-level Authorization**: Use `[Authorize]` attribute on the hub class or individual methods
3. **User Targeting**: `Clients.User(userId)` uses the `UserIdentifier` to target specific authenticated users
4. **Multiple Connections**: A single user can have multiple active connections (different tabs/devices)
5. **Connection Persistence**: Authentication context persists for the entire connection lifetime

The authentication integrates seamlessly with ASP.NET Core's existing authentication system, making it straightforward to secure your SignalR hubs while maintaining the same authentication patterns used throughout your application.