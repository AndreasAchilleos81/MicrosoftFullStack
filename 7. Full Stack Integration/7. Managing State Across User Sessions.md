# Blazor State Management: Local Storage and Session Storage

Being able to save state between sessions and even between application launches in a Blazor app is an important part of developing an application that has staying power and creates a better user experience. In this guide, we'll explore two different types of storage: **local storage** and **session storage**.

- **Local storage** allows you to save user information between app loads
- **Session storage** allows you to save user information between sessions

## Setup and Configuration

To use these storage options in your Blazor application, you'll need to add the required services to your `Program.cs` file:

```csharp
using Blazored.LocalStorage;
using Blazored.SessionStorage;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();
builder.Services.AddBlazoredLocalStorage();
builder.Services.AddBlazoredSessionStorage();

var app = builder.Build();
```

## Local Storage Implementation

Local storage saves data to the user's local machine. If the application restarts, it will read from that storage and return the data back to the user, even if they close their browser or the application.

### Example: Theme Switcher

Here's a complete example of a theme switcher using local storage:

```razor
@page "/"
@using Blazored.LocalStorage
@using Blazored.SessionStorage
@inject ILocalStorageService localStorage
@inject ISessionStorageService sessionStorage

<h3>Theme Switcher</h3>

<p>Current theme: @theme</p>

<button class="btn btn-primary" @onclick="ToggleTheme">Toggle Theme</button>
<button class="btn btn-secondary" @onclick="ClearStorage">Clear Storage</button>

@code {
    private string theme = "light";

    protected override async Task OnInitializedAsync()
    {
        // Check if theme exists in local storage
        var storedTheme = await localStorage.GetItemAsync<string>("userTheme");
        
        if (!string.IsNullOrEmpty(storedTheme))
        {
            theme = storedTheme;
        }
        else
        {
            theme = "light"; // Default theme
        }
    }

    private async Task ToggleTheme()
    {
        // Switch between light and dark themes
        theme = theme == "light" ? "dark" : "light";
        
        // Save the theme to local storage
        await localStorage.SetItemAsync("userTheme", theme);
    }

    private async Task ClearStorage()
    {
        // Clear all local storage data
        await localStorage.ClearAsync();
        await sessionStorage.ClearAsync();
        
        // Reset to default theme
        theme = "light";
    }
}
```

### Key Features of Local Storage:
- Data persists between browser sessions
- Data survives application restarts
- Data remains until explicitly cleared or browser data is cleared
- Perfect for user preferences, settings, and long-term data

## Session Storage Implementation

Session storage retains information only while the session is active (while the browser page is open). As soon as the browser page is closed, the data is erased.

### Example: Shopping Cart

Here's an example of a shopping cart using session storage:

```razor
@page "/cart"
@using Blazored.SessionStorage
@inject ISessionStorageService sessionStorage

<h3>Shopping Cart</h3>

<div class="mb-3">
    <input @bind="newItem" placeholder="Enter item name" class="form-control" />
    <button class="btn btn-success mt-2" @onclick="AddItem">Add Item</button>
</div>

<h4>Items in Cart:</h4>
<ul>
    @if (cartItems != null && cartItems.Any())
    {
        @foreach (var item in cartItems)
        {
            <li>@item</li>
        }
    }
    else
    {
        <li>No items in cart</li>
    }
</ul>

<p>Total items: @(cartItems?.Count ?? 0)</p>

@code {
    private string newItem = "";
    private List<string> cartItems = new List<string>();

    protected override async Task OnInitializedAsync()
    {
        // Retrieve cart items from session storage
        var storedCart = await sessionStorage.GetItemAsync<List<string>>("cart");
        
        if (storedCart != null)
        {
            cartItems = storedCart;
        }
    }

    private async Task AddItem()
    {
        if (!string.IsNullOrWhiteSpace(newItem))
        {
            cartItems.Add(newItem);
            
            // Save updated cart to session storage
            await sessionStorage.SetItemAsync("cart", cartItems);
            
            newItem = ""; // Clear input
        }
    }
}
```

### Key Features of Session Storage:
- Data persists only during the current session
- Data is lost when the browser tab/window is closed
- Perfect for temporary data like shopping carts, form data, or session-specific information
- Automatically clears when the session ends

## Storage Methods Summary

### Local Storage Methods:
```csharp
// Save data
await localStorage.SetItemAsync("key", value);

// Retrieve data
var data = await localStorage.GetItemAsync<T>("key");

// Check if key exists
bool exists = await localStorage.ContainKeyAsync("key");

// Remove specific item
await localStorage.RemoveItemAsync("key");

// Clear all data
await localStorage.ClearAsync();
```

### Session Storage Methods:
```csharp
// Save data
await sessionStorage.SetItemAsync("key", value);

// Retrieve data
var data = await sessionStorage.GetItemAsync<T>("key");

// Check if key exists
bool exists = await sessionStorage.ContainKeyAsync("key");

// Remove specific item
await sessionStorage.RemoveItemAsync("key");

// Clear all data
await sessionStorage.ClearAsync();
```

## When to Use Each Type

### Use Local Storage When:
- Storing user preferences (theme, language, settings)
- Saving application state that should persist across sessions
- Caching data that doesn't change frequently
- Storing user authentication tokens (with proper security considerations)

### Use Session Storage When:
- Storing temporary form data
- Managing shopping cart contents
- Saving wizard or multi-step form progress
- Storing session-specific application state

Both storage types provide excellent ways to enhance user experience in Blazor applications by maintaining state and reducing the need for users to re-enter information.