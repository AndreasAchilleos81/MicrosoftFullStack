# Blazor API Optimization: Complete Performance Guide

Efficient applications provide seamless experiences that keep users engaged. Optimizing your Blazor app's server communication can transform performance and reliability. This guide covers essential strategies for optimizing API calls in Blazor applications.

## Core Optimization Strategies

### 1. Caching API Responses

Caching temporarily stores API data to reduce unnecessary server requests, minimizing redundant calls while improving performance and user experience.

#### Basic Caching Implementation

```csharp
// Service for caching API responses
public class ApiCacheService
{
    private readonly HttpClient _httpClient;
    private readonly Dictionary<string, CacheItem> _cache;
    private readonly TimeSpan _defaultExpiration = TimeSpan.FromMinutes(10);

    public ApiCacheService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _cache = new Dictionary<string, CacheItem>();
    }

    public async Task<T> GetCachedDataAsync<T>(string endpoint, TimeSpan? expiration = null)
    {
        string cacheKey = $"{typeof(T).Name}_{endpoint}";
        
        // Check if data exists in cache and is still valid
        if (_cache.ContainsKey(cacheKey))
        {
            var cachedItem = _cache[cacheKey];
            if (DateTime.Now < cachedItem.ExpirationTime)
            {
                return (T)cachedItem.Data;
            }
            else
            {
                _cache.Remove(cacheKey); // Remove expired data
            }
        }

        // Fetch fresh data from API
        var response = await _httpClient.GetFromJsonAsync<T>(endpoint);
        
        // Cache the response
        _cache[cacheKey] = new CacheItem
        {
            Data = response,
            ExpirationTime = DateTime.Now.Add(expiration ?? _defaultExpiration)
        };

        return response;
    }
}

public class CacheItem
{
    public object Data { get; set; }
    public DateTime ExpirationTime { get; set; }
}
```

#### Weather Data Caching Example

```csharp
@page "/weather"
@inject ApiCacheService CacheService

<h3>Weather Forecast</h3>

@if (forecasts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Temperature</th>
                <th>Summary</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var forecast in forecasts)
            {
                <tr>
                    <td>@forecast.Date.ToShortDateString()</td>
                    <td>@forecast.TemperatureCÂ°C</td>
                    <td>@forecast.Summary</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync()
    {
        // Cache weather data for 30 minutes
        forecasts = await CacheService.GetCachedDataAsync<WeatherForecast[]>(
            "api/weather", 
            TimeSpan.FromMinutes(30)
        );
    }
}
```

#### Product List with Session-Based Caching

```csharp
public class ProductService
{
    private readonly ApiCacheService _cacheService;
    
    public ProductService(ApiCacheService cacheService)
    {
        _cacheService = cacheService;
    }

    public async Task<List<Product>> GetProductCategoriesAsync()
    {
        // Cache product categories for entire session
        return await _cacheService.GetCachedDataAsync<List<Product>>(
            "api/products/categories", 
            TimeSpan.FromHours(24)
        );
    }

    public async Task<List<Product>> GetLiveSportsScoresAsync()
    {
        // Update sports scores every minute
        return await _cacheService.GetCachedDataAsync<List<Product>>(
            "api/sports/scores", 
            TimeSpan.FromMinutes(1)
        );
    }
}
```

### 2. Pagination

Pagination divides large datasets into manageable chunks, preventing excessive data loading and improving performance.

#### Basic Pagination Component

```csharp
@page "/products"
@inject HttpClient Http

<h3>Product Reviews</h3>

<div class="reviews-container">
    @if (reviews != null)
    {
        @foreach (var review in reviews)
        {
            <div class="review-card">
                <h5>@review.Title</h5>
                <p>@review.Content</p>
                <small>Rating: @review.Rating/5</small>
            </div>
        }
    }
</div>

<div class="pagination-controls">
    <button class="btn btn-primary" @onclick="LoadPreviousPage" disabled="@(currentPage <= 1)">
        Previous
    </button>
    <span class="page-info">Page @currentPage of @totalPages</span>
    <button class="btn btn-primary" @onclick="LoadNextPage" disabled="@(currentPage >= totalPages)">
        Next
    </button>
</div>

@code {
    private List<ProductReview>? reviews;
    private int currentPage = 1;
    private int pageSize = 10;
    private int totalPages = 1;
    private int totalItems = 0;

    protected override async Task OnInitializedAsync()
    {
        await LoadReviewsAsync();
    }

    private async Task LoadReviewsAsync()
    {
        var response = await Http.GetFromJsonAsync<PaginatedResponse<ProductReview>>(
            $"api/reviews?page={currentPage}&size={pageSize}");
        
        reviews = response.Items;
        totalItems = response.TotalItems;
        totalPages = (int)Math.Ceiling((double)totalItems / pageSize);
    }

    private async Task LoadNextPage()
    {
        if (currentPage < totalPages)
        {
            currentPage++;
            await LoadReviewsAsync();
        }
    }

    private async Task LoadPreviousPage()
    {
        if (currentPage > 1)
        {
            currentPage--;
            await LoadReviewsAsync();
        }
    }
}
```

#### Photo Gallery with Scroll-Based Pagination

```csharp
@page "/gallery"
@inject HttpClient Http
@inject IJSRuntime JS

<div class="photo-gallery" @onscroll="HandleScroll">
    @if (photos != null)
    {
        @foreach (var photo in photos)
        {
            <div class="photo-item">
                <img src="@photo.ThumbnailUrl" alt="@photo.Title" />
                <p>@photo.Title</p>
            </div>
        }
    }
    
    @if (isLoading)
    {
        <div class="loading-spinner">Loading more photos...</div>
    }
</div>

@code {
    private List<Photo> photos = new();
    private int currentPage = 0;
    private int pageSize = 20;
    private bool isLoading = false;
    private bool hasMoreData = true;

    protected override async Task OnInitializedAsync()
    {
        await LoadMorePhotos();
    }

    private async Task LoadMorePhotos()
    {
        if (isLoading || !hasMoreData) return;

        isLoading = true;
        currentPage++;

        try
        {
            var newPhotos = await Http.GetFromJsonAsync<List<Photo>>(
                $"api/photos?page={currentPage}&size={pageSize}");
            
            if (newPhotos != null && newPhotos.Any())
            {
                photos.AddRange(newPhotos);
                hasMoreData = newPhotos.Count == pageSize;
            }
            else
            {
                hasMoreData = false;
            }
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task HandleScroll()
    {
        var scrollInfo = await JS.InvokeAsync<ScrollInfo>("getScrollInfo");
        
        // Load more when user scrolls near bottom
        if (scrollInfo.ScrollTop + scrollInfo.ClientHeight >= scrollInfo.ScrollHeight - 100)
        {
            await LoadMorePhotos();
        }
    }
}
```

### 3. Rate Limiting

Rate limiting controls API request frequency to prevent server overload and ensure fair resource usage.

#### Batch Request Implementation

```csharp
public class BatchRequestService
{
    private readonly HttpClient _httpClient;
    private readonly int _batchSize = 5;
    private readonly TimeSpan _batchDelay = TimeSpan.FromSeconds(1);

    public BatchRequestService(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    public async Task<List<ProfileImage>> LoadProfileImagesBatchAsync(List<int> userIds)
    {
        var allImages = new List<ProfileImage>();
        var batches = userIds.Chunk(_batchSize);

        foreach (var batch in batches)
        {
            // Process batch of requests
            var batchTasks = batch.Select(LoadSingleProfileImageAsync);
            var batchResults = await Task.WhenAll(batchTasks);
            
            allImages.AddRange(batchResults.Where(img => img != null));

            // Add delay between batches to respect rate limits
            await Task.Delay(_batchDelay);
        }

        return allImages;
    }

    private async Task<ProfileImage?> LoadSingleProfileImageAsync(int userId)
    {
        try
        {
            return await _httpClient.GetFromJsonAsync<ProfileImage>($"api/users/{userId}/profile-image");
        }
        catch (HttpRequestException)
        {
            return null; // Handle individual failures gracefully
        }
    }
}
```

#### Rate Limiting with Request Throttling

```csharp
public class ThrottledApiService
{
    private readonly HttpClient _httpClient;
    private readonly SemaphoreSlim _semaphore;
    private readonly int _maxRequestsPerMinute = 100;
    private readonly Queue<DateTime> _requestTimes;

    public ThrottledApiService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _semaphore = new SemaphoreSlim(_maxRequestsPerMinute, _maxRequestsPerMinute);
        _requestTimes = new Queue<DateTime>();
    }

    public async Task<T?> MakeThrottledRequestAsync<T>(string endpoint)
    {
        await _semaphore.WaitAsync();

        try
        {
            // Check if we're within rate limits
            if (!await CanMakeRequestAsync())
            {
                throw new RateLimitExceededException("Rate limit exceeded. Please try again later.");
            }

            // Record request time
            _requestTimes.Enqueue(DateTime.Now);

            // Make the actual request
            return await _httpClient.GetFromJsonAsync<T>(endpoint);
        }
        finally
        {
            _semaphore.Release();
        }
    }

    private async Task<bool> CanMakeRequestAsync()
    {
        var oneMinuteAgo = DateTime.Now.AddMinutes(-1);
        
        // Remove old requests from tracking
        while (_requestTimes.Count > 0 && _requestTimes.Peek() < oneMinuteAgo)
        {
            _requestTimes.Dequeue();
        }

        // Check if we can make another request
        if (_requestTimes.Count >= _maxRequestsPerMinute)
        {
            // Calculate wait time until next available slot
            var oldestRequest = _requestTimes.Peek();
            var waitTime = oldestRequest.AddMinutes(1) - DateTime.Now;
            
            if (waitTime > TimeSpan.Zero)
            {
                await Task.Delay(waitTime);
                return await CanMakeRequestAsync(); // Recursive check
            }
        }

        return true;
    }
}

public class RateLimitExceededException : Exception
{
    public RateLimitExceededException(string message) : base(message) { }
}
```

#### User-Friendly Rate Limiting Component

```csharp
@page "/api-demo"
@inject ThrottledApiService ApiService

<div class="api-demo">
    <button class="btn btn-primary" @onclick="MakeApiCall" disabled="@isLoading">
        @if (isLoading)
        {
            <span>Loading...</span>
        }
        else
        {
            <span>Fetch Data</span>
        }
    </button>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-warning mt-3">
            @errorMessage
            <button class="btn btn-sm btn-outline-primary ms-2" @onclick="RetryAfterDelay">
                Retry in @retryCountdown seconds
            </button>
        </div>
    }

    @if (data != null)
    {
        <div class="mt-3">
            <h5>Data Retrieved:</h5>
            <pre>@System.Text.Json.JsonSerializer.Serialize(data, new JsonSerializerOptions { WriteIndented = true })</pre>
        </div>
    }
</div>

@code {
    private bool isLoading = false;
    private string errorMessage = "";
    private object? data = null;
    private int retryCountdown = 0;

    private async Task MakeApiCall()
    {
        isLoading = true;
        errorMessage = "";

        try
        {
            data = await ApiService.MakeThrottledRequestAsync<object>("api/sample-data");
        }
        catch (RateLimitExceededException ex)
        {
            errorMessage = ex.Message;
            await StartRetryCountdown();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task StartRetryCountdown()
    {
        retryCountdown = 60; // Wait 60 seconds before retry
        
        while (retryCountdown > 0)
        {
            await Task.Delay(1000);
            retryCountdown--;
            StateHasChanged();
        }
        
        errorMessage = "";
    }

    private async Task RetryAfterDelay()
    {
        await Task.Delay(retryCountdown * 1000);
        await MakeApiCall();
    }
}
```

## Combined Optimization Strategy

```csharp
public class OptimizedDataService
{
    private readonly ApiCacheService _cacheService;
    private readonly ThrottledApiService _throttledService;
    private readonly int _pageSize = 20;

    public OptimizedDataService(ApiCacheService cacheService, ThrottledApiService throttledService)
    {
        _cacheService = cacheService;
        _throttledService = throttledService;
    }

    public async Task<PaginatedResponse<Product>> GetProductsOptimizedAsync(int page)
    {
        // Combine caching, pagination, and rate limiting
        string cacheKey = $"products_page_{page}";
        
        try
        {
            // First try cache
            var cachedData = await _cacheService.GetCachedDataAsync<PaginatedResponse<Product>>(
                $"api/products?page={page}&size={_pageSize}",
                TimeSpan.FromMinutes(5)
            );
            
            return cachedData;
        }
        catch (Exception)
        {
            // If cache fails, use throttled request
            return await _throttledService.MakeThrottledRequestAsync<PaginatedResponse<Product>>(
                $"api/products?page={page}&size={_pageSize}"
            );
        }
    }
}
```

## Key Benefits

1. **Reduced Server Load**: Caching and rate limiting minimize unnecessary requests
2. **Improved Performance**: Pagination and caching provide faster loading times
3. **Better User Experience**: Responsive interfaces with smooth data loading
4. **Resource Efficiency**: Optimal bandwidth usage and server resource management

These optimization strategies work together to create efficient, responsive Blazor applications that handle large datasets and high user loads while maintaining excellent performance and user experience.