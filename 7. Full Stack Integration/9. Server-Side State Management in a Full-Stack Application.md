# Blazor Server-Side State Management Lab Guide

## Overview

This lab demonstrates how to apply server-side state management strategies in a full-stack Blazor application, including session handling and caching techniques.

## Step 1: Creating the Application

### Create a New Blazor Server App

```bash
# Create a new Blazor Server application
dotnet new blazorserver -n BlazorServerApp

# Navigate to the project directory
cd BlazorServerApp

# Run the application to test
dotnet run
```

The application should start and be accessible at `https://localhost:5001` or `http://localhost:5000`.

## Step 2: Configuring Session Handling

Configure session middleware in `Program.cs` to manage user sessions with proper timeout and security settings.

### Program.cs Configuration

```csharp
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();

// Configure session services
builder.Services.AddSession(options =>
{
    // Set session idle timeout to 30 minutes
    options.IdleTimeout = TimeSpan.FromMinutes(30);
    
    // Set cookie to HTTP only for security
    options.Cookie.HttpOnly = true;
    
    // Additional security settings
    options.Cookie.IsEssential = true;
});


builder.Services.AddMemoryCache(); // Needs to be added for IMemoryCache to work
builder.Services.AddDistributedMemoryCache(); // Needs to be added for IMemoryCache to work
// Register the cache service
builder.Services.AddSingleton<CacheService>();

var app = builder.Build();

// Configure the HTTP request pipeline
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

// Enable session middleware
app.UseSession();

app.UseRouting();

app.MapRazorPages();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

app.Run();
```

### Session Configuration Explanation

- **IdleTimeout**: Session remains active for 30 minutes of inactivity
- **HttpOnly**: Prevents client-side JavaScript access to session cookies for security
- **IsEssential**: Marks the session cookie as essential for GDPR compliance

## Step 3: Setting Up Cache Service

Create a cache service that allows data to be stored server-side and reused across multiple client requests.

### CacheService.cs Implementation

```csharp
using Microsoft.Extensions.Caching.Memory;

public class CacheService
{
    private readonly IMemoryCache _cache;

    public CacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public T GetOrCreate<T>(string key, Func<T> createItem, TimeSpan expiration)
    {
        if (!_cache.TryGetValue(key, out T cachedItem))
        {
            // Item not in cache, create it
            cachedItem = createItem();
            
            // Set cache options with absolute expiration
            var cacheEntryOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = expiration
            };
            
            // Store item in cache
            _cache.Set(key, cachedItem, cacheEntryOptions);
        }
        
        return cachedItem;
    }

    public void Remove(string key)
    {
        _cache.Remove(key);
    }

    public bool TryGetValue<T>(string key, out T value)
    {
        return _cache.TryGetValue(key, out value);
    }
}
```

### Alternative Cache Service with Sliding Expiration

```csharp
using Microsoft.Extensions.Caching.Memory;

public class CacheService
{
    private readonly IMemoryCache _cache;

    public CacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public T GetOrCreate<T>(string key, Func<T> createItem, TimeSpan expiration, bool useSliding = false)
    {
        if (!_cache.TryGetValue(key, out T cachedItem))
        {
            cachedItem = createItem();
            
            var cacheEntryOptions = new MemoryCacheEntryOptions();
            
            if (useSliding)
            {
                // Sliding expiration - resets timer on each access
                cacheEntryOptions.SlidingExpiration = expiration;
            }
            else
            {
                // Absolute expiration - expires after fixed time
                cacheEntryOptions.AbsoluteExpirationRelativeToNow = expiration;
            }
            
            _cache.Set(key, cachedItem, cacheEntryOptions);
        }
        
        return cachedItem;
    }

    public async Task<T> GetOrCreateAsync<T>(string key, Func<Task<T>> createItemAsync, TimeSpan expiration)
    {
        if (!_cache.TryGetValue(key, out T cachedItem))
        {
            cachedItem = await createItemAsync();
            
            var cacheEntryOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = expiration
            };
            
            _cache.Set(key, cachedItem, cacheEntryOptions);
        }
        
        return cachedItem;
    }
}
```

## Step 4: Using the Cache Service in Components

### Example Weather Component

```razor
@page "/weather"
@inject CacheService CacheService
@inject IHttpContextAccessor HttpContextAccessor

<PageTitle>Weather</PageTitle>

<h1>Weather Forecast</h1>

<p>Data cached for 5 minutes. Last updated: @lastUpdated</p>

@if (forecasts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Temp. (C)</th>
                <th>Summary</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var forecast in forecasts)
            {
                <tr>
                    <td>@forecast.Date.ToShortDateString()</td>
                    <td>@forecast.TemperatureC</td>
                    <td>@forecast.Summary</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private WeatherForecast[]? forecasts;
    private DateTime lastUpdated;

    protected override async Task OnInitializedAsync()
    {
        // Get or create cached weather data with 5-minute expiration
        var cacheKey = "weather-forecast";
        var cacheExpiration = TimeSpan.FromMinutes(5);

        forecasts = CacheService.GetOrCreate(cacheKey, () => {
            lastUpdated = DateTime.Now;
            return GetWeatherData();
        }, cacheExpiration);
    }

    private WeatherForecast[] GetWeatherData()
    {
        var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
        
        return Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
    }

    public class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}
```

### Example Session Usage Component

```razor
@page "/session-demo"
@inject IHttpContextAccessor HttpContextAccessor
@implements IDisposable

<PageTitle>Session Demo</PageTitle>

<h1>Session Management Demo</h1>

<p>Session ID: @sessionId</p>
<p>Visit Count: @visitCount</p>
<p>Last Visit: @lastVisit</p>

<button class="btn btn-primary" @onclick="UpdateVisit">Update Visit</button>
<button class="btn btn-secondary" @onclick="ClearSession">Clear Session</button>

@code {
    private string sessionId = "";
    private int visitCount = 0;
    private string lastVisit = "";

    protected override void OnInitialized()
    {
        var session = HttpContextAccessor.HttpContext?.Session;
        
        if (session != null)
        {
            sessionId = session.Id;
            
            // Get visit count from session
            if (session.TryGetValue("VisitCount", out var countBytes))
            {
                visitCount = BitConverter.ToInt32(countBytes);
            }
            
            // Get last visit time
            lastVisit = session.GetString("LastVisit") ?? "Never";
            
            // Update visit count
            visitCount++;
            session.Set("VisitCount", BitConverter.GetBytes(visitCount));
            session.SetString("LastVisit", DateTime.Now.ToString());
        }
    }

    private void UpdateVisit()
    {
        var session = HttpContextAccessor.HttpContext?.Session;
        if (session != null)
        {
            visitCount++;
            session.Set("VisitCount", BitConverter.GetBytes(visitCount));
            session.SetString("LastVisit", DateTime.Now.ToString());
            lastVisit = DateTime.Now.ToString();
            StateHasChanged();
        }
    }

    private void ClearSession()
    {
        var session = HttpContextAccessor.HttpContext?.Session;
        if (session != null)
        {
            session.Clear();
            visitCount = 0;
            lastVisit = "Never";
            StateHasChanged();
        }
    }

    public void Dispose()
    {
        // Cleanup if needed
    }
}
```

## Required Using Statements

Add these to your `_Imports.razor`:

```razor
@using Microsoft.AspNetCore.Http
@using Microsoft.Extensions.Caching.Memory
@using System.ComponentModel.DataAnnotations
```

## Key Concepts

### Session Management
- **Timeout**: 30-minute idle timeout before session expires
- **Security**: HTTP-only cookies prevent XSS attacks
- **Storage**: Server-side session data storage

### Caching Strategy  
- **Memory Cache**: Fast in-memory storage for frequently accessed data
- **Expiration**: Absolute expiration based on creation time
- **Performance**: Reduces database/API calls for repeated requests

### Best Practices
1. Set appropriate session timeouts based on application needs
2. Use caching for expensive operations and frequently accessed data
3. Always configure HTTP-only cookies for security
4. Monitor memory usage with server-side caching
5. Implement proper error handling for session and cache operations

This lab provides a foundation for implementing robust state management in Blazor Server applications with both session handling and caching capabilities.