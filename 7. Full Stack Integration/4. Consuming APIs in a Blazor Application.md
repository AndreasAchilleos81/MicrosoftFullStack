# Consuming APIs in Blazor Applications

## Overview
This guide demonstrates how to consume APIs in a Blazor WebAssembly application using HTTP Client to retrieve data and bind it to UI components.

## Project Setup
The example uses a Blazor WebAssembly template created with:
```bash
dotnet new blazorwasm
```

## Complete Example: FetchData.razor

```razor
@page "/fetchdata"
@using System.Net.Http.Json
@inject HttpClient Http

<h3>Posts from API</h3>

@if (posts != null && posts.Any())
{
    <div>
        @foreach (var post in posts)
        {
            <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #ccc;">
                <h4>@post.Id - @post.Title</h4>
                <p>@post.Body</p>
            </div>
        }
    </div>
}
else
{
    <p>Loading...</p>
}

@code {
    private List<Post>? posts;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            posts = await Http.GetFromJsonAsync<List<Post>>("https://jsonplaceholder.typicode.com/posts");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
    }

    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Body { get; set; } = string.Empty;
    }
}
```

## Key Components Explained

### 1. Data Model
```csharp
public class Post
{
    public int Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
}
```

### 2. Data Binding
The application uses Blazor directives for conditional rendering and data iteration:
- `@if` directive for conditional display
- `@foreach` directive for iterating through the posts collection

### 3. Async Data Retrieval
```csharp
protected override async Task OnInitializedAsync()
{
    try
    {
        posts = await Http.GetFromJsonAsync<List<Post>>("https://jsonplaceholder.typicode.com/posts");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error fetching data: {ex.Message}");
    }
}
```

## Key Features

### Async Pattern Benefits
- **Background Processing**: Async methods allow multiple API calls to be queued and processed
- **Responsive UI**: The application remains responsive while making API calls
- **Non-blocking**: Uses `await` keyword to wait for requests to complete before proceeding

### Error Handling
The code implements a try-catch block to handle potential errors:
- Network failures
- Invalid endpoints (404 errors)
- API response issues

### HTTP Client Methods
- `GetFromJsonAsync<T>()`: Retrieves data from API and deserializes JSON response into specified type
- Automatically handles JSON deserialization
- Returns strongly-typed objects

## Testing Error Scenarios

To test error handling, you can modify the API URL to an invalid endpoint:
```csharp
// This will trigger a 404 error
posts = await Http.GetFromJsonAsync<List<Post>>("https://jsonplaceholder.typicode.com/invalid-endpoint");
```

The error will be logged to the browser console and can be viewed in Developer Tools.

## Best Practices

1. **Always use async/await** for API calls to maintain UI responsiveness
2. **Implement proper error handling** with try-catch blocks
3. **Show loading states** while data is being fetched
4. **Use strongly-typed models** to ensure type safety
5. **Inject HttpClient** using dependency injection
6. **Handle null states** appropriately in your UI

## API Endpoint Used
The example uses JSONPlaceholder (https://jsonplaceholder.typicode.com/posts), a free fake REST API service for testing and prototyping.