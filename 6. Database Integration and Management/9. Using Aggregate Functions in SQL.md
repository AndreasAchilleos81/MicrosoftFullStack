# SQL Aggregate Functions: Performing Calculations on Data

## Introduction

When working with large data sets, interpreting raw data can be overwhelming. Aggregate functions in SQL allow you to calculate sets of data into a single result, revealing patterns and trends that would be difficult to spot otherwise.

## What are Aggregate Functions?

**SQL aggregate functions** are functions that perform calculations on a set of values and return a single value. This single value is used to extract meaningful metrics and provide insights through summarization. Like other functions, they're often used in SELECT statements to summarize data.

## Sample Database Setup

Let's create a comprehensive music catalog table to demonstrate these functions:

```sql
CREATE TABLE music_catalog (
    song_id INT PRIMARY KEY,
    song_title VARCHAR(100),
    artist_name VARCHAR(100),
    genre VARCHAR(50),
    release_year INT,
    revenue DECIMAL(10,2),
    weekly_plays INT,
    duration_minutes DECIMAL(4,2),
    rating DECIMAL(3,1)
);

INSERT INTO music_catalog VALUES
(1, 'Bohemian Rhapsody', 'Queen', 'Rock', 1975, 2500000.00, 850000, 5.55, 9.8),
(2, 'Shape of You', 'Ed Sheeran', 'Pop', 2017, 3200000.00, 1200000, 3.53, 8.5),
(3, 'Hotel California', 'Eagles', 'Rock', 1976, 1800000.00, 720000, 6.30, 9.5),
(4, 'Billie Jean', 'Michael Jackson', 'Pop', 1983, 2800000.00, 950000, 4.54, 9.2),
(5, 'Smells Like Teen Spirit', 'Nirvana', 'Rock', 1991, 1500000.00, 680000, 5.01, 8.8),
(6, 'Rolling in the Deep', 'Adele', 'Pop', 2010, 2200000.00, 890000, 3.48, 9.0),
(7, 'Stairway to Heaven', 'Led Zeppelin', 'Rock', 1971, 3500000.00, 920000, 8.02, 9.9),
(8, 'Like a Rolling Stone', 'Bob Dylan', 'Folk', 1965, 1200000.00, 450000, 6.13, 9.3),
(9, 'What\'s Going On', 'Marvin Gaye', 'Soul', 1971, 800000.00, 380000, 3.52, 9.1),
(10, 'Imagine', 'John Lennon', 'Folk', 1971, 2000000.00, 750000, 3.07, 9.6);
```

## Core Aggregate Functions

### 1. COUNT Function

The **COUNT** function returns the number of rows that meet a specific condition, making it useful for determining how many entries satisfy certain criteria.

**Syntax:**
```sql
COUNT(*) -- Counts all rows including NULLs
COUNT(column_name) -- Counts non-NULL values in specified column
COUNT(DISTINCT column_name) -- Counts unique non-NULL values
```

**Basic COUNT Examples:**
```sql
-- Count total number of songs
SELECT COUNT(*) AS total_songs
FROM music_catalog;
```

**Result:**
```
total_songs
-----------
10
```

**Advanced COUNT Examples:**
```sql
-- Count songs by genre
SELECT 
    genre,
    COUNT(*) AS song_count
FROM music_catalog
GROUP BY genre;

-- Count songs with high ratings (above 9.0)
SELECT COUNT(*) AS highly_rated_songs
FROM music_catalog
WHERE rating > 9.0;

-- Count unique genres
SELECT COUNT(DISTINCT genre) AS unique_genres
FROM music_catalog;
```

**Results:**
```
-- Count by genre:
genre | song_count
------|------------
Folk  | 2
Pop   | 3
Rock  | 4
Soul  | 1

-- Highly rated songs: 6
-- Unique genres: 4
```

### 2. SUM Function

The **SUM** function provides the total of a column's values. Instead of counting entries only, SUM adds each value in the specified column to provide a total of all values.

**Syntax:**
```sql
SUM(column_name)
```

**Basic SUM Example:**
```sql
-- Calculate total revenue from all songs
SELECT SUM(revenue) AS total_revenue
FROM music_catalog;
```

**Result:**
```
total_revenue
-------------
21500000.00
```

**Advanced SUM Examples:**
```sql
-- Total revenue by genre
SELECT 
    genre,
    SUM(revenue) AS genre_revenue,
    COUNT(*) AS songs_in_genre
FROM music_catalog
GROUP BY genre
ORDER BY genre_revenue DESC;

-- Total weekly plays for rock songs
SELECT SUM(weekly_plays) AS total_rock_plays
FROM music_catalog
WHERE genre = 'Rock';

-- Calculate percentage of total revenue by genre
SELECT 
    genre,
    SUM(revenue) AS genre_revenue,
    ROUND(SUM(revenue) * 100.0 / (SELECT SUM(revenue) FROM music_catalog), 2) AS percentage_of_total
FROM music_catalog
GROUP BY genre;
```

### 3. AVG (AVERAGE) Function

The **AVG** function computes the average of all values in a numeric column by dividing the total by the number of entries, offering insights into overall performance.

**Syntax:**
```sql
AVG(column_name)
```

**Basic AVG Example:**
```sql
-- Calculate average revenue per song
SELECT AVG(revenue) AS average_revenue
FROM music_catalog;
```

**Result:**
```
average_revenue
---------------
2150000.00
```

**Advanced AVG Examples:**
```sql
-- Average statistics by genre
SELECT 
    genre,
    AVG(revenue) AS avg_revenue,
    AVG(weekly_plays) AS avg_plays,
    AVG(rating) AS avg_rating,
    AVG(duration_minutes) AS avg_duration
FROM music_catalog
GROUP BY genre
ORDER BY avg_revenue DESC;

-- Average rating for songs released after 1980
SELECT AVG(rating) AS avg_modern_rating
FROM music_catalog
WHERE release_year > 1980;

-- Compare average revenue: before vs after 1990
SELECT 
    CASE 
        WHEN release_year < 1990 THEN 'Before 1990'
        ELSE '1990 and After'
    END AS era,
    AVG(revenue) AS avg_revenue,
    COUNT(*) AS song_count
FROM music_catalog
GROUP BY 
    CASE 
        WHEN release_year < 1990 THEN 'Before 1990'
        ELSE '1990 and After'
    END;
```

### 4. MIN Function

The **MIN** function finds the smallest value in a specified column by directly retrieving the lowest value in your dataset.

**Syntax:**
```sql
MIN(column_name)
```

**Basic MIN Example:**
```sql
-- Find the lowest revenue generated by a song
SELECT MIN(revenue) AS lowest_revenue
FROM music_catalog;
```

**Result:**
```
lowest_revenue
--------------
800000.00
```

**Advanced MIN Examples:**
```sql
-- Find minimum values with details
SELECT 
    song_title,
    artist_name,
    revenue
FROM music_catalog
WHERE revenue = (SELECT MIN(revenue) FROM music_catalog);

-- Minimum statistics by genre
SELECT 
    genre,
    MIN(revenue) AS min_revenue,
    MIN(weekly_plays) AS min_plays,
    MIN(rating) AS min_rating
FROM music_catalog
GROUP BY genre;

-- Find oldest and newest songs
SELECT 
    'Oldest' AS category,
    MIN(release_year) AS year
FROM music_catalog
UNION
SELECT 
    'Newest' AS category,
    MAX(release_year) AS year
FROM music_catalog;
```
### UNION ###
What is SQL UNION?
The UNION operator is used in SQL to combine the results of two or more SELECT queries into a single result set. By default, it eliminates duplicate records, ensuring that each row in the final output is unique. If you want to include duplicates, you can use UNION ALL instead
###


### 5. MAX Function

The **MAX** function identifies the largest value in a column, helping you find peak performance or highest values.

**Syntax:**
```sql
MAX(column_name)
```

**Basic MAX Example:**
```sql
-- Find the highest weekly plays for a song
SELECT MAX(weekly_plays) AS highest_plays
FROM music_catalog;
```

**Result:**
```
highest_plays
-------------
1200000
```

**Advanced MAX Examples:**
```sql
-- Find the song with highest plays
SELECT 
    song_title,
    artist_name,
    weekly_plays,
    genre
FROM music_catalog
WHERE weekly_plays = (SELECT MAX(weekly_plays) FROM music_catalog);

-- Maximum statistics by genre
SELECT 
    genre,
    MAX(revenue) AS max_revenue,
    MAX(weekly_plays) AS max_plays,
    MAX(rating) AS max_rating,
    MAX(duration_minutes) AS longest_song
FROM music_catalog
GROUP BY genre;

-- Find top performer in each category
SELECT 'Highest Revenue' AS metric, song_title, artist_name, revenue AS value
FROM music_catalog
WHERE revenue = (SELECT MAX(revenue) FROM music_catalog)
UNION
SELECT 'Most Played' AS metric, song_title, artist_name, weekly_plays AS value
FROM music_catalog
WHERE weekly_plays = (SELECT MAX(weekly_plays) FROM music_catalog)
UNION
SELECT 'Highest Rated' AS metric, song_title, artist_name, rating AS value
FROM music_catalog
WHERE rating = (SELECT MAX(rating) FROM music_catalog);
```

+-----------------+--------------------+--------------+------------+
| metric          | song_title         | artist_name  | value      |
+-----------------+--------------------+--------------+------------+
| Highest Revenue | Stairway to Heaven | Led Zeppelin | 3500000.00 |
| Most Played     | Shape of You       | Ed Sheeran   | 1200000.00 |
| Highest Rated   | Stairway to Heaven | Led Zeppelin |       9.90 |
+-----------------+--------------------+--------------+------------+

## GROUP BY Clause

The **GROUP BY** clause groups rows with the same values in specified columns into summary rows, and is commonly used with aggregate functions.

### Basic GROUP BY Examples

```sql
-- Total revenue by genre
SELECT 
    genre,
    SUM(revenue) AS total_revenue
FROM music_catalog
GROUP BY genre;
```

**Result:**
```
genre | total_revenue
------|---------------
Folk  | 3200000.00
Pop   | 8200000.00
Rock  | 9300000.00
Soul  | 800000.00
```

### Advanced GROUP BY Examples

```sql
-- Comprehensive statistics by genre
SELECT 
    genre,
    COUNT(*) AS song_count,
    SUM(revenue) AS total_revenue,
    AVG(revenue) AS avg_revenue,
    MIN(revenue) AS min_revenue,
    MAX(revenue) AS max_revenue,
    AVG(rating) AS avg_rating
FROM music_catalog
GROUP BY genre
ORDER BY total_revenue DESC;

+-------+----------+---------------+-----------------+-----------------+-------------+----------------+
| genre | COUNT(*) | total_revenue | average_revenue | minimun_revenue | max_revenue | average_rating |
+-------+----------+---------------+-----------------+-----------------+-------------+----------------+
| Rock  |        4 |    9300000.00 |  2325000.000000 |      1500000.00 |  3500000.00 |        9.50000 |
| Pop   |        3 |    8200000.00 |  2733333.333333 |      2200000.00 |  3200000.00 |        8.90000 |
| Folk  |        2 |    3200000.00 |  1600000.000000 |      1200000.00 |  2000000.00 |        9.45000 |
| Soul  |        1 |     800000.00 |   800000.000000 |       800000.00 |   800000.00 |        9.10000 |
+-------+----------+---------------+-----------------+-----------------+-------------+----------------+
4 rows in set (0.002 sec)

-- Statistics by decade
SELECT 
    CASE 
        WHEN release_year < 1970 THEN '1960s'
        WHEN release_year < 1980 THEN '1970s'
        WHEN release_year < 1990 THEN '1980s'
        WHEN release_year < 2000 THEN '1990s'
        WHEN release_year < 2010 THEN '2000s'
        ELSE '2010s+'
    END AS decade,
    COUNT(*) AS songs,
    AVG(revenue) AS avg_revenue,
    AVG(rating) AS avg_rating
FROM music_catalog
GROUP BY 
    CASE 
        WHEN release_year < 1970 THEN '1960s'
        WHEN release_year < 1980 THEN '1970s'
        WHEN release_year < 1990 THEN '1980s'
        WHEN release_year < 2000 THEN '1990s'
        WHEN release_year < 2010 THEN '2000s'
        ELSE '2010s+'
    END
ORDER BY decade;
```

+--------+-------+----------------+------------+
| decade | songs | avg_revenue    | avg_rating |
+--------+-------+----------------+------------+
| 1960s  |     1 | 1200000.000000 |    9.30000 |
| 1970s  |     5 | 2120000.000000 |    9.58000 |
| 1980s  |     1 | 2800000.000000 |    9.20000 |
| 1990s  |     1 | 1500000.000000 |    8.80000 |
| 2010s+ |     2 | 2700000.000000 |    8.75000 |
+--------+-------+----------------+------------+


## HAVING Clause (Filtering Groups)

Use **HAVING** to filter results after grouping:

```sql
-- Genres with total revenue over 5 million
SELECT 
    genre,
    COUNT(*) AS song_count,
    SUM(revenue) AS total_revenue
FROM music_catalog
GROUP BY genre
HAVING SUM(revenue) > 5000000
ORDER BY total_revenue DESC;

-- Genres with average rating above 9.0
SELECT 
    genre,
    COUNT(*) AS song_count,
    AVG(rating) AS avg_rating
FROM music_catalog
GROUP BY genre
HAVING AVG(rating) > 9.0;
```

## Complex Aggregate Queries

### Multiple Grouping Levels
```sql
-- Statistics by genre and era
SELECT 
    genre,
    CASE 
        WHEN release_year < 1980 THEN 'Classic'
        ELSE 'Modern'
    END AS era,
    COUNT(*) AS songs,
    AVG(revenue) AS avg_revenue,
    SUM(weekly_plays) AS total_plays
FROM music_catalog
GROUP BY 
    genre,
    CASE 
        WHEN release_year < 1980 THEN 'Classic'
        ELSE 'Modern'
    END
ORDER BY genre, era;
```

+-------+---------+-------+----------------+-------------+
| genre | era     | songs | avg_revenue    | total_plays |
+-------+---------+-------+----------------+-------------+
| Folk  | Classic |     2 | 1600000.000000 |     1200000 |
| Pop   | Modern  |     3 | 2733333.333333 |     3040000 |
| Rock  | Classic |     3 | 2600000.000000 |     2490000 |
| Rock  | Modern  |     1 | 1500000.000000 |      680000 |
| Soul  | Classic |     1 |  800000.000000 |      380000 |
+-------+---------+-------+----------------+-------------+


### Subqueries with Aggregates
```sql
-- Songs performing above their genre average
SELECT 
    mc.song_title,
    mc.artist_name,
    mc.genre,
    mc.revenue,
    genre_avg.avg_revenue
FROM music_catalog mc
JOIN (
    SELECT 
        genre,
        AVG(revenue) AS avg_revenue
    FROM music_catalog
    GROUP BY genre
) genre_avg ON mc.genre = genre_avg.genre
WHERE mc.revenue > genre_avg.avg_revenue
ORDER BY mc.genre, mc.revenue DESC;
```

+--------------------+-----------------+-------+------------+----------------+
| song_title         | artist_name     | genre | revenue    | avg_revenue    |
+--------------------+-----------------+-------+------------+----------------+
| Imagine            | John Lennon     | Folk  | 2000000.00 | 1600000.000000 |
| Shape of You       | Ed Sheeran      | Pop   | 3200000.00 | 2733333.333333 |
| Billie Jean        | Michael Jackson | Pop   | 2800000.00 | 2733333.333333 |
| Stairway to Heaven | Led Zeppelin    | Rock  | 3500000.00 | 2325000.000000 |
| Bohemian Rhapsody  | Queen           | Rock  | 2500000.00 | 2325000.000000 |
+--------------------+-----------------+-------+------------+----------------+


### Window Functions with Aggregates
```sql
-- Running totals and rankings
SELECT 
    song_title,
    artist_name,
    genre,
    revenue,
    SUM(revenue) OVER (ORDER BY revenue DESC) AS running_total,
    RANK() OVER (ORDER BY revenue DESC) AS revenue_rank,
    RANK() OVER (PARTITION BY genre ORDER BY revenue DESC) AS genre_rank 
	-- RANK() AKA BRAKE IT INTO GROUPS/PARTITIONS IN ONE LINE AND IN THAT GROUP ORDER BY
FROM music_catalog
ORDER BY revenue DESC;
```



+-------------------------+-----------------+-------+------------+---------------+--------------+------------+
| song_title              | artist_name     | genre | revenue    | running_total | revenue_rank | genre_rank |
+-------------------------+-----------------+-------+------------+---------------+--------------+------------+
| Stairway to Heaven      | Led Zeppelin    | Rock  | 3500000.00 |    3500000.00 |            1 |          1 |
| Shape of You            | Ed Sheeran      | Pop   | 3200000.00 |    6700000.00 |            2 |          1 |
| Billie Jean             | Michael Jackson | Pop   | 2800000.00 |    9500000.00 |            3 |          2 |
| Bohemian Rhapsody       | Queen           | Rock  | 2500000.00 |   12000000.00 |            4 |          2 |
| Rolling in the Deep     | Adele           | Pop   | 2200000.00 |   14200000.00 |            5 |          3 |
| Imagine                 | John Lennon     | Folk  | 2000000.00 |   16200000.00 |            6 |          1 |
| Hotel California        | Eagles          | Rock  | 1800000.00 |   18000000.00 |            7 |          3 |
| Smells Like Teen Spirit | Nirvana         | Rock  | 1500000.00 |   19500000.00 |            8 |          4 |
| Like a Rolling Stone    | Bob Dylan       | Folk  | 1200000.00 |   20700000.00 |            9 |          2 |
| What's Going On         | Marvin Gaye     | Soul  |  800000.00 |   21500000.00 |           10 |          1 |
+-------------------------+-----------------+-------+------------+---------------+--------------+------------+

## Practical Business Applications

### Sales Dashboard Query
```sql
-- Executive summary dashboard
SELECT 
    'Total Songs' AS metric, COUNT(*)::TEXT AS value
FROM music_catalog
UNION ALL
SELECT 'Total Revenue', '$' || FORMAT(SUM(revenue), 'N0')
FROM music_catalog
UNION ALL
SELECT 'Average Rating', FORMAT(AVG(rating), 'N2')
FROM music_catalog
UNION ALL
SELECT 'Top Genre', genre
FROM (
    SELECT genre, SUM(revenue) as total
    FROM music_catalog
    GROUP BY genre
    ORDER BY total DESC
    LIMIT 1
) top;
```

### Performance Analysis
```sql
-- Identify underperforming high-rated songs
SELECT 
    song_title,
    artist_name,
    rating,
    revenue,
    weekly_plays,
    CASE 
        WHEN rating > 9.0 AND revenue < 2000000 THEN 'Underperforming Gem'
        WHEN rating > 9.0 AND revenue >= 2000000 THEN 'Successful Hit'
        WHEN rating <= 9.0 AND revenue >= 2000000 THEN 'Commercial Success'
        ELSE 'Moderate Performance'
    END AS performance_category
FROM music_catalog
ORDER BY rating DESC, revenue DESC;
```

+-------------------------+-----------------+--------+------------+--------------+----------------------+
| song_title              | artist_name     | rating | revenue    | weekly_plays | performance_category |
+-------------------------+-----------------+--------+------------+--------------+----------------------+
| Stairway to Heaven      | Led Zeppelin    |    9.9 | 3500000.00 |       920000 | Successful Hit       |
| Bohemian Rhapsody       | Queen           |    9.8 | 2500000.00 |       850000 | Successful Hit       |
| Imagine                 | John Lennon     |    9.6 | 2000000.00 |       750000 | Successful Hit       |
| Hotel California        | Eagles          |    9.5 | 1800000.00 |       720000 | Underperforming Gem  |
| Like a Rolling Stone    | Bob Dylan       |    9.3 | 1200000.00 |       450000 | Underperforming Gem  |
| Billie Jean             | Michael Jackson |    9.2 | 2800000.00 |       950000 | Successful Hit       |
| What's Going On         | Marvin Gaye     |    9.1 |  800000.00 |       380000 | Underperforming Gem  |
| Rolling in the Deep     | Adele           |    9.0 | 2200000.00 |       890000 | Commercial Success   |
| Smells Like Teen Spirit | Nirvana         |    8.8 | 1500000.00 |       680000 | Moderate Performance |
| Shape of You            | Ed Sheeran      |    8.5 | 3200000.00 |      1200000 | Commercial Success   |
+-------------------------+-----------------+--------+------------+--------------+----------------------+



## Key Points to Remember

- **COUNT(*)**: Counts all rows including NULLs
- **COUNT(column)**: Counts non-NULL values only
- **SUM**: Adds up all values in a numeric column
- **AVG**: Calculates the average of numeric values
- **MIN**: Finds the smallest value
- **MAX**: Finds the largest value
- **GROUP BY**: Groups rows for aggregate calculations
- **HAVING**: Filters groups after aggregation (use WHERE to filter before)
- Aggregate functions ignore NULL values (except COUNT(*))
- Always use meaningful aliases for aggregate results
- Combine functions for powerful insights

Keep experimenting with these functions, and you'll soon notice how powerful aggregate functions can be for any analysis task. They're essential tools for turning raw data into actionable business insights.