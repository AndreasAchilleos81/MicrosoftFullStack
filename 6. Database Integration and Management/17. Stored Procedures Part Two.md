TRY-CATCH blocks in SQL Server provide structured error handling for stored procedures and functions. Here's a comprehensive guide:

## Basic TRY-CATCH Syntax

```sql
BEGIN TRY
    -- Code that might cause an error
END TRY
BEGIN CATCH
    -- Error handling code
END CATCH
```

## Error Information Functions

Inside the CATCH block, you can use these functions to get error details:

```sql
BEGIN CATCH
    SELECT 
        ERROR_NUMBER() AS ErrorNumber,
        ERROR_SEVERITY() AS ErrorSeverity,
        ERROR_STATE() AS ErrorState,
        ERROR_LINE() AS ErrorLine,
        ERROR_PROCEDURE() AS ErrorProcedure,
        ERROR_MESSAGE() AS ErrorMessage;
END CATCH
```

## Examples in Stored Procedures

### Example 1: Basic Error Handling
```sql
CREATE PROCEDURE SafeUpdateProductPrice
    @ProductID INT,
    @NewPrice DECIMAL(10,2)
AS
BEGIN
    BEGIN TRY
        UPDATE Products 
        SET UnitPrice = @NewPrice
        WHERE ProductID = @ProductID;
        
        PRINT 'Product price updated successfully';
    END TRY
    BEGIN CATCH
        PRINT 'Error occurred: ' + ERROR_MESSAGE();
        PRINT 'Error Number: ' + CAST(ERROR_NUMBER() AS VARCHAR(10));
    END CATCH
END
```

### Example 2: Error Handling with OUTPUT Parameters
```sql
CREATE PROCEDURE CreateCustomerWithErrorHandling
    @CompanyName VARCHAR(100),
    @ContactName VARCHAR(50),
    @Email VARCHAR(100),
    @CustomerID INT OUTPUT,
    @ErrorCode INT OUTPUT,
    @ErrorMessage VARCHAR(500) OUTPUT
AS
BEGIN
    SET @CustomerID = 0;
    SET @ErrorCode = 0;
    SET @ErrorMessage = '';
    
    BEGIN TRY
        -- Validate input
        IF LEN(TRIM(@CompanyName)) = 0
        BEGIN
            SET @ErrorCode = 50001;
            SET @ErrorMessage = 'Company name cannot be empty';
            RETURN;
        END
        
        -- Check for duplicate email
        IF EXISTS (SELECT 1 FROM Customers WHERE Email = @Email)
        BEGIN
            SET @ErrorCode = 50002;
            SET @ErrorMessage = 'Email address already exists';
            RETURN;
        END
        
        -- Insert new customer
        INSERT INTO Customers (CompanyName, ContactName, Email, CreatedDate)
        VALUES (@CompanyName, @ContactName, @Email, GETDATE());
        
        SET @CustomerID = SCOPE_IDENTITY();
        SET @ErrorMessage = 'Customer created successfully';
        
    END TRY
    BEGIN CATCH
        SET @ErrorCode = ERROR_NUMBER();
        SET @ErrorMessage = ERROR_MESSAGE();
        SET @CustomerID = 0;
    END CATCH
END
```

**Usage:**
```sql
DECLARE @CustID INT, @ErrCode INT, @ErrMsg VARCHAR(500);

EXEC CreateCustomerWithErrorHandling
    @CompanyName = 'Test Corp',
    @ContactName = 'John Doe',
    @Email = 'john@testcorp.com',
    @CustomerID = @CustID OUTPUT,
    @ErrorCode = @ErrCode OUTPUT,
    @ErrorMessage = @ErrMsg OUTPUT;

IF @ErrCode = 0
    PRINT 'Success: Customer ID ' + CAST(@CustID AS VARCHAR(10)) + ' created'
ELSE
    PRINT 'Error ' + CAST(@ErrCode AS VARCHAR(10)) + ': ' + @ErrMsg;
```

### Example 3: Transaction Management with TRY-CATCH
```sql
CREATE PROCEDURE ProcessOrderWithTransaction
    @CustomerID INT,
    @ProductID INT,
    @Quantity INT,
    @OrderID INT OUTPUT,
    @Success BIT OUTPUT,
    @ErrorMessage VARCHAR(500) OUTPUT
AS
BEGIN
    SET @OrderID = 0;
    SET @Success = 0;
    SET @ErrorMessage = '';
    
    BEGIN TRANSACTION;
    
    BEGIN TRY
        -- Check product availability
        DECLARE @UnitsInStock INT, @UnitPrice DECIMAL(10,2);
        
        SELECT @UnitsInStock = UnitsInStock, @UnitPrice = UnitPrice
        FROM Products 
        WHERE ProductID = @ProductID;
        
        IF @UnitsInStock IS NULL
        BEGIN
            SET @ErrorMessage = 'Product not found';
            ROLLBACK TRANSACTION;
            RETURN;
        END
        
        IF @UnitsInStock < @Quantity
        BEGIN
            SET @ErrorMessage = 'Insufficient stock. Available: ' + CAST(@UnitsInStock AS VARCHAR(10));
            ROLLBACK TRANSACTION;
            RETURN;
        END
        
        -- Create order
        INSERT INTO Orders (CustomerID, OrderDate, Status)
        VALUES (@CustomerID, GETDATE(), 'Pending');
        
        SET @OrderID = SCOPE_IDENTITY();
        
        -- Add order details
        INSERT INTO OrderDetails (OrderID, ProductID, Quantity, UnitPrice)
        VALUES (@OrderID, @ProductID, @Quantity, @UnitPrice);
        
        -- Update inventory
        UPDATE Products 
        SET UnitsInStock = UnitsInStock - @Quantity
        WHERE ProductID = @ProductID;
        
        -- Log the transaction
        INSERT INTO OrderLog (OrderID, Action, ActionDate)
        VALUES (@OrderID, 'Order Created', GETDATE());
        
        COMMIT TRANSACTION;
        SET @Success = 1;
        SET @ErrorMessage = 'Order processed successfully';
        
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        SET @ErrorMessage = 'Transaction failed: ' + ERROR_MESSAGE() + 
                           ' (Line: ' + CAST(ERROR_LINE() AS VARCHAR(10)) + ')';
    END CATCH
END
```

### Example 4: Nested TRY-CATCH with Logging
```sql
CREATE PROCEDURE ComplexDataProcessing
    @BatchID INT,
    @ProcessedRecords INT OUTPUT
AS
BEGIN
    SET @ProcessedRecords = 0;
    DECLARE @ErrorCount INT = 0;
    
    BEGIN TRY
        -- Main processing loop
        DECLARE @RecordID INT;
        DECLARE record_cursor CURSOR FOR
            SELECT RecordID FROM DataToProcess WHERE BatchID = @BatchID;
        
        OPEN record_cursor;
        FETCH NEXT FROM record_cursor INTO @RecordID;
        
        WHILE @@FETCH_STATUS = 0
        BEGIN
            BEGIN TRY
                -- Process individual record
                EXEC ProcessSingleRecord @RecordID;
                SET @ProcessedRecords = @ProcessedRecords + 1;
                
            END TRY
            BEGIN CATCH
                -- Log individual record error but continue processing
                INSERT INTO ErrorLog (RecordID, ErrorMessage, ErrorDate)
                VALUES (@RecordID, ERROR_MESSAGE(), GETDATE());
                
                SET @ErrorCount = @ErrorCount + 1;
            END CATCH
            
            FETCH NEXT FROM record_cursor INTO @RecordID;
        END
        
        CLOSE record_cursor;
        DEALLOCATE record_cursor;
        
        -- Summary logging
        INSERT INTO ProcessingLog (BatchID, ProcessedRecords, ErrorCount, ProcessDate)
        VALUES (@BatchID, @ProcessedRecords, @ErrorCount, GETDATE());
        
    END TRY
    BEGIN CATCH
        -- Handle cursor cleanup in case of major error
        IF CURSOR_STATUS('global', 'record_cursor') >= -1
        BEGIN
            CLOSE record_cursor;
            DEALLOCATE record_cursor;
        END
        
        -- Log major error
        INSERT INTO ErrorLog (BatchID, ErrorMessage, ErrorDate, IsCritical)
        VALUES (@BatchID, ERROR_MESSAGE(), GETDATE(), 1);
        
        -- Re-throw the error
        THROW;
    END CATCH
END
```

## TRY-CATCH in Functions

**Important:** TRY-CATCH cannot be used directly in scalar functions, but can be used in table-valued functions and multi-statement table-valued functions.

### Example: Multi-Statement Table-Valued Function with TRY-CATCH
```sql
CREATE FUNCTION GetCustomerOrdersWithErrorHandling(@CustomerID INT)
RETURNS @OrderTable TABLE
(
    OrderID INT,
    OrderDate DATE,
    OrderTotal DECIMAL(10,2),
    ErrorMessage VARCHAR(255)
)
AS
BEGIN
    BEGIN TRY
        INSERT INTO @OrderTable (OrderID, OrderDate, OrderTotal, ErrorMessage)
        SELECT 
            o.OrderID,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice) as OrderTotal,
            NULL as ErrorMessage
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderID = od.OrderID
        WHERE o.CustomerID = @CustomerID
        GROUP BY o.OrderID, o.OrderDate;
        
    END TRY
    BEGIN CATCH
        INSERT INTO @OrderTable (OrderID, OrderDate, OrderTotal, ErrorMessage)
        VALUES (NULL, NULL, NULL, ERROR_MESSAGE());
    END CATCH
    
    RETURN;
END
```

## Advanced Error Handling Patterns

### Example 5: Custom Error Messages with THROW
```sql
CREATE PROCEDURE ValidatedCustomerUpdate
    @CustomerID INT,
    @CompanyName VARCHAR(100),
    @CreditLimit DECIMAL(10,2)
AS
BEGIN
    BEGIN TRY
        -- Business rule validation
        IF @CreditLimit < 0
        BEGIN
            THROW 50001, 'Credit limit cannot be negative', 1;
        END
        
        IF @CreditLimit > 1000000
        BEGIN
            THROW 50002, 'Credit limit cannot exceed $1,000,000', 1;
        END
        
        -- Check if customer exists
        IF NOT EXISTS (SELECT 1 FROM Customers WHERE CustomerID = @CustomerID)
        BEGIN
            THROW 50003, 'Customer not found', 1;
        END
        
        -- Perform update
        UPDATE Customers 
        SET CompanyName = @CompanyName, 
            CreditLimit = @CreditLimit,
            LastModified = GETDATE()
        WHERE CustomerID = @CustomerID;
        
        PRINT 'Customer updated successfully';
        
    END TRY
    BEGIN CATCH
        -- Log error details
        INSERT INTO ErrorLog (ProcedureName, ErrorNumber, ErrorMessage, ErrorDate)
        VALUES ('ValidatedCustomerUpdate', ERROR_NUMBER(), ERROR_MESSAGE(), GETDATE());
        
        -- Re-throw to caller
        THROW;
    END CATCH
END
```

### Example 6: Error Handling with RAISERROR (Legacy Method)
```sql
CREATE PROCEDURE LegacyErrorHandling
    @ProductID INT,
    @NewPrice DECIMAL(10,2)
AS
BEGIN
    BEGIN TRY
        IF @NewPrice <= 0
        BEGIN
            RAISERROR('Price must be greater than zero', 16, 1);
        END
        
        UPDATE Products 
        SET UnitPrice = @NewPrice
        WHERE ProductID = @ProductID;
        
        IF @@ROWCOUNT = 0
        BEGIN
            RAISERROR('Product ID %d not found', 16, 1, @ProductID);
        END
        
    END TRY
    BEGIN CATCH
        PRINT 'Error Number: ' + CAST(ERROR_NUMBER() AS VARCHAR(10));
        PRINT 'Error Message: ' + ERROR_MESSAGE();
        PRINT 'Error Severity: ' + CAST(ERROR_SEVERITY() AS VARCHAR(10));
        PRINT 'Error State: ' + CAST(ERROR_STATE() AS VARCHAR(10));
    END CATCH
END
```

## Best Practices

1. **Always handle transactions properly** in TRY-CATCH blocks
2. **Log errors** for debugging and monitoring
3. **Use OUTPUT parameters** to return success/failure status
4. **Clean up resources** (cursors, temp tables) in CATCH blocks
5. **Use THROW instead of RAISERROR** in newer SQL Server versions
6. **Test error scenarios** thoroughly
7. **Keep CATCH blocks focused** on error handling, not business logic

TRY-CATCH blocks make your stored procedures more robust and provide better error handling for applications that depend on your database procedures.


```
SET @CustomerID = SCOPE_IDENTITY(); 
```

retrieves the last identity value that was inserted in the current scope and assigns it to the @CustomerID variable.
What SCOPE_IDENTITY() Does
SCOPE_IDENTITY() returns the last identity value generated for any table with an identity column within the current execution scope (the current stored procedure, function, or batch). This is typically used right after an INSERT statement to get the auto-generated ID of the row you just inserted.