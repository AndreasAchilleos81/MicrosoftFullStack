# Relational Database Design: Core Principles and Examples

Have you ever wondered how large databases stay organized and efficient even as they grow in size and complexity? Understanding the principles behind relational database design is the key to creating systems that are scalable and maintainable.

Relational database design includes three core principles: **relationships**, **normalization**, and **constraints**. Let's explore each of these principles with practical examples.

## 1. Relationships

Relationships define how different tables in a database connect to each other. There are three common types: one-to-one, one-to-many, and many-to-many.

### One-to-One Relationship

A one-to-one relationship means that each record in one table corresponds to exactly one record in another. For example, if we kept track of special edition copies of books where each special edition is unique to a specific book:

```sql
-- Books table
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL
);

-- Special Editions table (one-to-one with Books)
CREATE TABLE Special_Editions (
    edition_id INT PRIMARY KEY,
    book_id INT UNIQUE,
    cover_type VARCHAR(50),
    limited_quantity INT,
    FOREIGN KEY (book_id) REFERENCES Books(book_id)
);
```

### One-to-Many Relationship

A one-to-many relationship is more common. One author can write many books, but each book typically only has one primary author. The Authors table and Books table are linked through a foreign key:

```sql
-- Authors table
CREATE TABLE Authors (
    author_id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    birth_date DATE,
    biography TEXT
);

-- Books table (many books can belong to one author)
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL,
    author_id INT,
    publication_year INT,
    price DECIMAL(10, 2),
    FOREIGN KEY (author_id) REFERENCES Authors(author_id)
);
```

### Many-to-Many Relationship

In a many-to-many relationship, multiple records in one table are related to multiple records in another. Many books can be written by many authors, and many authors can write multiple books. To represent this, we create a junction table:

```sql
-- Authors table
CREATE TABLE Authors (
    author_id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    birth_date DATE,
    biography TEXT
);

-- Books table
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL,
    publication_year INT,
    price DECIMAL(10, 2)
);

-- Junction table for many-to-many relationship
CREATE TABLE Book_Authors (
    book_id INT,
    author_id INT,
    contribution_type VARCHAR(50), -- e.g., 'primary', 'co-author', 'editor'
    PRIMARY KEY (book_id, author_id),
    FOREIGN KEY (book_id) REFERENCES Books(book_id),
    FOREIGN KEY (author_id) REFERENCES Authors(author_id)
);
```

**Junction tables** are database tables used to represent many-to-many relationships between two or more other tables. Each record in the junction table represents one connection between the related entities.

## 2. Normalization

Normalization is the process of organizing data into tables, columns, and relationships to minimize redundancy and improve data integrity. We typically follow three main stages of normalization, referred to as normal forms.

### First Normal Form (1NF)

**1NF** requires that each column in a table contains atomic (indivisible) values, meaning no repeated data within the same field.

**❌ Violates 1NF (multiple authors in one field):**
```sql
-- BAD: Multiple authors stored in a single field
CREATE TABLE Books_Bad (
    book_id INT PRIMARY KEY,
    title VARCHAR(255),
    authors VARCHAR(500) -- "John Smith, Jane Doe, Bob Wilson"
);
```

**✅ Follows 1NF (one author per row):**
```sql
-- GOOD: Each row contains atomic values
CREATE TABLE Books_1NF (
    book_id INT PRIMARY KEY,
    title VARCHAR(255),
    author_name VARCHAR(255)
);

-- If a book has multiple authors, create multiple rows
INSERT INTO Books_1NF VALUES 
(1, 'Database Design Fundamentals', 'John Smith'),
(2, 'Database Design Fundamentals', 'Jane Doe');
```

### Second Normal Form (2NF)

**2NF** eliminates partial dependencies, ensuring that non-primary key attributes are fully dependent on the primary key. To achieve 2NF, we create separate tables and use foreign keys:

```sql
-- Separate Authors table
CREATE TABLE Authors (
    author_id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

-- Books table with foreign key reference
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors(author_id)
);
```

### Third Normal Form (3NF)

**3NF** further reduces redundancy by ensuring that every piece of information in a table depends only on the primary key. This prevents storing details that don't directly relate to the table's main subject.

**❌ Violates 3NF (author details in Books table):**
```sql
-- BAD: Author biography stored in Books table
CREATE TABLE Books_Bad (
    book_id INT PRIMARY KEY,
    title VARCHAR(255),
    author_id INT,
    author_name VARCHAR(255),
    author_biography TEXT -- This depends on author_id, not book_id
);
```

**✅ Follows 3NF (clear separation of concerns):**
```sql
-- Authors table contains all author-specific information
CREATE TABLE Authors (
    author_id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    biography TEXT,
    birth_date DATE
);

-- Books table contains only book-specific information
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author_id INT,
    publication_year INT,
    FOREIGN KEY (author_id) REFERENCES Authors(author_id)
);
```

## 3. Constraints

Constraints are rules applied to data to ensure that it remains accurate and follows specific guidelines. Let's explore the most common types:

### NOT NULL Constraint

The NOT NULL constraint ensures that certain fields cannot be left empty:

```sql
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) NOT NULL, -- ISBN cannot be empty
    author_id INT,
    publication_year INT
);
```

### UNIQUE Constraint

The UNIQUE constraint ensures that all values in a specific column are different:

```sql
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL, -- No two books can share the same ISBN
    author_id INT
);
```

### CHECK Constraint

The CHECK constraint enforces a rule that data in a column must meet certain conditions:

```sql
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL,
    publication_year INT CHECK (publication_year > 1500), -- Must be after 1500
    price DECIMAL(10, 2) CHECK (price >= 0) -- Price cannot be negative
);
```

### DEFAULT Constraint

The DEFAULT constraint assigns a default value to a column if no value is specified:

```sql
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL,
    publication_year INT,
    price DECIMAL(10, 2) DEFAULT 10.00, -- Default price of $10.00
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Example: Complete Database Schema with All Constraints

```sql
-- Authors table
CREATE TABLE Authors (
    author_id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE,
    birth_date DATE,
    biography TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Books table
CREATE TABLE Books (
    book_id INT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) UNIQUE NOT NULL,
    publication_year INT CHECK (publication_year > 1500 AND publication_year <= YEAR(CURDATE())),
    price DECIMAL(10, 2) DEFAULT 10.00 CHECK (price >= 0),
    page_count INT CHECK (page_count > 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Junction table for many-to-many relationship
CREATE TABLE Book_Authors (
    book_id INT NOT NULL,
    author_id INT NOT NULL,
    role VARCHAR(50) DEFAULT 'Author',
    PRIMARY KEY (book_id, author_id),
    FOREIGN KEY (book_id) REFERENCES Books(book_id) ON DELETE CASCADE,
    FOREIGN KEY (author_id) REFERENCES Authors(author_id) ON DELETE CASCADE
);
```

## Conclusion

The principles of relational database design—**relationships**, **normalization**, and **constraints**—ensure efficient data storage, reduced redundancy, and maintain accuracy. Understanding these concepts enables you to create scalable databases that stay organized and maintain data integrity as they grow.

**Key Takeaways:**
- Use appropriate relationship types (one-to-one, one-to-many, many-to-many) based on your data requirements
- Apply normalization (1NF, 2NF, 3NF) to reduce redundancy and improve data integrity
- Implement constraints (NOT NULL, UNIQUE, CHECK, DEFAULT) to maintain data accuracy and consistency
- Junction tables are essential for representing many-to-many relationships effectively


Differnce between one to one vs one to many: The Critical Difference
One-to-Many: The foreign key column (author_id) has NO UNIQUE constraint

Multiple books can reference the same author
Same author_id value can appear in multiple rows

One-to-One: The foreign key column (book_id) has a UNIQUE constraint

Only one special edition can reference each book
Each book_id value can appear only once