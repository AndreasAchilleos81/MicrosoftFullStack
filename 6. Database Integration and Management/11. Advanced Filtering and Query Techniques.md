# Advanced SQL Filtering Techniques and Complex Queries Guide

## Introduction

In SQL, filtering data is one of the most important skills for getting useful information from a database. While simple queries are enough for basic tasks, real-world problems often need more advanced filtering methods. 

Advanced filtering techniques in SQL give you the power to refine your queries and retrieve data based on more complex conditions. These techniques include:

- Comparison operators
- Logical operators
- Pattern matching
- Conditional logic in WHERE clauses
- Aggregate filtering in the HAVING clause
- Complex joins and subqueries

## Comparison Operators

Comparison operators are the core tool in SQL filtering. They let you compare values like numbers, dates, or text so you can find exactly what you're looking for.

### Basic Comparison Operators

| Operator | Description | Example |
|----------|-------------|---------|
| `=` | Equal to | `salary = 50000` |
| `>` | Greater than | `salary > 100000` |
| `<` | Less than | `salary < 100000` |
| `>=` | Greater than or equal to | `salary >= 50000` |
| `<=` | Less than or equal to | `salary <= 50000` |
| `!=` or `<>` | Not equal to | `salary != 50000` |

### Comparison Operator Examples

```sql
-- Find employees with an exact salary of $50,000
SELECT employee_name, salary
FROM employees
WHERE salary = 50000;

-- Find employees who earn more than $100,000
SELECT employee_name, salary
FROM employees
WHERE salary > 100000;

-- Find employees with salaries less than $100,000
SELECT employee_name, salary
FROM employees
WHERE salary < 100000;

-- Find employees with salaries less than or equal to $50,000
SELECT employee_name, salary
FROM employees
WHERE salary <= 50000;

-- Find employees whose salary is not $50,000
SELECT employee_name, salary
FROM employees
WHERE salary <> 50000;

-- Working with dates
SELECT employee_name, hire_date
FROM employees
WHERE hire_date >= '2020-01-01';

-- Working with text (alphabetical comparison)
SELECT product_name, category
FROM products
WHERE category > 'Electronics'
ORDER BY category;
```

## Logical Operators

Logical operators allow you to combine or exclude conditions, enabling you to create more sophisticated filtering criteria.

### AND Operator

The AND operator requires **both** conditions to be true.

```sql
-- Find employees with more than 5 years of experience who work in IT
SELECT employee_name, years_experience, department
FROM employees
WHERE years_experience > 5 
  AND department = 'IT';

-- Multiple AND conditions
SELECT employee_name, salary, years_experience, department
FROM employees
WHERE salary > 75000 
  AND years_experience >= 3 
  AND department IN ('IT', 'Engineering');
```

### OR Operator

The OR operator requires **at least one** condition to be true.

```sql
-- Find employees either in IT or with more than 5 years of experience
SELECT employee_name, years_experience, department
FROM employees
WHERE department = 'IT' 
   OR years_experience > 5;

-- Complex OR conditions
SELECT employee_name, salary, department
FROM employees
WHERE salary > 100000 
   OR (department = 'Sales' AND years_experience > 3);
```

### NOT Operator

The NOT operator negates a condition.

```sql
-- Find employees not in the IT department
SELECT employee_name, department
FROM employees
WHERE NOT department = 'IT';

-- Equivalent to:
SELECT employee_name, department
FROM employees
WHERE department <> 'IT';

-- NOT with other operators
SELECT employee_name, salary
FROM employees
WHERE NOT (salary BETWEEN 40000 AND 80000);
```

### Combining Logical Operators

```sql
-- Complex logical combinations with parentheses for clarity
SELECT employee_name, department, salary, years_experience
FROM employees
WHERE (department = 'IT' OR department = 'Engineering') 
  AND (salary > 80000 OR years_experience > 7)
  AND NOT (years_experience < 2);
```

## Pattern Matching

Pattern matching allows you to search for partial matches or values within a set using flexible criteria.

### LIKE Operator with Wildcards

The LIKE operator uses wildcards to help you find data that follows a pattern.

| Wildcard | Description | Example |
|----------|-------------|---------|
| `%` | Matches any sequence of characters | `'John%'` matches "John", "Johnson", "Johnny" |
| `_` | Matches exactly one character | `'J_hn'` matches "John" but not "Johnson" |

```sql
-- Find employees with names starting with "John"
SELECT employee_name
FROM employees
WHERE employee_name LIKE 'John%';

-- Find employees with names ending with "son"
SELECT employee_name
FROM employees
WHERE employee_name LIKE '%son';

-- Find employees with names containing "anna"
SELECT employee_name
FROM employees
WHERE employee_name LIKE '%anna%';

-- Find employees with exactly 4-letter first names starting with 'J'
SELECT employee_name
FROM employees
WHERE employee_name LIKE 'J___';

-- Case-insensitive search (depending on database)
SELECT employee_name, email
FROM employees
WHERE LOWER(email) LIKE '%@gmail.com';
```

### IN Operator

The IN operator matches against a list of specific values.

```sql
-- Find employees in specific departments
SELECT employee_name, department
FROM employees
WHERE department IN ('IT', 'Finance', 'Marketing');

-- IN with numbers
SELECT product_name, price
FROM products
WHERE price IN (19.99, 29.99, 39.99);

-- IN with subquery
SELECT employee_name, department_id
FROM employees
WHERE department_id IN (
    SELECT department_id 
    FROM departments 
    WHERE budget > 500000
);

-- NOT IN to exclude values
SELECT employee_name, department
FROM employees
WHERE department NOT IN ('HR', 'Legal');
```

### BETWEEN Operator

```sql
-- Find employees with salaries between $50,000 and $100,000
SELECT employee_name, salary
FROM employees
WHERE salary BETWEEN 50000 AND 100000;

-- BETWEEN with dates
SELECT employee_name, hire_date
FROM employees
WHERE hire_date BETWEEN '2020-01-01' AND '2023-12-31';

-- NOT BETWEEN
SELECT employee_name, salary
FROM employees
WHERE salary NOT BETWEEN 40000 AND 80000;
```

## Conditional Logic with CASE Statements

The CASE statement adds programming logic into SQL, similar to IF-THEN statements in code.

### Basic CASE Statement

```sql
-- Classify employees based on experience
SELECT 
    employee_name,
    years_experience,
    CASE 
        WHEN years_experience < 2 THEN 'Junior'
        WHEN years_experience BETWEEN 2 AND 5 THEN 'Mid-level'
        WHEN years_experience > 5 THEN 'Senior'
        ELSE 'Unknown'
    END AS experience_level
FROM employees;
```

### Advanced CASE Examples

```sql
-- Salary bands with multiple conditions
SELECT 
    employee_name,
    department,
    salary,
    CASE 
        WHEN department = 'IT' AND salary > 100000 THEN 'Senior IT'
        WHEN department = 'IT' AND salary >= 70000 THEN 'Mid IT'
        WHEN department = 'IT' THEN 'Junior IT'
        WHEN salary > 120000 THEN 'Executive'
        WHEN salary > 80000 THEN 'Senior Staff'
        ELSE 'Staff'
    END AS role_category
FROM employees;

-- CASE in WHERE clause
SELECT employee_name, department, performance_rating
FROM employees
WHERE 
    CASE 
        WHEN department = 'Sales' THEN performance_rating > 8
        WHEN department = 'IT' THEN performance_rating > 7
        ELSE performance_rating > 6
    END;

-- CASE for calculations
SELECT 
    product_name,
    price,
    CASE 
        WHEN price > 100 THEN price * 0.1
        WHEN price > 50 THEN price * 0.05
        ELSE 0
    END AS discount_amount
FROM products;
```

## Aggregate Functions and HAVING Clause

Aggregate functions summarize data across multiple rows, and the HAVING clause filters these aggregated results.

### Common Aggregate Functions

```sql
-- Count total number of employees
SELECT COUNT(employee_id) as total_employees
FROM employees;

-- Count non-null values
SELECT COUNT(phone_number) as employees_with_phone
FROM employees;

-- Calculate average salary
SELECT AVG(salary) as average_salary
FROM employees;

-- Find minimum and maximum salaries
SELECT 
    MIN(salary) as lowest_salary,
    MAX(salary) as highest_salary
FROM employees;

-- Calculate total of all salaries
SELECT SUM(salary) as total_payroll
FROM employees;

-- Get unique count
SELECT COUNT(DISTINCT department) as number_of_departments
FROM employees;
```

### GROUP BY with Aggregate Functions

```sql
-- Count employees by department
SELECT 
    department,
    COUNT(employee_id) as employee_count,
    AVG(salary) as avg_salary
FROM employees
GROUP BY department;

-- Multiple grouping columns
SELECT 
    department,
    years_experience,
    COUNT(*) as count,
    AVG(salary) as avg_salary
FROM employees
GROUP BY department, years_experience
ORDER BY department, years_experience;
```

### HAVING Clause

The HAVING clause filters grouped results after aggregation (unlike WHERE, which filters before aggregation).

```sql
-- Find departments with more than 50 employees
SELECT 
    department,
    COUNT(employee_id) as employee_count
FROM employees
GROUP BY department
HAVING COUNT(employee_id) > 50;

-- Departments with average salary above $75,000
SELECT 
    department,
    AVG(salary) as avg_salary,
    COUNT(*) as employee_count
FROM employees
GROUP BY department
HAVING AVG(salary) > 75000;

-- Complex HAVING with multiple conditions
SELECT 
    department,
    AVG(salary) as avg_salary,
    COUNT(*) as employee_count,
    MAX(years_experience) as max_experience
FROM employees
GROUP BY department
HAVING COUNT(*) >= 10 
   AND AVG(salary) > 60000
   AND MAX(years_experience) > 5;

-- HAVING with CASE
SELECT 
    department,
    COUNT(*) as employee_count,
    SUM(CASE WHEN salary > 80000 THEN 1 ELSE 0 END) as high_earners
FROM employees
GROUP BY department
HAVING SUM(CASE WHEN salary > 80000 THEN 1 ELSE 0 END) > 5;
```

## Advanced Joins and Complex Queries

Advanced joins are useful when your queries require combining data from multiple sources or performing more intricate filtering.

### Multi-Table Joins

```sql
-- Join three tables: employees, departments, and projects
SELECT 
    e.employee_name,
    d.department_name,
    p.project_name,
    p.budget
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN employee_projects ep ON e.employee_id = ep.employee_id
JOIN projects p ON ep.project_id = p.project_id;

-- More complex multi-table join with filtering
SELECT 
    e.employee_name,
    d.department_name,
    p.project_name,
    p.budget,
    ep.role_in_project
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN employee_projects ep ON e.employee_id = ep.employee_id
JOIN projects p ON ep.project_id = p.project_id
WHERE p.budget > 100000
  AND d.department_name IN ('IT', 'Engineering')
  AND e.years_experience > 3;
```

### Subqueries in Joins

Using subqueries within joins allows you to filter data first and then join the results.

```sql
-- CORRECTED: Find employees working on high-budget projects
-- Method 1: Using proper JOIN relationships through bridge table
SELECT DISTINCT
    e.employee_name,
    e.salary,
    p.project_name,
    p.budget
FROM employees e
JOIN employee_projects ep ON e.employee_id = ep.employee_id
JOIN (
    SELECT project_id, project_name, budget
    FROM projects
    WHERE budget > 500000
) p ON ep.project_id = p.project_id;

-- Method 2: Simpler approach - filter in WHERE clause instead
SELECT DISTINCT
    e.employee_name,
    e.salary,
    p.project_name,
    p.budget
FROM employees e
JOIN employee_projects ep ON e.employee_id = ep.employee_id
JOIN projects p ON ep.project_id = p.project_id
WHERE p.budget > 500000;

-- Method 3: Using EXISTS (often more efficient)
SELECT 
    e.employee_name,
    e.department,
    e.salary
FROM employees e
WHERE EXISTS (
    SELECT 1 
    FROM employee_projects ep
    JOIN projects p ON ep.project_id = p.project_id
    WHERE ep.employee_id = e.employee_id 
      AND p.budget > 1000000
);
```

### CTEs with Complex Joins

Common Table Expressions help manage intermediate calculations before performing joins.

```sql
-- Calculate department averages and compare individual employees
WITH department_averages AS (
    SELECT 
        department_id,
        AVG(salary) as avg_department_salary,
        COUNT(*) as department_size
    FROM employees
    GROUP BY department_id
),
high_performers AS (
    SELECT employee_id, employee_name, department_id, salary
    FROM employees
    WHERE performance_rating > 8
)
SELECT 
    hp.employee_name,
    d.department_name,
    hp.salary,
    da.avg_department_salary,
    hp.salary - da.avg_department_salary AS salary_diff_from_avg,
    da.department_size
FROM high_performers hp
JOIN departments d ON hp.department_id = d.department_id
JOIN department_averages da ON hp.department_id = da.department_id
WHERE hp.salary > da.avg_department_salary
ORDER BY salary_diff_from_avg DESC;
```

### Window Functions for Advanced Analysis

```sql
-- Rank employees by salary within their department
SELECT 
    employee_name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank,
    AVG(salary) OVER (PARTITION BY department) as dept_avg_salary
FROM employees;

-- Running totals and comparisons
SELECT 
    employee_name,
    hire_date,
    salary,
    SUM(salary) OVER (ORDER BY hire_date) as running_total_payroll,
    LAG(salary) OVER (ORDER BY hire_date) as previous_hire_salary
FROM employees
ORDER BY hire_date;
```

|Name	|Hire Date	|Salary	|Running Total Payroll	|Previous Hire Salary|
|-------|-----------|-------|-----------------------|--------------------|
|Alice	|2015-01-01	|77,440	|77,440	                |        â€”           |
|Bob	|2015-06-30	|85,760	|163,200	            |77,440              |



## Combining Multiple Techniques

Here's an example that combines several advanced filtering techniques:

```sql
-- Complex query combining multiple techniques
WITH department_stats AS (
    SELECT 
        department_id,
        AVG(salary) as avg_salary,
        COUNT(*) as employee_count,
        MAX(years_experience) as max_experience
    FROM employees
    GROUP BY department_id
    HAVING COUNT(*) >= 5
),
categorized_employees AS (
    SELECT 
        e.employee_id,
        e.employee_name,
        e.department_id,
        e.salary,
        e.years_experience,
        CASE 
            WHEN e.years_experience < 2 THEN 'Junior'
            WHEN e.years_experience BETWEEN 2 AND 5 THEN 'Mid-level'
            ELSE 'Senior'
        END as experience_level
    FROM employees e
    WHERE e.salary BETWEEN 50000 AND 150000
      AND e.employee_name LIKE '%a%'
      AND e.department_id NOT IN (
          SELECT department_id 
          FROM departments 
          WHERE department_name = 'Temp'
      )
)
SELECT 
    ce.employee_name,
    d.department_name,
    ce.salary,
    ds.avg_salary,
    ce.experience_level,
    CASE 
        WHEN ce.salary > ds.avg_salary THEN 'Above Average'
        WHEN ce.salary = ds.avg_salary THEN 'Average'
        ELSE 'Below Average'
    END as salary_comparison
FROM categorized_employees ce
JOIN departments d ON ce.department_id = d.department_id
JOIN department_stats ds ON ce.department_id = ds.department_id
WHERE ce.experience_level IN ('Mid-level', 'Senior')
ORDER BY d.department_name, ce.salary DESC;
```

## Best Practices for Advanced Filtering

### Performance Optimization
```sql
-- Use indexes on frequently filtered columns
CREATE INDEX idx_employee_department ON employees(department);
CREATE INDEX idx_employee_salary ON employees(salary);
CREATE INDEX idx_employee_hire_date ON employees(hire_date);

-- Efficient filtering with proper operator precedence
SELECT employee_name, salary, department
FROM employees
WHERE department = 'IT' 
  AND (salary > 80000 OR years_experience > 5)
  AND hire_date >= '2020-01-01';
```

### Readable Query Structure
```sql
-- Well-formatted query with clear logic
SELECT 
    e.employee_name,
    e.salary,
    d.department_name
FROM employees e
    JOIN departments d ON e.department_id = d.department_id
WHERE 
    -- Salary criteria
    e.salary BETWEEN 60000 AND 120000
    
    -- Department criteria
    AND d.department_name IN ('IT', 'Engineering', 'Data Science')
    
    -- Experience criteria
    AND e.years_experience >= 2
    
    -- Exclude contractors
    AND e.employment_type = 'Full-time'
ORDER BY 
    d.department_name,
    e.salary DESC;
```

## Summary

Advanced filtering techniques in SQL provide powerful tools for extracting precise information from databases. Key concepts include:

1. **Comparison operators** for exact and range-based filtering
2. **Logical operators** (AND, OR, NOT) for combining conditions
3. **Pattern matching** with LIKE and wildcards for flexible text searching
4. **Conditional logic** with CASE statements for dynamic categorization
5. **Aggregate functions** with HAVING clauses for group-based filtering
6. **Complex joins** and **subqueries** for multi-table analysis
7. **CTEs** for breaking complex queries into manageable steps

As you practice these skills, you'll find that the ability to create complex queries will become a valuable tool for pulling the exact data you need, giving you more precision and confidence in your analysis.