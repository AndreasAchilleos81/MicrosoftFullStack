# Entity Framework Core: Creating and Configuring Entity Classes

Entity classes in EF Core are powerful tools that serve as the building blocks for working with databases in .NET applications. This guide explains how to create and configure entity classes using a company database example with Employee, Department, and Project entities.

## Setting Up Entity Classes

### 1. Project Structure

First, create a proper folder structure for your entities:

```
YourProject/
├── Models/
│   ├── Employee.cs
│   ├── Department.cs
│   └── Project.cs
└── Data/
    └── HrDbContext.cs
```

Most developers use a **Models** folder to store entity classes that represent database tables.

### 2. Creating Your First Entity

Create a new file `Employee.cs` in the Models folder:

```csharp
using System.ComponentModel.DataAnnotations;

namespace YourProject.Models
{
    public class Employee
    {
        public int EmployeeId { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime HireDate { get; set; }
        
        // Foreign Key
        public int DepartmentId { get; set; }
        
        // Navigation Property
        public Department Department { get; set; }
    }
}
```

## EF Core Conventions

EF Core uses **conventions** - automatic rules that save development time:

### Primary Key Convention
- Property named `Id` OR `{EntityName}Id` automatically becomes the primary key
- In our example: `EmployeeId` is automatically recognized as the primary key

### Column Mapping Convention
- Properties automatically map to columns with the same name
- `FirstName` property → `FirstName` column

## Establishing Relationships

### One-to-Many Relationship Example

**Employee.cs:**
```csharp
public class Employee
{
    public int EmployeeId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime HireDate { get; set; }
    
    // Foreign Key
    public int DepartmentId { get; set; }
    
    // Navigation Property (Many employees belong to one department)
    public Department Department { get; set; }
}
```

**Department.cs:**
```csharp
public class Department
{
    public int DepartmentId { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    
    // Navigation Property (One department has many employees)
    public ICollection<Employee> Employees { get; set; } = new List<Employee>();
}
```

### Many-to-Many Relationship Example

**Employee.cs (with Projects):**
```csharp
public class Employee
{
    public int EmployeeId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime HireDate { get; set; }
    public int DepartmentId { get; set; }
    
    public Department Department { get; set; }
    
    // Many-to-Many: Employee can work on multiple projects
    public ICollection<Project> Projects { get; set; } = new List<Project>();
}
```

**Project.cs:**
```csharp
public class Project
{
    public int ProjectId { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime? EndDate { get; set; }
    
    // Many-to-Many: Project can have multiple employees
    public ICollection<Employee> Employees { get; set; } = new List<Employee>();
}
```

## Configuration Methods

### Method 1: Data Annotations

Data Annotations are attributes applied directly to properties for simple configurations:

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

public class Employee
{
    [Key] // Explicitly declare primary key
    public int EmployeeId { get; set; }
    
    [Required] // Make field mandatory
    [StringLength(50)] // Limit string length
    public string FirstName { get; set; }
    
    [Required]
    [StringLength(50)]
    public string LastName { get; set; }
    
    [Required]
    public DateTime HireDate { get; set; }
    
    [Column("Salary", TypeName = "decimal(18,2)")] // Custom column mapping
    public decimal Salary { get; set; }
    
    public int DepartmentId { get; set; }
    public Department Department { get; set; }
}
```

**Common Data Annotations:**
- `[Key]` - Explicitly marks primary key
- `[Required]` - Makes field mandatory (NOT NULL)
- `[StringLength(n)]` - Sets maximum string length
- `[Column("name")]` - Maps to specific column name
- `[ForeignKey("PropertyName")]` - Defines foreign key relationship
- `[NotMapped]` - Excludes property from database mapping

### Method 2: Fluent API

Fluent API provides more flexibility and control through the `OnModelCreating` method:

**HrDbContext.cs:**
```csharp
using Microsoft.EntityFrameworkCore;
using YourProject.Models;

namespace YourProject.Data
{
    public class HrDbContext : DbContext
    {
        public HrDbContext(DbContextOptions<HrDbContext> options) : base(options)
        {
        }
        
        // DbSet properties map entities to tables
        public DbSet<Employee> Employees { get; set; }
        public DbSet<Department> Departments { get; set; }
        public DbSet<Project> Projects { get; set; }
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure Employee entity
            modelBuilder.Entity<Employee>(entity =>
            {
                // Primary Key (optional if following convention)
                entity.HasKey(e => e.EmployeeId);
                
                // Property configurations
                entity.Property(e => e.FirstName)
                    .IsRequired()
                    .HasMaxLength(50);
                
                entity.Property(e => e.LastName)
                    .IsRequired()
                    .HasMaxLength(50);
                
                entity.Property(e => e.HireDate)
                    .IsRequired();
                
                entity.Property(e => e.Salary)
                    .HasColumnType("decimal(18,2)")
                    .HasDefaultValue(0);
                
                // Relationship configuration
                entity.HasOne(e => e.Department)
                    .WithMany(d => d.Employees)
                    .HasForeignKey(e => e.DepartmentId)
                    .OnDelete(DeleteBehavior.Restrict);
            });
            
            // Configure Department entity
            modelBuilder.Entity<Department>(entity =>
            {
                entity.HasKey(d => d.DepartmentId);
                
                entity.Property(d => d.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                
                entity.Property(d => d.Description)
                    .HasMaxLength(500);
            });
            
            // Configure Many-to-Many relationship (Employee-Project)
            modelBuilder.Entity<Employee>()
                .HasMany(e => e.Projects)
                .WithMany(p => p.Employees)
                .UsingEntity(
                    "EmployeeProject", // Junction table name
                    l => l.HasOne(typeof(Project)).WithMany().HasForeignKey("ProjectId"),
                    r => r.HasOne(typeof(Employee)).WithMany().HasForeignKey("EmployeeId"),
                    j => j.HasKey("EmployeeId", "ProjectId"));
            
            base.OnModelCreating(modelBuilder);
        }
    }
}
```

## Complete Example with All Configurations

**Employee.cs (Clean version using Fluent API):**
```csharp
namespace YourProject.Models
{
    public class Employee
    {
        public int EmployeeId { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime HireDate { get; set; }
        public decimal Salary { get; set; }
        public int DepartmentId { get; set; }
        
        // Navigation Properties
        public Department Department { get; set; }
        public ICollection<Project> Projects { get; set; } = new List<Project>();
    }
}
```

## Key Benefits

### 1. **Convention Over Configuration**
- Automatic primary key detection
- Automatic column mapping
- Reduces boilerplate code

### 2. **Flexibility**
- Data Annotations for simple configurations
- Fluent API for complex scenarios
- Mix both approaches as needed

### 3. **Type Safety**
- Compile-time checking
- IntelliSense support
- Refactoring support

### 4. **Relationship Management**
- Automatic foreign key handling
- Navigation properties for easy data access
- Support for all relationship types

## Best Practices

1. **Use conventions when possible** - Let EF Core handle standard configurations automatically
2. **Choose the right configuration method**:
   - Data Annotations for simple, property-level rules
   - Fluent API for complex relationships and table-level configurations
3. **Initialize collections** - Always initialize navigation collection properties
4. **Use meaningful names** - Follow naming conventions for automatic recognition
5. **Separate concerns** - Keep entity classes clean, put complex configurations in `OnModelCreating`

This approach provides a solid foundation for building robust data models with Entity Framework Core, ensuring both maintainability and performance in your .NET applications.