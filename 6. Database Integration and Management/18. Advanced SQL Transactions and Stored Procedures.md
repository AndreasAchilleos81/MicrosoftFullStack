# MySQL Transactions and Stored Procedures Lab Guide

This lab demonstrates how to use the SQL query language to create transactions and stored procedures in MySQL using a sample database called EmployeeDB.

## Step 1: Database Setup

First, we need to access the MySQL prompt and create our database and table structure.

### Connect to MySQL
```bash
mysql -u root -p
# Enter your password when prompted
```

### Create Database and Table
```sql
-- Create the database
CREATE DATABASE EmployeeDB;

-- Use the database
USE EmployeeDB;

-- Create the Employees table
CREATE TABLE Employees (
    employee_id INT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE
);
```

### Populate with Sample Data
```sql
-- Insert sample employee records
INSERT INTO Employees (first_name, last_name, department, salary, hire_date) 
VALUES 
    ('John', 'Smith', 'Marketing', 55000.00, '2022-01-15'),
    ('Jane', 'Doe', 'Finance', 62000.00, '2021-03-22'),
    ('Mike', 'Johnson', 'IT', 68000.00, '2020-07-10'),
    ('Sarah', 'Wilson', 'HR', 52000.00, '2022-05-18'),
    ('David', 'Brown', 'Finance', 59000.00, '2021-11-08');

-- Verify the data
SELECT * FROM Employees;
```

## Step 2: Transaction and Concurrency Control

Setting transaction isolation levels and using transactions for data consistency.

### Set Transaction Isolation Level
```sql
-- Set isolation level to serializable (highest isolation level)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### Using Transactions for Salary Updates
```sql
-- Start a transaction
START TRANSACTION;

-- Decrease Marketing department salaries by $5,000
UPDATE Employees 
SET salary = salary - 5000 
WHERE department = 'Marketing';

-- Increase Finance department salaries by $5,000
UPDATE Employees 
SET salary = salary + 5000 
WHERE department = 'Finance';

-- At this point, changes are not yet permanent
-- You can verify with SELECT but changes are only visible in this session

-- Commit the changes to make them permanent
COMMIT;

-- Unlock tables if needed
UNLOCK TABLES;
```

**Alternative - Rolling Back Changes:**
```sql
START TRANSACTION;

UPDATE Employees 
SET salary = salary + 10000 
WHERE department = 'IT';

-- If you decide not to keep the changes
ROLLBACK;  -- This undoes all changes since START TRANSACTION
```

## Step 3: Advanced SELECT with Subqueries

Using subqueries to find employees earning above average salary.

```sql
-- Select employees with salary greater than average
SELECT first_name, last_name, salary
FROM Employees
WHERE salary > (
    SELECT AVG(salary) 
    FROM Employees
);
```

**Expected Output:**
```
+------------+-----------+----------+
| first_name | last_name | salary   |
+------------+-----------+----------+
| Jane       | Doe       | 67000.00 |
| Mike       | Johnson   | 68000.00 |
| David      | Brown     | 64000.00 |
+------------+-----------+----------+
```

## Step 4: Common Table Expressions (CTEs)

Creating temporary result sets for complex queries.

### Basic CTE - Department Salary Totals
```sql
-- Create a CTE to calculate total salary by department
WITH DepartmentSalaries AS (
    SELECT 
        department,
        SUM(salary) AS total_salary,
        COUNT(*) AS employee_count,
        AVG(salary) AS avg_salary
    FROM Employees
    GROUP BY department
)
SELECT 
    department,
    total_salary,
    employee_count,
    ROUND(avg_salary, 2) AS average_salary
FROM DepartmentSalaries
ORDER BY total_salary DESC;
```

**Expected Output:**
```
+------------+--------------+----------------+----------------+
| department | total_salary | employee_count | average_salary |
+------------+--------------+----------------+----------------+
| Finance    | 131000.00    | 2              | 65500.00       |
| IT         | 68000.00     | 1              | 68000.00       |
| HR         | 52000.00     | 1              | 52000.00       |
| Marketing  | 50000.00     | 1              | 50000.00       |
+------------+--------------+----------------+----------------+
```

### Advanced CTE - Ranking Employees
```sql
-- CTE to rank employees by salary within their department
WITH EmployeeRanking AS (
    SELECT 
        first_name,
        last_name,
        department,
        salary,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_in_dept,
        RANK() OVER (ORDER BY salary DESC) AS overall_rank
    FROM Employees
)
SELECT 
    first_name,
    last_name,
    department,
    salary,
    rank_in_dept,
    overall_rank
FROM EmployeeRanking
ORDER BY overall_rank;
```

## Step 5: Creating Stored Procedures

Stored procedures are reusable SQL programs that can accept parameters and perform operations.

### Basic Stored Procedure - Salary Adjustment
```sql
DELIMITER //

CREATE PROCEDURE AdjustSalary(
    IN department_name VARCHAR(50),
    IN adjustment_amount DECIMAL(10,2)
)
BEGIN
    UPDATE Employees 
    SET salary = salary + adjustment_amount 
    WHERE department = department_name;
    
    -- Return the number of affected rows
    SELECT ROW_COUNT() AS rows_affected;
    
    -- Show updated records
    SELECT first_name, last_name, department, salary
    FROM Employees
    WHERE department = department_name;
END //

DELIMITER ;
```

### Using the Stored Procedure
```sql
-- Increase IT department salaries by $3,000
CALL AdjustSalary('IT', 3000.00);

-- Decrease Marketing salaries by $1,000
CALL AdjustSalary('Marketing', -1000.00);
```

### Advanced Stored Procedure - Employee Management
```sql
DELIMITER //

CREATE PROCEDURE ManageEmployee(
    IN action_type VARCHAR(10),
    IN emp_id INT,
    IN f_name VARCHAR(50),
    IN l_name VARCHAR(50),
    IN dept VARCHAR(50),
    IN sal DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    CASE action_type
        WHEN 'INSERT' THEN
            INSERT INTO Employees (first_name, last_name, department, salary, hire_date)
            VALUES (f_name, l_name, dept, sal, CURDATE());
            
        WHEN 'UPDATE' THEN
            UPDATE Employees 
            SET first_name = f_name, last_name = l_name, 
                department = dept, salary = sal
            WHERE employee_id = emp_id;
            
        WHEN 'DELETE' THEN
            DELETE FROM Employees WHERE employee_id = emp_id;
            
        ELSE
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid action type';
    END CASE;
    
    COMMIT;
    
    -- Return confirmation
    SELECT CONCAT('Action ', action_type, ' completed successfully') AS result;
END //

DELIMITER ;
```

**Usage Examples:**
```sql
-- Add new employee
CALL ManageEmployee('INSERT', NULL, 'Alice', 'Cooper', 'IT', 72000.00);

-- Update existing employee
CALL ManageEmployee('UPDATE', 1, 'John', 'Smith', 'Sales', 60000.00);

-- Delete employee
CALL ManageEmployee('DELETE', 3, NULL, NULL, NULL, NULL);
```

## Step 6: Creating Functions

Functions return single values and can be used in queries like built-in functions.

### Basic Function - Calculate Bonus
```sql
DELIMITER //

CREATE FUNCTION CalculateBonus(salary DECIMAL(10,2))
RETURNS DECIMAL(10,2)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE bonus DECIMAL(10,2);
    SET bonus = salary * 0.001; -- 0.1% of salary
    RETURN bonus;
END //

DELIMITER ;
```

### Using the Function
```sql
-- Calculate bonus for all employees
SELECT 
    first_name,
    last_name,
    salary,
    CalculateBonus(salary) AS bonus_amount,
    salary + CalculateBonus(salary) AS total_compensation
FROM Employees;
```

### Advanced Function - Performance Rating
```sql
DELIMITER //

CREATE FUNCTION GetPerformanceRating(
    emp_salary DECIMAL(10,2),
    dept_name VARCHAR(50)
)
RETURNS VARCHAR(20)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE avg_dept_salary DECIMAL(10,2);
    DECLARE rating VARCHAR(20);
    
    -- Get average salary for the department
    SELECT AVG(salary) INTO avg_dept_salary
    FROM Employees
    WHERE department = dept_name;
    
    -- Determine rating based on comparison to department average
    IF emp_salary >= avg_dept_salary * 1.2 THEN
        SET rating = 'Excellent';
    ELSEIF emp_salary >= avg_dept_salary * 1.1 THEN
        SET rating = 'Above Average';
    ELSEIF emp_salary >= avg_dept_salary * 0.9 THEN
        SET rating = 'Average';
    ELSE
        SET rating = 'Below Average';
    END IF;
    
    RETURN rating;
END //

DELIMITER ;
```

**Usage:**
```sql
-- Get performance ratings for all employees
SELECT 
    first_name,
    last_name,
    department,
    salary,
    GetPerformanceRating(salary, department) AS performance_rating
FROM Employees
ORDER BY department, salary DESC;
```

## Step 7: Viewing Created Objects

### List All Procedures and Functions
```sql
-- View all stored procedures in current database
SHOW PROCEDURE STATUS WHERE Db = 'EmployeeDB';

-- View all functions in current database  
SHOW FUNCTION STATUS WHERE Db = 'EmployeeDB';

-- View procedure definition
SHOW CREATE PROCEDURE AdjustSalary;

-- View function definition
SHOW CREATE FUNCTION CalculateBonus;
```

### Dropping Procedures and Functions
```sql
-- Remove stored procedure
DROP PROCEDURE IF EXISTS AdjustSalary;

-- Remove function
DROP FUNCTION IF EXISTS CalculateBonus;
```

## Complete Example - Putting It All Together

```sql
-- Complete workflow example
USE EmployeeDB;

-- Start transaction for bulk operations
START TRANSACTION;

-- Use stored procedure to adjust salaries
CALL AdjustSalary('IT', 2000.00);

-- Use CTE and function together
WITH EnhancedEmployeeData AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        department,
        salary,
        CalculateBonus(salary) AS bonus,
        GetPerformanceRating(salary, department) AS rating
    FROM Employees
)
SELECT 
    first_name,
    last_name,
    department,
    salary,
    bonus,
    rating,
    salary + bonus AS total_compensation
FROM EnhancedEmployeeData
WHERE rating IN ('Excellent', 'Above Average')
ORDER BY total_compensation DESC;

-- Commit all changes
COMMIT;
```

## Key Takeaways

The SQL query language provides powerful tools for database management:

1. **Transactions** ensure data consistency and allow for rollback of changes
2. **CTEs** create temporary result sets for complex queries
3. **Stored Procedures** encapsulate business logic and can be reused
4. **Functions** perform calculations and return single values
5. **Isolation Levels** control how transactions interact with each other

These features make SQL a comprehensive language for both data manipulation and application logic implementation within the database layer.


```
DELIMITER $$

DELIMITER $$
CREATE PROCEDURE IncreaseSalary (
    IN deptName VARCHAR(50),
    IN increment DECIMAL(10, 2)
)
BEGIN
    IF increment <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Increment must be positive';
    END IF;

    UPDATE Employees
    SET Salary = Salary + increment
    WHERE Department = deptName;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Department not found';
    END IF;
END$$
DELIMITER ;


CALL IncreaseSalary("HR", 500);

```
#CREATE FUNCTION on MYSQL Terminal
```
CREATE FUNCTION CalculateBonus(salary DECIMAL(10,2)) RETURNS DECIMAL(10,2) DETERMINISTIC BEGIN RETURN (salary * 0.1) + salary; END$$


CREATE FUNCTION CalculateBonus(salary DECIMAL(10,2)) 
RETURNS DECIMAL(10,2) 
DETERMINISTIC 
BEGIN 
IF salary <= 0 THEN 
	RETURN -1;	
END IF;
RETURN (salary * 0.1) + salary; 
END;
$$


```