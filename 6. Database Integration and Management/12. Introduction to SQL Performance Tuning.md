# Introduction to SQL Performance Tuning

## Introduction

This reference guide outlines core techniques for optimizing SQL queries to enhance database performance and efficiency. Each technique is accompanied by practical examples to illustrate implementation.

## Key Techniques

### 1. Query Optimization

Analyzing and adjusting SQL queries to reduce execution time by optimizing syntax, indexing, and joins.

**Example - Inefficient Query:**
```sql
-- Poor: Using SELECT * and unnecessary joins
SELECT *
FROM customers c, orders o, products p
WHERE c.customer_id = o.customer_id
AND o.product_id = p.product_id
AND c.city = 'New York';
```

**Example - Optimized Query:**
```sql
-- Better: Select only needed columns and use explicit JOINs
SELECT c.customer_name, o.order_date, p.product_name
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN products p ON o.product_id = p.product_id
WHERE c.city = 'New York';
```

**Additional Optimization Examples:**

```sql
-- Use EXISTS instead of IN for better performance
-- Poor:
SELECT * FROM customers 
WHERE customer_id IN (SELECT customer_id FROM orders);

-- Better:
SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);
```

### 2. Indexing

Proper use of indexes, especially on frequently queried columns, can dramatically speed up retrieval but should be balanced to avoid unnecessary overhead on insertions and updates.

**Creating Effective Indexes:**
```sql
-- Single column index for frequently searched columns
CREATE INDEX idx_customer_email ON customers(email);

-- Composite index for multi-column searches
CREATE INDEX idx_order_date_status ON orders(order_date, status);

-- Partial index for specific conditions
CREATE INDEX idx_active_customers ON customers(customer_id) 
WHERE status = 'active';
```

**Index Usage Examples:**
```sql
-- This query will benefit from idx_customer_email
SELECT * FROM customers WHERE email = 'john@example.com';

-- This query will benefit from idx_order_date_status
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' AND status = 'shipped';
```

**When to Avoid Indexes:**
```sql
-- Don't create indexes on columns with low selectivity
-- Poor choice for indexing:
CREATE INDEX idx_gender ON customers(gender); -- Only 2-3 distinct values

-- Don't index columns that change frequently
-- Poor choice for heavy INSERT/UPDATE tables:
CREATE INDEX idx_last_modified ON audit_log(last_modified);
```

### 3. Execution Plans

Reviewing execution plans helps identify inefficient operations within a query, such as full table scans, which can be replaced with more efficient query patterns.

**Analyzing Execution Plans:**
```sql
-- PostgreSQL
EXPLAIN ANALYZE SELECT * FROM customers WHERE city = 'New York';

-- SQL Server
SET STATISTICS IO ON;
SELECT * FROM customers WHERE city = 'New York';

-- MySQL
EXPLAIN FORMAT=JSON SELECT * FROM customers WHERE city = 'New York';
```

**Common Issues Found in Execution Plans:**

```sql
-- Problem: Full table scan
-- This query might scan the entire table without an index
SELECT * FROM orders WHERE order_date = '2024-01-15';

-- Solution: Add appropriate index
CREATE INDEX idx_order_date ON orders(order_date);
```

```sql
-- Problem: Inefficient JOIN order
-- Large table joined first can be inefficient
SELECT c.customer_name, o.total_amount
FROM large_customer_table c
JOIN small_orders_table o ON c.customer_id = o.customer_id
WHERE o.order_date = '2024-01-15';

-- Solution: Filter early and use appropriate JOIN order
SELECT c.customer_name, o.total_amount
FROM small_orders_table o
JOIN large_customer_table c ON c.customer_id = o.customer_id
WHERE o.order_date = '2024-01-15';
```

What YOU Control (Syntax):

The table you write first in FROM table1 JOIN table2 is the LEFT table
The table after JOIN is the RIGHT table
This matters for LEFT JOIN and RIGHT JOIN results

```
-- Standard JOIN syntax
SELECT columns
FROM left_table          -- This is the LEFT table
JOIN right_table         -- This is the RIGHT table
ON left_table.id = right_table.id;

-- Alternative comma syntax (older style)
SELECT columns
FROM left_table,         -- First table listed
     right_table         -- Second table listed  
WHERE left_table.id = right_table.id;
```

### 4. Database Statistics

Keeping database statistics up-to-date aids the SQL optimizer in making the best choices for query plans.

**Updating Statistics:**
```sql
-- PostgreSQL
ANALYZE customers;
ANALYZE; -- All tables

-- SQL Server
UPDATE STATISTICS customers;
UPDATE STATISTICS customers WITH FULLSCAN;

-- MySQL
ANALYZE TABLE customers;
```

**Automated Statistics Updates:**
```sql
-- SQL Server - Enable auto-update statistics
ALTER DATABASE MyDatabase SET AUTO_UPDATE_STATISTICS ON;

-- PostgreSQL - Configure autovacuum
ALTER TABLE customers SET (autovacuum_analyze_scale_factor = 0.1);
```

### 5. Limiting Result Sets

Using filters and limiting result sets to only necessary data reduces memory and processing load, particularly in large databases.

**Effective Filtering Examples:**
```sql
-- Use LIMIT/TOP to restrict results
-- PostgreSQL/MySQL
SELECT customer_name, email FROM customers 
WHERE city = 'New York' 
ORDER BY customer_name 
LIMIT 100;

-- SQL Server
SELECT TOP 100 customer_name, email FROM customers 
WHERE city = 'New York' 
ORDER BY customer_name;
```

**Pagination Best Practices:**
```sql
-- Efficient pagination using OFFSET (for small offsets)
SELECT customer_id, customer_name FROM customers 
ORDER BY customer_id 
LIMIT 20 OFFSET 40;

-- Better pagination for large datasets using cursor-based approach
SELECT customer_id, customer_name FROM customers 
WHERE customer_id > 1000 
ORDER BY customer_id 
LIMIT 20;
```

**Filtering Early:**
```sql
-- Poor: Filtering after JOIN
SELECT c.customer_name, o.total_amount
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= '2024-01-01';

-- Better: Filter in subquery or use WHERE clause efficiently
SELECT c.customer_name, o.total_amount
FROM customers c
JOIN (
    SELECT customer_id, total_amount 
    FROM orders 
    WHERE order_date >= '2024-01-01'
) o ON c.customer_id = o.customer_id;
```

## Performance Testing Examples

**Measuring Query Performance:**
```sql
-- PostgreSQL timing
\timing on
SELECT COUNT(*) FROM large_table WHERE indexed_column = 'value';

-- SQL Server timing
SET STATISTICS TIME ON;
SELECT COUNT(*) FROM large_table WHERE indexed_column = 'value';

-- Compare before and after optimization
-- Before optimization:
-- Execution time: 2.5 seconds
-- After adding index:
-- Execution time: 0.05 seconds
```

## Best Practices Summary

1. **Always** select only the columns you need
2. **Use** appropriate WHERE clauses to filter data early
3. **Create** indexes on frequently queried columns
4. **Monitor** and update database statistics regularly
5. **Review** execution plans for performance bottlenecks
6. **Test** performance improvements with realistic data volumes
7. **Consider** the trade-offs between query performance and insert/update performance


# How to Force or Influence Index Usage in SQL

## Database-Specific Methods

### MySQL - Using INDEX Hints

MySQL provides explicit hints to force or suggest index usage:

```sql
-- Force a specific index
SELECT * FROM customers 
USE INDEX (idx_customer_email)
WHERE email = 'john@example.com';

-- Force a specific index (stronger hint)
SELECT * FROM customers 
FORCE INDEX (idx_customer_email)
WHERE email = 'john@example.com';

-- Ignore a specific index
SELECT * FROM customers 
IGNORE INDEX (idx_customer_name)
WHERE name = 'John Smith';

-- Use multiple indexes
SELECT * FROM orders 
USE INDEX (idx_order_date, idx_customer_id)
WHERE order_date >= '2024-01-01' AND customer_id = 123;

-- Use index for specific operation (JOIN, ORDER BY, GROUP BY)
SELECT * FROM customers c
USE INDEX FOR JOIN (idx_customer_id)
JOIN orders o ON c.customer_id = o.customer_id;
```

### SQL Server - Using Query Hints

```sql
-- Force a specific index using WITH (INDEX())
SELECT * FROM customers WITH (INDEX(idx_customer_email))
WHERE email = 'john@example.com';

-- Force multiple indexes
SELECT * FROM orders WITH (INDEX(idx_order_date, idx_customer_id))
WHERE order_date >= '2024-01-01' AND customer_id = 123;

-- Force index seek (no table scan)
SELECT * FROM customers WITH (FORCESEEK)
WHERE customer_id = 123;

-- Combine hints
SELECT * FROM customers WITH (INDEX(idx_customer_email), FORCESEEK)
WHERE email = 'john@example.com';
```

### PostgreSQL - Less Direct Control

PostgreSQL doesn't have explicit index hints, but you can influence the planner:

```sql
-- Disable sequential scans to encourage index usage
SET enable_seqscan = off;
SELECT * FROM customers WHERE email = 'john@example.com';
SET enable_seqscan = on; -- Re-enable afterwards

-- Adjust cost parameters to favor index scans
SET random_page_cost = 1.0; -- Default is usually 4.0
SELECT * FROM customers WHERE email = 'john@example.com';
RESET random_page_cost;

-- Use explicit conditions that match your index
-- If you have an index on (status, created_date)
SELECT * FROM orders 
WHERE status = 'active' AND created_date >= '2024-01-01'
ORDER BY status, created_date; -- Matches index order
```

### Oracle - Using Hints

```sql
-- Force index usage with /*+ INDEX */ hint
SELECT /*+ INDEX(customers idx_customer_email) */ 
* FROM customers 
WHERE email = 'john@example.com';

-- Use specific index for join
SELECT /*+ USE_NL(c o) INDEX(c idx_customer_id) */ 
c.customer_name, o.order_date
FROM customers c, orders o
WHERE c.customer_id = o.customer_id;
```

## Best Practices for Index Usage

### 1. Write Index-Friendly Queries

```sql
-- Good: Matches index structure
CREATE INDEX idx_order_status_date ON orders(status, order_date);

-- This query will use the index efficiently
SELECT * FROM orders 
WHERE status = 'shipped' 
AND order_date >= '2024-01-01';

-- This query will also use the index (leftmost prefix)
SELECT * FROM orders WHERE status = 'shipped';

-- Poor: Doesn't match index structure
SELECT * FROM orders WHERE order_date >= '2024-01-01'; -- Only uses partial index
```

### 2. Use Covering Indexes

```sql
-- Create a covering index (includes all needed columns)
CREATE INDEX idx_customer_covering 
ON customers(email) 
INCLUDE (customer_name, city, phone);

-- This query will use index-only scan
SELECT customer_name, city, phone 
FROM customers 
WHERE email = 'john@example.com';
```

### 3. Ensure Statistics Are Updated

```sql
-- Update statistics to help optimizer choose correct index
-- SQL Server
UPDATE STATISTICS customers;

-- PostgreSQL  
ANALYZE customers;

-- MySQL
ANALYZE TABLE customers;
```

## Verifying Index Usage

### Check Execution Plans

```sql
-- MySQL
EXPLAIN SELECT * FROM customers 
USE INDEX (idx_customer_email) 
WHERE email = 'john@example.com';

-- SQL Server
SET SHOWPLAN_ALL ON;
SELECT * FROM customers WITH (INDEX(idx_customer_email))
WHERE email = 'john@example.com';

-- PostgreSQL
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM customers WHERE email = 'john@example.com';
```

### Monitor Index Usage

```sql
-- SQL Server - Check index usage stats
SELECT 
    i.name AS index_name,
    s.user_seeks,
    s.user_scans,
    s.user_lookups
FROM sys.dm_db_index_usage_stats s
JOIN sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id
WHERE s.database_id = DB_ID() AND OBJECT_NAME(s.object_id) = 'customers';

-- PostgreSQL - Check index usage
SELECT 
    indexrelname AS index_name,
    idx_scan AS times_used,
    idx_tup_read AS tuples_read
FROM pg_stat_user_indexes 
WHERE relname = 'customers';
```

## Common Scenarios

### Force Index for Slow Queries

```sql
-- Original slow query
SELECT * FROM large_table WHERE some_column = 'value';

-- MySQL - Force index usage
SELECT * FROM large_table 
FORCE INDEX (idx_some_column)
WHERE some_column = 'value';

-- SQL Server - Force index usage  
SELECT * FROM large_table WITH (INDEX(idx_some_column))
WHERE some_column = 'value';
```

### Dealing with Complex WHERE Clauses

```sql
-- Create composite index
CREATE INDEX idx_complex ON orders(status, priority, created_date);

-- Force usage of the composite index
-- MySQL
SELECT * FROM orders 
USE INDEX (idx_complex)
WHERE status = 'pending' 
  AND priority = 'high' 
  AND created_date >= '2024-01-01';

-- SQL Server
SELECT * FROM orders WITH (INDEX(idx_complex))
WHERE status = 'pending' 
  AND priority = 'high' 
  AND created_date >= '2024-01-01';
```

## Important Warnings

⚠️ **Use hints sparingly**: Index hints can become outdated as data changes and may prevent the optimizer from choosing better execution plans.

⚠️ **Test thoroughly**: Always verify that forced index usage actually improves performance.

⚠️ **Keep statistics current**: Outdated statistics can cause poor index selection even with hints.

⚠️ **Consider maintenance**: Index hints make queries less portable between database systems.

## When NOT to Force Index Usage

- When the optimizer consistently chooses good plans
- In small tables where indexes don't provide benefit  
- When data distribution changes frequently
- For ad-hoc queries that won't be reused