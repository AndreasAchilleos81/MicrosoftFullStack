# SQL Subqueries and Common Table Expressions (CTEs) Guide

## Introduction

The use of subqueries and common table expressions (CTEs) in SQL can open new ways to manage complex data, giving you the power to seamlessly combine and filter results across multiple sources with precision. By combining SQL commands you've already learned with a few new query building strategies, these techniques can transform basic SQL into powerful tools for taking on complex data challenges.

Both subqueries and CTEs are advanced querying techniques that make complex data retrieval more manageable. They allow you to nest and organize SQL commands for powerful, layered results.

## Subqueries

### What is a Subquery?

A **subquery** is a query nested within another query. Subqueries are often used to filter data, calculate values, or join tables based on specific criteria.

### How Subqueries Work

In SQL, a subquery (also called an inner query) runs first and returns results that an outer query uses to further process or filter the data. Subqueries can be used in different parts of a SQL statement, including:

- SELECT clauses
- FROM clauses  
- WHERE clauses
- INSERT, UPDATE, or DELETE commands

### Subquery Operators

When working with subqueries, these operators are commonly used:

- **IN**: Check if a value exists in a list of results
- **ANY**: Compare against any value in the subquery results
- **ALL**: Compare against all values in the subquery results
- **=, >, <**: Standard comparison operators

### Subquery Example

Let's use a music catalog example. Suppose you want to find all songs by artists who have more than 1 million followers.

```sql
-- Find all songs by artists with more than 1 million followers
SELECT song_title 
FROM songs 
WHERE artist_id IN (
    SELECT artist_id 
    FROM artists 
    WHERE followers > 1000000
);
```

**How this works:**

1. **Inner query (subquery)** executes first:
   ```sql
   SELECT artist_id 
   FROM artists 
   WHERE followers > 1000000
   ```
   This returns a list of artist IDs for artists with more than 1 million followers.

2. **Outer query** then uses these results:
   ```sql
   SELECT song_title 
   FROM songs 
   WHERE artist_id IN (...)
   ```
   This selects song titles only for artists whose IDs match those from the subquery.

### Additional Subquery Examples

```sql
-- Find artists with above-average follower counts
SELECT artist_name, followers
FROM artists
WHERE followers > (
    SELECT AVG(followers) 
    FROM artists
);

-- Find songs that are more popular than any song by 'Artist X'
SELECT song_title, popularity
FROM songs
WHERE popularity > ANY (
    SELECT popularity 
    FROM songs s
    JOIN artists a ON s.artist_id = a.artist_id
    WHERE a.artist_name = 'Artist X'
);

-- Find artists who have more followers than all indie artists
SELECT artist_name, followers
FROM artists
WHERE followers > ALL (
    SELECT followers 
    FROM artists 
    WHERE genre = 'Indie'
);
```

## Common Table Expressions (CTEs)

### What is a CTE?

A **Common Table Expression (CTE)** is a temporary result set that can be referenced multiple times within a single SQL statement. CTEs can be thought of as temporary tables that exist only for the duration of the query.

### Benefits of CTEs

- Break down complex queries into smaller, manageable parts
- Improve readability and clarity of query structure
- Allow referencing the same result set multiple times
- Make queries easier to maintain and debug

### CTE Syntax

CTEs are defined using the **WITH** clause:

```sql
WITH cte_name AS (
    -- CTE query definition
    SELECT columns...
    FROM tables...
    WHERE conditions...
)
-- Main query that uses the CTE
SELECT columns...
FROM cte_name...
```

### CTE Example

Building on our previous example, let's calculate the average popularity score for songs by artists with more than a million followers, then use this to exclude songs below the threshold.

```sql
-- Step 1: Create CTE for popular artists with their average song popularity
WITH popular_artists AS (
    SELECT 
        s.artist_id,
        AVG(s.popularity) AS avg_popularity
    FROM songs s
    WHERE s.artist_id IN (
        SELECT artist_id 
        FROM artists 
        WHERE followers > 1000000
    )
    GROUP BY s.artist_id
)

-- Step 2: Use the CTE in main query
SELECT 
    s.song_id,
    s.song_title,
    s.popularity
FROM songs s
JOIN popular_artists pa ON s.artist_id = pa.artist_id
WHERE s.popularity >= pa.avg_popularity;
```

### Advanced CTE Examples

#### Multiple CTEs
```sql
WITH 
high_follower_artists AS (
    SELECT artist_id, artist_name, followers
    FROM artists
    WHERE followers > 1000000
),
popular_songs AS (
    SELECT song_id, song_title, artist_id, popularity
    FROM songs
    WHERE popularity > 80
)
SELECT 
    hfa.artist_name,
    ps.song_title,
    ps.popularity,
    hfa.followers
FROM high_follower_artists hfa
JOIN popular_songs ps ON hfa.artist_id = ps.artist_id
ORDER BY ps.popularity DESC;
```

#### Recursive CTE (for hierarchical data)
```sql
-- Example: Find all employees and their management chain
WITH employee_hierarchy AS (
    -- Base case: Top-level managers
    SELECT employee_id, employee_name, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: Employees with managers
    SELECT e.employee_id, e.employee_name, e.manager_id, eh.level + 1
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT employee_id, employee_name, level
FROM employee_hierarchy
ORDER BY level, employee_name;
```
The above first query of employee_hierarchy returns the head manager who no-ones manages
-- Result:
1 | Alice | NULL | level = 1

Then the JOIN finds the employees/manger under Alice and we repeat.
Now we wil have Alice, Bod and Carol and they will return Dave and Eve and so on


Sample Data:
employee_id	employee_name	manager_id
1				Alice		NULL
2				Bob			1
3				Carol		1
4				Dave		2
5				Eve			2
6				Frank		4




## When to Use Subqueries vs CTEs

### Use Subqueries When:
- You need a simple, single-use query
- The logic is straightforward and doesn't need to be reused
- You're working with smaller, less complex operations
- The subquery result is used only once

### Use CTEs When:
- You need to reference the same result set multiple times
- You want to break down complex queries into readable parts
- You need to improve query maintainability
- You're working with recursive relationships
- You want to create a logical flow in your query structure

## Performance Considerations

```sql
-- Subquery example - may execute multiple times
SELECT artist_name
FROM artists a
WHERE EXISTS (
    SELECT 1 
    FROM songs s 
    WHERE s.artist_id = a.artist_id 
    AND s.popularity > 90
);

-- CTE example - executes once and stores result
WITH top_songs AS (
    SELECT DISTINCT artist_id
    FROM songs
    WHERE popularity > 90
)
SELECT artist_name
FROM artists a
JOIN top_songs ts ON a.artist_id = ts.artist_id;
```

## Best Practices

1. **Use meaningful names** for CTEs and subqueries
2. **Add comments** to explain complex logic
3. **Test performance** - sometimes CTEs can be slower than subqueries
4. **Keep it readable** - break complex queries into logical parts
5. **Use aliases** to make joins and references clearer

## Summary

Mastering subqueries and CTEs can significantly elevate your SQL skills and enhance your ability to write efficient, maintainable queries. Subqueries work well for simpler or single-use scenarios, while CTEs excel when you need to reuse results, break down complexity, or improve readability. Both techniques are essential tools for handling complex data challenges in SQL.