# SQL Server TSQL Pagination Guide

## Modern Pagination Methods (SQL Server 2012+)

### 1. OFFSET and FETCH (Recommended)

The standard and most efficient way to implement pagination in modern SQL Server.

```sql
-- Basic OFFSET/FETCH syntax
SELECT CustomerID, CompanyName, ContactName
FROM Customers
ORDER BY CompanyName  -- ORDER BY is required for OFFSET/FETCH
OFFSET 20 ROWS        -- Skip first 20 rows  
FETCH NEXT 10 ROWS ONLY;  -- Return next 10 rows

-- Page 1 (rows 1-10)
SELECT CustomerID, CompanyName, ContactName
FROM Customers
ORDER BY CompanyName
OFFSET 0 ROWS
FETCH NEXT 10 ROWS ONLY;

-- Page 2 (rows 11-20) 
SELECT CustomerID, CompanyName, ContactName
FROM Customers
ORDER BY CompanyName
OFFSET 10 ROWS
FETCH NEXT 10 ROWS ONLY;

-- Page 3 (rows 21-30)
SELECT CustomerID, CompanyName, ContactName
FROM Customers  
ORDER BY CompanyName
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;
```

### 2. Parameterized Pagination Function

```sql
-- Create a parameterized pagination procedure
CREATE PROCEDURE GetCustomersPaged
    @PageNumber INT = 1,
    @PageSize INT = 10,
    @SortColumn NVARCHAR(50) = 'CompanyName',
    @SortDirection NVARCHAR(4) = 'ASC'
AS
BEGIN
    DECLARE @Offset INT = (@PageNumber - 1) * @PageSize;
    
    -- Dynamic SQL for flexible sorting
    DECLARE @SQL NVARCHAR(MAX) = '
        SELECT CustomerID, CompanyName, ContactName, City, Country
        FROM Customers
        ORDER BY ' + @SortColumn + ' ' + @SortDirection + '
        OFFSET @Offset ROWS
        FETCH NEXT @PageSize ROWS ONLY';
    
    EXEC sp_executesql @SQL, 
         N'@Offset INT, @PageSize INT', 
         @Offset, @PageSize;
END

-- Usage examples
EXEC GetCustomersPaged @PageNumber = 1, @PageSize = 10;
EXEC GetCustomersPaged @PageNumber = 3, @PageSize = 5, @SortColumn = 'City';
```

## Getting Total Count with Pagination

### Method 1: Separate COUNT Query

```sql
-- Get total count first
DECLARE @TotalRows INT;
SELECT @TotalRows = COUNT(*) FROM Customers WHERE Country = 'USA';

-- Get paginated results
SELECT CustomerID, CompanyName, ContactName,
       @TotalRows as TotalRows
FROM Customers
WHERE Country = 'USA'
ORDER BY CompanyName
OFFSET 0 ROWS
FETCH NEXT 10 ROWS ONLY;
```

### Method 2: Using WINDOW Functions

```sql
-- Get count and data in single query
SELECT CustomerID, CompanyName, ContactName,
       COUNT(*) OVER() as TotalRows  -- Total count for all matching rows
FROM Customers
WHERE Country = 'USA'
ORDER BY CompanyName
OFFSET 0 ROWS
FETCH NEXT 10 ROWS ONLY;
```

### Method 3: Complete Pagination Info

```sql
DECLARE @PageNumber INT = 2;
DECLARE @PageSize INT = 10;
DECLARE @Offset INT = (@PageNumber - 1) * @PageSize;

SELECT 
    CustomerID, 
    CompanyName, 
    ContactName,
    -- Pagination metadata
    COUNT(*) OVER() as TotalRows,
    @PageNumber as CurrentPage,
    @PageSize as PageSize,
    CEILING(CAST(COUNT(*) OVER() AS FLOAT) / @PageSize) as TotalPages,
    CASE WHEN @PageNumber > 1 THEN 1 ELSE 0 END as HasPreviousPage,
    CASE WHEN @PageNumber < CEILING(CAST(COUNT(*) OVER() AS FLOAT) / @PageSize) 
         THEN 1 ELSE 0 END as HasNextPage
FROM Customers
WHERE Country = 'USA'
ORDER BY CompanyName
OFFSET @Offset ROWS
FETCH NEXT @PageSize ROWS ONLY;
```

## Legacy Pagination Methods (SQL Server 2008 and earlier)

### ROW_NUMBER() Method

```sql
-- Using ROW_NUMBER() for older SQL Server versions
DECLARE @PageNumber INT = 2;
DECLARE @PageSize INT = 10;

WITH PagedResults AS (
    SELECT 
        CustomerID, CompanyName, ContactName,
        ROW_NUMBER() OVER (ORDER BY CompanyName) as RowNum
    FROM Customers
    WHERE Country = 'USA'
)
SELECT CustomerID, CompanyName, ContactName
FROM PagedResults
WHERE RowNum BETWEEN ((@PageNumber - 1) * @PageSize + 1) 
                 AND (@PageNumber * @PageSize);
```

### TOP and Subquery Method

```sql
-- Less efficient method for very old versions
DECLARE @PageNumber INT = 3;
DECLARE @PageSize INT = 10;
DECLARE @SkipRows INT = (@PageNumber - 1) * @PageSize;

SELECT TOP (@PageSize) CustomerID, CompanyName, ContactName
FROM Customers
WHERE CustomerID NOT IN (
    SELECT TOP (@SkipRows) CustomerID
    FROM Customers
    ORDER BY CompanyName
)
ORDER BY CompanyName;
```

## Advanced Pagination Scenarios

### 1. Filtered Pagination

```sql
CREATE PROCEDURE GetFilteredCustomersPaged
    @PageNumber INT = 1,
    @PageSize INT = 10,
    @CountryFilter NVARCHAR(50) = NULL,
    @CityFilter NVARCHAR(50) = NULL,
    @SearchTerm NVARCHAR(100) = NULL
AS
BEGIN
    DECLARE @Offset INT = (@PageNumber - 1) * @PageSize;
    
    SELECT 
        CustomerID, CompanyName, ContactName, City, Country,
        COUNT(*) OVER() as TotalRows
    FROM Customers
    WHERE 
        (@CountryFilter IS NULL OR Country = @CountryFilter)
        AND (@CityFilter IS NULL OR City = @CityFilter)
        AND (@SearchTerm IS NULL OR 
             CompanyName LIKE '%' + @SearchTerm + '%' OR 
             ContactName LIKE '%' + @SearchTerm + '%')
    ORDER BY CompanyName
    OFFSET @Offset ROWS
    FETCH NEXT @PageSize ROWS ONLY;
END

-- Usage
EXEC GetFilteredCustomersPaged 
    @PageNumber = 1, 
    @PageSize = 5, 
    @CountryFilter = 'USA',
    @SearchTerm = 'John';
```

### 2. Cursor-Based Pagination (for large datasets)

```sql
-- More efficient for very large datasets
-- Page 1 - no cursor needed
SELECT TOP 10 CustomerID, CompanyName, ContactName
FROM Customers
ORDER BY CustomerID;

-- Page 2 - using cursor (last CustomerID from page 1)
DECLARE @LastCustomerID NVARCHAR(10) = 'ALFKI'; -- Last ID from previous page

SELECT TOP 10 CustomerID, CompanyName, ContactName
FROM Customers
WHERE CustomerID > @LastCustomerID
ORDER BY CustomerID;

-- Generic cursor-based pagination procedure
CREATE PROCEDURE GetCustomersCursorPaged
    @PageSize INT = 10,
    @LastCustomerID NVARCHAR(10) = NULL
AS
BEGIN
    SELECT TOP (@PageSize) CustomerID, CompanyName, ContactName
    FROM Customers
    WHERE (@LastCustomerID IS NULL OR CustomerID > @LastCustomerID)
    ORDER BY CustomerID;
END
```

### 3. Pagination with Complex Joins

```sql
DECLARE @PageNumber INT = 1;
DECLARE @PageSize INT = 10;
DECLARE @Offset INT = (@PageNumber - 1) * @PageSize;

SELECT 
    c.CustomerID,
    c.CompanyName,
    c.ContactName,
    COUNT(o.OrderID) as TotalOrders,
    COUNT(*) OVER() as TotalCustomers
FROM Customers c
LEFT JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.Country = 'USA'
GROUP BY c.CustomerID, c.CompanyName, c.ContactName
ORDER BY c.CompanyName
OFFSET @Offset ROWS
FETCH NEXT @PageSize ROWS ONLY;
```

## Performance Optimization Tips

### 1. Proper Indexing

```sql
-- Create appropriate indexes for pagination
CREATE NONCLUSTERED INDEX IX_Customers_CompanyName 
ON Customers (CompanyName)
INCLUDE (CustomerID, ContactName, City, Country);

-- For filtered pagination
CREATE NONCLUSTERED INDEX IX_Customers_Country_CompanyName
ON Customers (Country, CompanyName)
INCLUDE (CustomerID, ContactName, City);
```

### 2. Avoid OFFSET with Large Numbers

```sql
-- Inefficient for large offsets
SELECT CustomerID, CompanyName 
FROM Customers
ORDER BY CompanyName
OFFSET 100000 ROWS  -- Very slow for large offsets
FETCH NEXT 10 ROWS ONLY;

-- Better: Use cursor-based approach for large datasets
SELECT TOP 10 CustomerID, CompanyName
FROM Customers
WHERE CompanyName > @LastCompanyName  -- From previous page
ORDER BY CompanyName;
```

### 3. Consider Snapshot Isolation

```sql
-- For consistent pagination across multiple requests
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;
BEGIN TRANSACTION;

-- Execute pagination queries here
-- Data remains consistent even if other transactions modify data

COMMIT TRANSACTION;
```

## Complete Pagination Example

```sql
-- Comprehensive pagination stored procedure
CREATE PROCEDURE GetPagedData
    @TableName NVARCHAR(128),
    @PageNumber INT = 1,
    @PageSize INT = 10,
    @SortColumn NVARCHAR(128) = NULL,
    @SortDirection NVARCHAR(4) = 'ASC',
    @WhereClause NVARCHAR(MAX) = NULL,
    @TotalRows INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @Offset INT = (@PageNumber - 1) * @PageSize;
    DECLARE @SQL NVARCHAR(MAX);
    
    -- Build dynamic SQL
    SET @SQL = 'WITH PagedData AS (
        SELECT *, COUNT(*) OVER() as TotalCount
        FROM ' + @TableName;
    
    IF @WhereClause IS NOT NULL
        SET @SQL = @SQL + ' WHERE ' + @WhereClause;
    
    SET @SQL = @SQL + ')
    SELECT *
    FROM PagedData
    ORDER BY ' + ISNULL(@SortColumn, '(SELECT NULL)') + ' ' + @SortDirection + '
    OFFSET @Offset ROWS
    FETCH NEXT @PageSize ROWS ONLY';
    
    EXEC sp_executesql @SQL, 
         N'@Offset INT, @PageSize INT', 
         @Offset, @PageSize;
END
```

## Best Practices Summary

1. **Use OFFSET/FETCH** for SQL Server 2012+ (most efficient)
2. **Always include ORDER BY** - required for OFFSET/FETCH
3. **Create appropriate indexes** on sort columns
4. **Use cursor-based pagination** for very large datasets
5. **Consider using COUNT(*) OVER()** to get total rows efficiently
6. **Parameterize your queries** to prevent SQL injection
7. **Avoid large OFFSET values** - performance degrades significantly
8. **Test with realistic data volumes** to ensure good performance