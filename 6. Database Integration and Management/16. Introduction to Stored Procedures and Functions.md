# SQL Stored Procedures and Functions Guide

When working with databases, developers often find themselves rewriting the same queries and managing complex calculations across different applications. This repetitive work can add significant time and effort to database management. SQL stored procedures and functions offer an efficient solution by automating recurring queries and complex calculations while ensuring consistency and reducing errors.

## What are Stored Procedures?

Stored procedures are sets of SQL commands saved in a database that can be run as a single task. They allow us to reuse code for common tasks. Instead of writing the same commands every time, we can simply call the stored procedure, ensuring consistent results while saving time and reducing errors.

### Types of Stored Procedures

#### User-Defined Stored Procedures
Custom procedures created by developers to handle specific tasks, like updating order statuses or processing sales reports.

**Example: Update Order Status**
```sql
CREATE PROCEDURE UpdateOrderStatus
    @OrderID INT,
    @NewStatus VARCHAR(20)
AS
BEGIN
    UPDATE Orders 
    SET Status = @NewStatus, 
        LastModified = GETDATE()
    WHERE OrderID = @OrderID;
    
    -- Log the status change
    INSERT INTO OrderStatusLog (OrderID, Status, ChangeDate)
    VALUES (@OrderID, @NewStatus, GETDATE());
END;

-- Usage
EXEC UpdateOrderStatus @OrderID = 12345, @NewStatus = 'Shipped';
```

**Example: Sales Report Processing**
```sql
CREATE PROCEDURE GenerateSalesReport
    @StartDate DATE,
    @EndDate DATE
AS
BEGIN
    SELECT 
        p.ProductName,
        SUM(od.Quantity) as TotalQuantity,
        SUM(od.Quantity * od.UnitPrice) as TotalRevenue
    FROM Orders o
    INNER JOIN OrderDetails od ON o.OrderID = od.OrderID
    INNER JOIN Products p ON od.ProductID = p.ProductID
    WHERE o.OrderDate BETWEEN @StartDate AND @EndDate
    GROUP BY p.ProductName
    ORDER BY TotalRevenue DESC;
END;

-- Usage
EXEC GenerateSalesReport @StartDate = '2024-01-01', @EndDate = '2024-01-31';
```

Setting output parameters with stored procedures:

```
CREATE PROCEDURE GetCustomerOrderCount
    @CustomerID INT,
    @OrderCount INT OUTPUT
AS
BEGIN
    SELECT @OrderCount = COUNT(*)
    FROM Orders
    WHERE CustomerID = @CustomerID;
END
```
Called and used as such:

```
DECLARE @TotalOrders INT;
EXEC GetCustomerOrderCount @CustomerID = 123, @OrderCount = @TotalOrders OUTPUT;
SELECT @TotalOrders as CustomerOrderCount;
```



#### Temporary Stored Procedures
Short-term procedures created for use within a single session and automatically deleted when the session ends.

**Example: Session-Specific Data Processing**
```sql
CREATE PROCEDURE #TempCalculateDiscounts
    @CustomerID INT
AS
BEGIN
    SELECT 
        ProductID,
        UnitPrice,
        CASE 
            WHEN UnitPrice > 100 THEN UnitPrice * 0.9
            WHEN UnitPrice > 50 THEN UnitPrice * 0.95
            ELSE UnitPrice
        END as DiscountedPrice
    FROM Products
    WHERE CategoryID IN (
        SELECT PreferredCategoryID 
        FROM Customers 
        WHERE CustomerID = @CustomerID
    );
END;

-- This procedure is automatically dropped when the session ends
```

## What are Functions?

Functions are a stored set of SQL statements that perform a specific calculation or operation and return a result. Functions can be reused in queries to simplify complex calculations or data retrieval tasks.

### Types of Functions

#### Scalar Functions
Functions that return a single value, like a number or a string, typically used for calculations or transformations on individual data elements.

**Example: Calculate Tax**
```sql
CREATE FUNCTION CalculateTax(@Price DECIMAL(10,2), @TaxRate DECIMAL(5,4))
RETURNS DECIMAL(10,2)
AS
BEGIN
    RETURN @Price * @TaxRate;
END;

-- Usage in a query
SELECT 
    ProductName,
    UnitPrice,
    dbo.CalculateTax(UnitPrice, 0.0825) as TaxAmount,
    UnitPrice + dbo.CalculateTax(UnitPrice, 0.0825) as TotalPrice
FROM Products;
```

**Example: Format Customer Name**
```sql
CREATE FUNCTION FormatCustomerName(@FirstName VARCHAR(50), @LastName VARCHAR(50))
RETURNS VARCHAR(102)
AS
BEGIN
    RETURN UPPER(LEFT(@LastName, 1)) + LOWER(SUBSTRING(@LastName, 2, LEN(@LastName))) + 
           ', ' + 
           UPPER(LEFT(@FirstName, 1)) + LOWER(SUBSTRING(@FirstName, 2, LEN(@FirstName)));
END;

-- Usage
SELECT 
    CustomerID,
    dbo.FormatCustomerName(FirstName, LastName) as FormattedName
FROM Customers;
```

#### Table-Valued Functions
Functions that return an entire table of data rather than a single value, allowing users to perform complex queries.

**Example: Top Selling Products**
```sql
CREATE FUNCTION GetTopSellingProducts(@Days INT, @TopCount INT)
RETURNS TABLE
AS
RETURN
(
    SELECT TOP (@TopCount)
        p.ProductID,
        p.ProductName,
        SUM(od.Quantity) as TotalQuantitySold,
        SUM(od.Quantity * od.UnitPrice) as TotalRevenue
    FROM Products p
    INNER JOIN OrderDetails od ON p.ProductID = od.ProductID
    INNER JOIN Orders o ON od.OrderID = o.OrderID
    WHERE o.OrderDate >= DATEADD(DAY, -@Days, GETDATE())
    GROUP BY p.ProductID, p.ProductName
    ORDER BY TotalQuantitySold DESC
);

-- Usage - treat like a table
SELECT * FROM dbo.GetTopSellingProducts(30, 10);

-- Can be used in JOINs
SELECT 
    tsp.ProductName,
    tsp.TotalQuantitySold,
    c.CategoryName
FROM dbo.GetTopSellingProducts(30, 10) tsp
INNER JOIN Products p ON tsp.ProductID = p.ProductID
INNER JOIN Categories c ON p.CategoryID = c.CategoryID;
```

**Example: Customer Orders by Date Range**
```sql
CREATE FUNCTION GetCustomerOrdersByDateRange(
    @CustomerID INT, 
    @StartDate DATE, 
    @EndDate DATE
)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        o.OrderID,
        o.OrderDate,
        o.ShippedDate,
        SUM(od.Quantity * od.UnitPrice) as OrderTotal
    FROM Orders o
    INNER JOIN OrderDetails od ON o.OrderID = od.OrderID
    WHERE o.CustomerID = @CustomerID
        AND o.OrderDate BETWEEN @StartDate AND @EndDate
    GROUP BY o.OrderID, o.OrderDate, o.ShippedDate
);

-- Usage
SELECT * FROM dbo.GetCustomerOrdersByDateRange(123, '2024-01-01', '2024-03-31');
```

## Benefits of Stored Procedures and Functions

### 1. Improved Code Organization
Group related SQL logic, making it easier to manage and update.

**Example: Centralized Filtering Logic**
```sql
CREATE PROCEDURE GetActiveCustomersWithOrders
AS
BEGIN
    SELECT DISTINCT
        c.CustomerID,
        c.CompanyName,
        c.ContactName
    FROM Customers c
    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
    WHERE c.IsActive = 1
        AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE());
END;
```

### 2. Improved Query Performance
Pre-compiled and optimized SQL commands reduce parsing time.

**Example: Performance-Optimized Customer History**
```sql
CREATE PROCEDURE GetCustomerOrderHistory
    @CustomerID INT
AS
BEGIN
    -- Pre-compiled and cached execution plan
    SELECT 
        o.OrderID,
        o.OrderDate,
        COUNT(od.ProductID) as ItemCount,
        SUM(od.Quantity * od.UnitPrice) as OrderTotal
    FROM Orders o
    INNER JOIN OrderDetails od ON o.OrderID = od.OrderID
    WHERE o.CustomerID = @CustomerID
    GROUP BY o.OrderID, o.OrderDate
    ORDER BY o.OrderDate DESC;
END;
```

### 3. Reduced Network Traffic
Execute multiple operations on the server in a single call.

**Example: Batch Operations**
```sql
CREATE PROCEDURE ProcessNewOrder
    @CustomerID INT,
    @OrderDetails NVARCHAR(MAX) -- JSON format
AS
BEGIN
    DECLARE @OrderID INT;
    
    -- Insert order
    INSERT INTO Orders (CustomerID, OrderDate)
    VALUES (@CustomerID, GETDATE());
    
    SET @OrderID = SCOPE_IDENTITY();
    
    -- Parse JSON and insert order details
    INSERT INTO OrderDetails (OrderID, ProductID, Quantity, UnitPrice)
    SELECT 
        @OrderID,
        ProductID,
        Quantity,
        UnitPrice
    FROM OPENJSON(@OrderDetails)
    WITH (
        ProductID INT '$.productId',
        Quantity INT '$.quantity',
        UnitPrice DECIMAL(10,2) '$.unitPrice'
    );
    
    -- Update inventory
    UPDATE p
    SET UnitsInStock = p.UnitsInStock - od.Quantity
    FROM Products p
    INNER JOIN OrderDetails od ON p.ProductID = od.ProductID
    WHERE od.OrderID = @OrderID;
    
    SELECT @OrderID as NewOrderID;
END;
```

### 4. Enhanced Security
Grant access to specific procedures without exposing underlying tables.

**Example: Secure Reporting Access**
```sql
CREATE PROCEDURE GetSalesReportSummary
    @UserRole VARCHAR(20)
AS
BEGIN
    IF @UserRole = 'Manager'
    BEGIN
        -- Full details for managers
        SELECT 
            ProductName,
            SUM(Quantity) as TotalSold,
            SUM(Quantity * UnitPrice) as Revenue,
            AVG(UnitPrice) as AvgPrice
        FROM vw_SalesData  -- View that joins multiple tables
        WHERE SaleDate >= DATEADD(MONTH, -1, GETDATE())
        GROUP BY ProductName;
    END
    ELSE
    BEGIN
        -- Summary only for other users
        SELECT 
            'Summary' as ReportType,
            COUNT(DISTINCT ProductName) as ProductCount,
            SUM(Quantity * UnitPrice) as TotalRevenue
        FROM vw_SalesData
        WHERE SaleDate >= DATEADD(MONTH, -1, GETDATE());
    END
END;

-- Grant execute permission without table access
GRANT EXECUTE ON GetSalesReportSummary TO ReportUsers;
```

## Conclusion

Stored procedures and functions are essential tools for building organized, efficient, and secure databases. By using these features, developers can simplify database tasks, improve performance, and keep data safe in multi-user environments. They provide a powerful way to encapsulate business logic, ensure consistency, and create reusable database components that enhance both development productivity and application performance.