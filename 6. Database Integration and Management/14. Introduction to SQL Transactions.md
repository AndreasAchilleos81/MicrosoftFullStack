# SQL Transactions and Data Integrity

## Introduction

Whenever we make database changes, we rely on them to happen smoothly and accurately. SQL transactions build trust by ensuring data remains consistent no matter what. This guide explains the concept of transactions in SQL and their role in maintaining data integrity.

## What is a SQL Transaction?

In databases, a **SQL transaction** is a sequence of operations performed in a single logical unit of work. Think of it as a package of changes where each part depends on the others to succeed. If one part fails, the whole transaction is rolled back, preserving data accuracy.

## ACID Properties

ACID is an acronym that stands for four principles that guarantee transaction reliability:
- **A**tomicity
- **C**onsistency  
- **I**solation
- **D**urability

### Atomicity

**Atomicity** is the principle that a transaction is one complete, unbreakable action. Either everything within the transaction happens, or nothing happens. If even one part of a transaction fails, none of the changes are applied. This property prevents partial updates, which could lead to errors.

**Example:** Transferring funds between two accounts in a banking system requires two steps:
1. Subtracting an amount from one account
2. Adding it to another account

Both must succeed, or neither should happen.

```sql
-- Example of atomicity in action
BEGIN TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE account_id = 'ACC001';
    UPDATE accounts SET balance = balance + 100 WHERE account_id = 'ACC002';
    -- If either update fails, both are rolled back
COMMIT;
```

### Consistency

**Consistency** is the principle that ensures a transaction moves the database from one valid state to another, following all rules, constraints, and data integrity requirements. This principle stops any changes that would make the database incorrect or break its rules.

**Example:** A bank won't allow the bank balance to drop below zero, ensuring account records remain valid.

```sql
-- This transaction will fail if it violates consistency rules
BEGIN TRANSACTION;
    UPDATE accounts 
    SET balance = balance - 500 
    WHERE account_id = 'ACC001' AND balance >= 500; -- Check constraint
    
    -- If balance < 500, this fails and transaction rolls back
    IF @@ROWCOUNT = 0
    BEGIN
        ROLLBACK;
        PRINT 'Insufficient funds';
    END
    ELSE
    BEGIN
        UPDATE accounts SET balance = balance + 500 WHERE account_id = 'ACC002';
        COMMIT;
    END
```

### Isolation

**Isolation** is the principle that ensures each transaction operates independently, so changes from one transaction don't affect others until they are complete. When multiple transactions occur simultaneously, isolation prevents them from interfering with each other's data.

**Example:** If two users try to update the same account balance at the same time, isolation ensures that each update happens independently.

```sql
-- Transaction 1
BEGIN TRANSACTION;
    SELECT balance FROM accounts WHERE account_id = 'ACC001'; -- Reads 1000
    UPDATE accounts SET balance = balance - 50 WHERE account_id = 'ACC001';
    -- Other transactions can't see this change yet
COMMIT; -- Now other transactions can see the updated balance

-- Transaction 2 (running simultaneously)
BEGIN TRANSACTION;
    SELECT balance FROM accounts WHERE account_id = 'ACC001'; -- Still reads 1000
    UPDATE accounts SET balance = balance - 25 WHERE account_id = 'ACC001';
COMMIT;
```

### Durability

**Durability** is the principle that ensures completed changes are saved permanently, even if the system crashes. Durability ensures that the results of a committed transaction persist, providing reliability for data storage.

**Example:** After a bank transfer is complete, durability ensures the updated balances are saved permanently, so they remain accurate even if the system goes down right after.

## SQL Transaction Commands

To work with transactions in SQL, we use specific commands to control them:

### BEGIN TRANSACTION

**BEGIN TRANSACTION** marks the start of any transaction, grouping the following actions as a single unit.

```sql
BEGIN TRANSACTION;
-- All operations after this point are part of the transaction
```

### COMMIT

**COMMIT** finalizes a transaction, saving all changes permanently to the database. It signals that the transaction has been successfully completed and that the ACID properties have been upheld.

```sql
BEGIN TRANSACTION;
    -- Perform operations here
    UPDATE accounts SET balance = balance - 100 WHERE account_id = 'sender';
    UPDATE accounts SET balance = balance + 100 WHERE account_id = 'receiver';
COMMIT; -- Saves all changes permanently
```

### ROLLBACK

**ROLLBACK** cancels a transaction, undoing all changes made since the transaction began. If an error occurs, or if any part of the transaction fails, we use ROLLBACK to maintain data accuracy.

```sql
BEGIN TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE account_id = 'sender';
    
    -- Check if sender has sufficient funds
    IF (SELECT balance FROM accounts WHERE account_id = 'sender') < 0
    BEGIN
        ROLLBACK; -- Undo all changes
        PRINT 'Transaction failed: Insufficient funds';
    END
    ELSE
    BEGIN
        UPDATE accounts SET balance = balance + 100 WHERE account_id = 'receiver';
        COMMIT;
        PRINT 'Transfer successful';
    END
```

## Complete Bank Transfer Example

Here's a comprehensive example showing all concepts together:

```sql
-- Bank transfer transaction with error handling
BEGIN TRANSACTION;
    DECLARE @sender_balance DECIMAL(10,2);
    DECLARE @transfer_amount DECIMAL(10,2) = 250.00;
    
    -- Check sender's current balance
    SELECT @sender_balance = balance 
    FROM accounts 
    WHERE account_id = 'ACC001';
    
    -- Verify sufficient funds
    IF @sender_balance >= @transfer_amount
    BEGIN
        -- Deduct from sender
        UPDATE accounts 
        SET balance = balance - @transfer_amount,
            last_updated = GETDATE()
        WHERE account_id = 'ACC001';
        
        -- Add to receiver
        UPDATE accounts 
        SET balance = balance + @transfer_amount,
            last_updated = GETDATE()
        WHERE account_id = 'ACC002';
        
        -- Log the transaction
        INSERT INTO transaction_log (from_account, to_account, amount, timestamp)
        VALUES ('ACC001', 'ACC002', @transfer_amount, GETDATE());
        
        COMMIT;
        PRINT 'Transfer completed successfully';
    END
    ELSE
    BEGIN
        ROLLBACK;
        PRINT 'Transfer failed: Insufficient funds';
    END
```

## Best Practices

1. **Keep transactions short** - Long transactions can lock resources
2. **Handle errors properly** - Always include error handling with ROLLBACK
3. **Use appropriate isolation levels** - Choose the right balance between consistency and performance
4. **Test transaction logic thoroughly** - Verify both success and failure scenarios

## Conclusion

Transactions are essential for applications where data consistency is crucial. By understanding and using transactions with BEGIN TRANSACTION, COMMIT, and ROLLBACK, you can manage complex operations confidently, knowing that the database remains reliable, consistent, and accurate. The ACID properties ensure that your data stays intact and dependable, even through complex changes, creating a foundation for reliability that supports every interaction within a database.