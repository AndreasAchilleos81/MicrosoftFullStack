```markdown
# Implementing External Authentication with Google OAuth 2.0 in ASP.NET Identity

## Overview

This lab demonstrates how to implement external authentication providers in ASP.NET Identity using OAuth 2.0 with Google APIs. This approach uses Google's client libraries directly rather than the built-in ASP.NET authentication middleware.

## Prerequisites

Install the required Google API packages:

```bash
dotnet add package Google.Apis.Auth
dotnet add package Google.Apis.Util
```

## Step 1: Initial Application Setup

Configure the application to use controllers for handling authentication endpoints.

### Program.cs - Basic Setup

```csharp
using Google.Apis.Auth;
using Google.Apis.Util;

var builder = WebApplication.CreateBuilder(args);

// Add controllers to discover and use controller endpoints
builder.Services.AddControllers();

var app = builder.Build();

app.MapControllers();
app.Run();
```

## Step 2: Configure Google Client and Authentication Flow

### Configuration File (appsettings.json)

Store your Google credentials in a separate configuration file. **Never commit these to source control.**

```json
{
  "Google": {
    "ClientID": "your-client-id-here.apps.googleusercontent.com",
    "ClientSecret": "your-client-secret-here"
  }
}
```

### Authentication Configuration

```csharp
using Google.Apis.Auth.OAuth2;
using Google.Apis.Auth.OAuth2.Flows;
using Google.Apis.Util.Store;

// Create ClientSecrets object to store credentials
var clientSecrets = new ClientSecrets
{
    ClientId = builder.Configuration["Google:ClientID"],
    ClientSecret = builder.Configuration["Google:ClientSecret"]
};

// Define the OAuth scopes we need
var scopes = new[] { "https://www.googleapis.com/auth/userinfo.profile" };

// Set the data store path for storing credentials locally
var dataStorePath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

// Create credential using Google Web Authorization Broker
var credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(
    clientSecrets,
    scopes,
    "user",
    CancellationToken.None,
    new FileDataStore(dataStorePath, true)
);
```

### Key Components Explained

#### ClientSecrets
Stores your Google OAuth credentials obtained from Google Cloud Console.

```csharp
var clientSecrets = new ClientSecrets
{
    ClientId = builder.Configuration["Google:ClientID"],
    ClientSecret = builder.Configuration["Google:ClientSecret"]
};
```

#### Scopes
Defines what user information your application can access. Common scopes include:

```csharp
// For user profile information
var scopes = new[] { "https://www.googleapis.com/auth/userinfo.profile" };

// For email access
// var scopes = new[] { "https://www.googleapis.com/auth/userinfo.email" };

// For multiple scopes
// var scopes = new[] { 
//     "https://www.googleapis.com/auth/userinfo.profile",
//     "https://www.googleapis.com/auth/userinfo.email"
// };
```

#### Data Store Path
Specifies where Google stores credential information on the local device:

```csharp
var dataStorePath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
```

This uses the operating system's application data folder:
- **Windows**: `C:\Users\[Username]\AppData\Roaming`
- **macOS**: `~/Library/Application Support`
- **Linux**: `~/.config`

#### GoogleWebAuthorizationBroker
Handles the OAuth 2.0 authorization flow:

```csharp
var credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(
    clientSecrets,           // Your Google credentials
    scopes,                  // Permissions you're requesting
    "user",                  // User identifier (can be any string)
    CancellationToken.None,  // Cancellation token
    new FileDataStore(dataStorePath, true)  // Where to store credentials
);
```

## Step 3: Create the Login Endpoint

Create an API endpoint that triggers the authentication flow and returns the authentication status.

### Login Controller

```csharp
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("[controller]")]
public class AuthController : ControllerBase
{
    private readonly IConfiguration _configuration;

    public AuthController(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    [HttpGet("login")]
    public async Task<IActionResult> Login()
    {
        // Create ClientSecrets
        var clientSecrets = new ClientSecrets
        {
            ClientId = _configuration["Google:ClientID"],
            ClientSecret = _configuration["Google:ClientSecret"]
        };

        // Define scopes
        var scopes = new[] { "https://www.googleapis.com/auth/userinfo.profile" };

        // Set data store path
        var dataStorePath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

        // Authorize and get credential
        var credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(
            clientSecrets,
            scopes,
            "user",
            CancellationToken.None,
            new FileDataStore(dataStorePath, true)
        );

        // Return authentication status
        return Ok(new { 
            Status = "Authenticated",
            Message = "Successfully authenticated with Google" 
        });
    }
}
```

### Alternative: Minimal API Approach

```csharp
app.MapGet("/login", async (IConfiguration configuration) =>
{
    var clientSecrets = new ClientSecrets
    {
        ClientId = configuration["Google:ClientID"],
        ClientSecret = configuration["Google:ClientSecret"]
    };

    var scopes = new[] { "https://www.googleapis.com/auth/userinfo.profile" };
    var dataStorePath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

    var credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(
        clientSecrets,
        scopes,
        "user",
        CancellationToken.None,
        new FileDataStore(dataStorePath, true)
    );

    return Results.Ok("Authenticated");
});
```

## Complete Example

### Program.cs - Full Implementation

```csharp
using Google.Apis.Auth.OAuth2;
using Google.Apis.Util.Store;
using Microsoft.AspNetCore.Mvc;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();

var app = builder.Build();

app.MapControllers();

// Login endpoint
app.MapGet("/login", async (IConfiguration configuration) =>
{
    // Configure client secrets
    var clientSecrets = new ClientSecrets
    {
        ClientId = configuration["Google:ClientID"],
        ClientSecret = configuration["Google:ClientSecret"]
    };

    // Define OAuth scopes
    var scopes = new[] { "https://www.googleapis.com/auth/userinfo.profile" };

    // Set credential storage path
    var dataStorePath = Environment.GetFolderPath(
        Environment.SpecialFolder.ApplicationData
    );

    // Perform authorization
    var credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(
        clientSecrets,
        scopes,
        "user",
        CancellationToken.None,
        new FileDataStore(dataStorePath, true)
    );

    // Return authentication response
    return Results.Ok(new { 
        authentication = "Success",
        tokenExpiry = credential.Token.ExpiresInSeconds
    });
});

app.Run();
```

## How the Authentication Flow Works

1. **User hits `/login` endpoint**
2. **GoogleWebAuthorizationBroker initiates OAuth flow**:
   - Opens browser window with Google sign-in
   - User authenticates with Google
   - Google redirects with authorization code
3. **Application exchanges code for tokens**
4. **Credentials stored locally** in the data store path
5. **Application returns authentication response** to the user

## Key Differences from Previous Approach

This approach uses **Google's client libraries directly** rather than ASP.NET's built-in authentication middleware:

| Feature             | Google.Apis.Auth        | ASP.NET Authentication |
| ------------------- | ----------------------- | ---------------------- |
| Cookie management   | Manual                  | Automatic              |
| Token storage       | Local file system       | Cookie/session         |
| Browser interaction | Opens new window        | Redirects current page |
| Best for            | Desktop apps, CLI tools | Web applications       |

## Security Considerations

### Protecting Credentials

**Never expose ClientID and ClientSecret in code:**

```csharp
// ❌ Bad - hardcoded secrets
var clientSecrets = new ClientSecrets
{
    ClientId = "123456.apps.googleusercontent.com",
    ClientSecret = "GOCSPX-abc123"
};

// ✅ Good - from configuration
var clientSecrets = new ClientSecrets
{
    ClientId = configuration["Google:ClientID"],
    ClientSecret = configuration["Google:ClientSecret"]
};
```

### Using User Secrets for Development

```bash
dotnet user-secrets init
dotnet user-secrets set "Google:ClientID" "your-client-id"
dotnet user-secrets set "Google:ClientSecret" "your-secret"
```

### Environment Variables for Production

```csharp
var clientSecrets = new ClientSecrets
{
    ClientId = Environment.GetEnvironmentVariable("GOOGLE_CLIENT_ID"),
    ClientSecret = Environment.GetEnvironmentVariable("GOOGLE_CLIENT_SECRET")
};
```

## Testing the Application

```bash
dotnet run
```

1. Navigate to `http://localhost:5000/login` (or your configured port)
2. Browser window opens with Google sign-in
3. Sign in with your Google account
4. Grant requested permissions
5. Receive authentication response

## Summary

This implementation provides a simple way to integrate Google OAuth 2.0 authentication:

- **ClientSecrets**: Store Google OAuth credentials
- **Scopes**: Define what user data you can access
- **DataStore**: Local storage for credentials
- **GoogleWebAuthorizationBroker**: Handles the OAuth flow
- **/login endpoint**: Triggers authentication and returns status

This approach is particularly useful for desktop applications or scenarios where you need direct control over the OAuth flow.
```