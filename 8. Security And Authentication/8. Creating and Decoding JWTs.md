# Understanding JSON Web Tokens (JWTs)

## Introduction

JWTs are one of the gold standards for sending stateless tokenized information around the internet to support authentication. This guide explains the creation and decoding of JWTs in an ASP.NET Core application.

## JWT Structure

A JWT consists of three main parts, separated by periods (`.`):

```
[HEADER].[PAYLOAD].[SIGNATURE]
```

### Example JWT Token

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

## The Three Components

### 1. Header

The header is a JSON object that typically contains the token type and signing algorithm:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

When Base64 URL encoded, this becomes:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

### 2. Payload

The payload contains the claims (user data and metadata):

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

When Base64 URL encoded, this becomes:
```
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
```

### 3. Signature

The signature is created using:
- The encoded header
- The encoded payload
- A secret key
- The signing algorithm specified in the header

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

## Important Concepts

### Base64 URL Encoding

The header and payload are **NOT encrypted** — they are simply Base64 URL encoded. This encoding:

- Makes the data safe to transport as text across the internet
- Prevents misinterpretation due to special characters
- **Does NOT provide security** (anyone can decode it)

### Security Through Signatures

The security of JWTs comes from the signature, which:

- Requires a secret key to generate
- Changes if any part of the header or payload is modified
- Cannot be recreated without the secret key

**Key Point:** If someone tries to tamper with the data, they cannot generate a valid signature without your secret key.

## ASP.NET Core Implementation

### Creating a JWT

```csharp
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;

public string GenerateJwtToken(string userId, string username)
{
    var securityKey = new SymmetricSecurityKey(
        Encoding.UTF8.GetBytes("your-secret-key-min-32-chars")
    );
    var credentials = new SigningCredentials(
        securityKey, 
        SecurityAlgorithms.HmacSha256
    );

    var claims = new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, userId),
        new Claim(JwtRegisteredClaimNames.Name, username),
        new Claim(JwtRegisteredClaimNames.Iat, 
            DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString())
    };

    var token = new JwtSecurityToken(
        issuer: "your-issuer",
        audience: "your-audience",
        claims: claims,
        expires: DateTime.UtcNow.AddHours(1),
        signingCredentials: credentials
    );

    return new JwtSecurityTokenHandler().WriteToken(token);
}
```

### Validating a JWT

```csharp
public ClaimsPrincipal ValidateJwtToken(string token)
{
    var tokenHandler = new JwtSecurityTokenHandler();
    var securityKey = new SymmetricSecurityKey(
        Encoding.UTF8.GetBytes("your-secret-key-min-32-chars")
    );

    var validationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = securityKey,
        ValidateIssuer = true,
        ValidIssuer = "your-issuer",
        ValidateAudience = true,
        ValidAudience = "your-audience",
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero
    };

    try
    {
        var principal = tokenHandler.ValidateToken(
            token, 
            validationParameters, 
            out SecurityToken validatedToken
        );
        return principal;
    }
    catch (SecurityTokenException)
    {
        // Token validation failed
        return null;
    }
}
```

### Configuring JWT Authentication in ASP.NET Core

```csharp
// In Program.cs or Startup.cs
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:SecretKey"])
            ),
            ValidateIssuer = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidateAudience = true,
            ValidAudience = builder.Configuration["Jwt:Audience"],
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
    });

builder.Services.AddAuthorization();

// In the middleware pipeline
app.UseAuthentication();
app.UseAuthorization();
```

### Using JWT in a Controller

```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IConfiguration _configuration;

    public AuthController(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    [HttpPost("login")]
    public IActionResult Login([FromBody] LoginRequest request)
    {
        // Validate user credentials (simplified)
        if (request.Username == "user" && request.Password == "password")
        {
            var token = GenerateJwtToken(
                request.Username, 
                request.Username
            );
            return Ok(new { token });
        }

        return Unauthorized();
    }

    [Authorize]
    [HttpGet("protected")]
    public IActionResult Protected()
    {
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        return Ok($"Hello, user {userId}");
    }
}
```

## Why JWTs Are Secure

1. **Tamper-Proof:** Any modification to the header or payload invalidates the signature
2. **Secret Key Required:** Only parties with the secret key can create valid signatures
3. **Self-Contained:** All necessary information is contained in the token itself
4. **Stateless:** No need to store session information on the server

## Testing JWTs

You can test and debug JWTs using [JWT.io](https://jwt.io), which allows you to:

- Decode existing tokens
- Create new tokens
- Verify signatures
- Experiment with different algorithms

## Common Pitfalls

⚠️ **Remember:**
- The header and payload are **NOT encrypted** — don't store sensitive data in them
- Keep your secret key secure and never expose it in client-side code
- Use HTTPS to prevent token interception during transmission
- Implement token expiration to limit the damage from stolen tokens
- Consider token refresh strategies for long-lived sessions