```markdown
# External Authentication with Google in ASP.NET Core using OAuth 2.0

## Overview

This guide demonstrates how to integrate external authentication providers (like Google or Microsoft) into an ASP.NET application using OAuth 2.0, allowing users to authenticate with their existing accounts instead of using ASP.NET Identity.

## Initial Setup

Starting with a simple application that has a root route and a secured route. **Note:** We don't need Identity, a database, or Identity API endpoints - just authentication and authorization.

### Add Required Services

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add authentication and authorization services
builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;
})
.AddCookie()  // Required because we cannot have an external provider as default
.AddGoogle(options =>
{
    options.ClientId = builder.Configuration["Authorization:Google:ClientID"] 
        ?? throw new InvalidOperationException("Google ClientID not configured");
    options.ClientSecret = builder.Configuration["Authorization:Google:ClientSecret"]
        ?? throw new InvalidOperationException("Google ClientSecret not configured");
});

builder.Services.AddAuthorization();

var app = builder.Build();
```

### Install Required Package

```bash
dotnet add package Microsoft.AspNetCore.Authentication.Google
```

## Configuration

### appsettings.json

Store your Google credentials securely. **Important:** Never commit these values to source control. Add `appsettings.json` to your `.gitignore` file.

```json
{
  "Authorization": {
    "Google": {
      "ClientID": "your-client-id-here",
      "ClientSecret": "your-client-secret-here"
    }
  }
}
```

### Key Configuration Options

- **DefaultScheme**: Set to `CookieAuthenticationDefaults.AuthenticationScheme` - this handles the authentication after Google validates the user
- **DefaultChallengeScheme**: Set to `GoogleDefaults.AuthenticationScheme` - this redirects unauthenticated users to Google's login
- **ClientID** and **ClientSecret**: Obtained from Google Cloud Console (see below)

## How It Works

1. User tries to access a secured route
2. ASP.NET Core redirects to Google's sign-in page
3. User authenticates with Google
4. Google redirects back to your application with authentication token
5. ASP.NET Core creates a cookie for the authenticated session
6. User can now access secured routes

## Getting Google Credentials

### Step 1: Access Google Cloud Console

Navigate to: `console.cloud.google.com/apis`

### Step 2: Configure OAuth Consent Screen

1. Click **Credentials** → **Configure Consent Screen**
2. Select **External** and click **Create**
3. Fill in required information:
   - App name (e.g., "MyTestApp")
   - User support email
   - Developer contact email
4. Click **Save and Continue** through the scopes and test users sections

### Step 3: Create OAuth Client ID

1. Go to **Credentials** → **Create Credentials** → **OAuth Client ID**
2. Select **Web application** as the application type
3. Add authorized redirect URIs:
   ```
   http://localhost:5000/signin-google
   https://localhost:5001/signin-google
   ```
   
   **Note:** `/signin-google` is the default redirect URI that .NET uses. You can customize this in your application if needed.

4. Click **Create**
5. Copy the **Client ID** and **Client Secret** into your `appsettings.json`

### Redirect URI Pattern

The redirect URI follows this pattern:
```
{your-domain}/signin-google
```

For local development:
- HTTP: `http://localhost:5000/signin-google`
- HTTPS: `https://localhost:5001/signin-google`

For production:
- `https://yourdomain.com/signin-google`

## Security Best Practices

### Protecting Secrets

1. **Never commit secrets to source control**
2. **Use environment variables** in production:
   ```csharp
   options.ClientId = Environment.GetEnvironmentVariable("GOOGLE_CLIENT_ID");
   ```

3. **Use user secrets** for local development:
   ```bash
   dotnet user-secrets init
   dotnet user-secrets set "Authorization:Google:ClientID" "your-client-id"
   dotnet user-secrets set "Authorization:Google:ClientSecret" "your-secret"
   ```

4. **Add proper error handling**:
   ```csharp
   options.ClientId = builder.Configuration["Authorization:Google:ClientID"] 
       ?? throw new InvalidOperationException("Google ClientID is not configured");
   ```

## Complete Example

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configure authentication
builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;
})
.AddCookie()
.AddGoogle(options =>
{
    options.ClientId = builder.Configuration["Authorization:Google:ClientID"]!;
    options.ClientSecret = builder.Configuration["Authorization:Google:ClientSecret"]!;
});

builder.Services.AddAuthorization();

var app = builder.Build();

// Public route - no authentication required
app.MapGet("/", () => "Welcome! This is a public route.");

// Secured route - requires authentication
app.MapGet("/secure", () => "You are authenticated!")
    .RequireAuthorization();

app.Run();
```

## Running the Application

```bash
dotnet watch
```

1. Navigate to the root route (`/`) - accessible without authentication
2. Navigate to `/secure` - redirects to Google sign-in
3. Sign in with your Google account
4. Get redirected back to `/secure` with access granted

## Key Takeaways

- External authentication requires **two schemes**: Cookie (for session management) and Google (for authentication challenge)
- **ClientID and ClientSecret** must be kept secure and never exposed
- The redirect URI in Google Console must **exactly match** what your application uses
- OAuth 2.0 handles the secure token exchange between your app and Google
- No database or Identity framework needed for basic external authentication
```