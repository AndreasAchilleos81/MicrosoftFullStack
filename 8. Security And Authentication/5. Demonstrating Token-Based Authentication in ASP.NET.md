# Working with Session Tokens in .NET Identity

## Overview

Cookies are largely considered the gold standard of working with back-end security. They are incredibly powerful when working with browser environments and any front-end that can support cookies. However, not all front-ends can support cookies, and sometimes you need to work with third-party services that can't issue cookies. In those situations, you often have to work with security tokens or session tokens.

One of the most common types of tokens is JWTs (JSON Web Tokens). While .NET doesn't have built-in support for issuing JWTs, it does have its own proprietary session token that performs similarly to a JWT. This makes them an excellent introduction for working with session tokens, as everything you learn here will apply to JWTs in the future.

## Setting Up the Application

In this application, we have:
- Identity set up
- Policies and roles configured
- User management
- Routes secured behind different policies
- Logout functionality
- Ability to add roles and claims to users

Getting sessions is relatively straightforward because we are set up out of the box using Identity to generate sessions.

## Cookie-Based Authentication

When using cookies, authentication happens automatically behind the scenes.

### Example: Login with Cookies

```http
POST /register
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

```http
POST /login?useCookies=true
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

Response: Sets a cookie automatically, which is stored and sent with all future requests.

```http
GET /secure-route
Cookie: .AspNetCore.Identity.Application=<cookie_value>
```

The cookie is automatically included in subsequent requests, providing authentication without manual intervention.

## Token-Based Authentication

When you set `useCookies=false`, you receive a session token instead of a cookie.

### Example: Login with Tokens

```http
POST /login?useCookies=false
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

Response payload:

```json
{
  "accessToken": "CfDJ8K...(long token string)",
  "refreshToken": "CfDJ8M...(another long token string)",
  "expiresIn": 3600
}
```

### Using Bearer Tokens

Unlike cookies, tokens are not automatically stored or sent by the client. You must manually implement how to use them.

To use a bearer token, add an `Authorization` header with the format: `Bearer <token>`

```http
GET /secure-route
Authorization: Bearer CfDJ8K...(your access token here)
```

### Example Code: Using Tokens in a Client

```csharp
// Store the tokens after login
var loginResponse = await httpClient.PostAsJsonAsync("/login?useCookies=false", 
    new { email = "user@example.com", password = "SecurePassword123!" });

var tokens = await loginResponse.Content.ReadFromJsonAsync<TokenResponse>();

// Store tokens securely
string accessToken = tokens.AccessToken;
string refreshToken = tokens.RefreshToken;

// Use the access token in subsequent requests
httpClient.DefaultRequestHeaders.Authorization = 
    new AuthenticationHeaderValue("Bearer", accessToken);

// Now you can make authenticated requests
var response = await httpClient.GetAsync("/secure-route");
```

```csharp
public class TokenResponse
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
    public int ExpiresIn { get; set; }
}
```

## Token Expiration and Security

### Key Differences from Cookies

One of the major differences with session tokens is that **you cannot revoke them**. If you log a user out, they can still continue to use the token until it expires. Unlike cookies, which can be overwritten with a blank value, tokens remain valid until their expiration time.

### Why Short-Lived Tokens Matter

Tokens typically don't last very long for security reasons. If someone obtains a client's token, they would be able to access your application even though they shouldn't. By limiting the token's lifespan, you reduce the window of vulnerability.

The `expiresIn` value is in seconds. In this example:
- `expiresIn: 3600` = 1 hour

This is why refresh tokens exist.

## Refreshing Tokens

The refresh token allows you to obtain new access tokens without requiring the user to log in again. You must refresh before the access token expires.

### Example: Refreshing a Token

```http
POST /refresh
Content-Type: application/json

{
  "refreshToken": "CfDJ8M...(your refresh token here)"
}
```

Response:

```json
{
  "accessToken": "CfDJ8N...(new access token)",
  "refreshToken": "CfDJ8P...(new refresh token)",
  "expiresIn": 3600
}
```

### Example Code: Token Refresh Implementation

```csharp
public async Task<string> RefreshAccessToken(string refreshToken)
{
    var refreshRequest = new { refreshToken = refreshToken };
    
    var response = await httpClient.PostAsJsonAsync("/refresh", refreshRequest);
    
    if (response.IsSuccessStatusCode)
    {
        var tokens = await response.Content.ReadFromJsonAsync<TokenResponse>();
        
        // Update stored tokens
        accessToken = tokens.AccessToken;
        refreshToken = tokens.RefreshToken;
        
        // Update authorization header
        httpClient.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", accessToken);
        
        return tokens.AccessToken;
    }
    
    throw new Exception("Failed to refresh token");
}
```

### Automatic Token Refresh with Retry Logic

```csharp
public async Task<HttpResponseMessage> SendAuthenticatedRequest(string url)
{
    var response = await httpClient.GetAsync(url);
    
    if (response.StatusCode == HttpStatusCode.Unauthorized)
    {
        // Try to refresh the token
        await RefreshAccessToken(storedRefreshToken);
        
        // Retry the request with new token
        response = await httpClient.GetAsync(url);
    }
    
    return response;
}
```

## Important Notes

### Token Behavior
- **Refresh tokens do not invalidate previous tokens** - When you refresh, you get a new token, but the old one remains valid until it expires
- Tokens are passed in the `Authorization` header as bearer tokens
- Refresh tokens are passed in the request body, not in headers

### Security Considerations
- Store tokens securely (never in plain text or easily accessible storage)
- Use HTTPS to prevent token interception
- Implement token expiration and refresh logic
- Consider using refresh token rotation for enhanced security
- Remember: logging out does not invalidate tokens - they remain valid until expiration

## Summary

To set up session tokens in .NET:

1. **Change login method** - Set `useCookies=false` when logging in to receive tokens instead of cookies
2. **Implement token storage** - Create a method on your client or front-end to store and manage tokens
3. **Pass tokens with requests** - Add tokens to the `Authorization` header as bearer tokens
4. **Implement refresh logic** - Use refresh tokens to get new access tokens before they expire
5. **Handle security** - Implement measures to work around the fact that tokens cannot be invalidated before expiration