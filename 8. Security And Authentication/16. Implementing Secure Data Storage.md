# Secure Data Storage Implementation in Messaging Applications

## Overview

You've learned a lot about encryption, decryption, and securing endpoints. Now it's time to put that all together in a messaging app. This guide describes how to implement secure data storage techniques in an application.

## Application Structure

This messaging application allows users to:
- Send messages that are stored in a database
- Retrieve their messages
- Encrypt messages for secure storage

The application includes:
- JWT authentication
- Three main routes: get all messages, retrieve a single message, and post a message
- User claims from JWT tokens to associate messages with users

## Initial Setup

### Message Model

```csharp
public class Message
{
    public int Id { get; set; }
    public string Text { get; set; }
    public string User { get; set; }
}
```

### Message DTO

```csharp
public class MessageDto
{
    public string Text { get; set; }
}
```

### Encryption Service Interface

```csharp
public interface IEncryptionService
{
    string Encrypt(string plainText);
    string Decrypt(string cipherText);
}
```

## Implementing Message Encryption

### POST Route - Creating Encrypted Messages

```csharp
[HttpPost]
[Authorize]
public async Task<IActionResult> PostMessage(
    [FromBody] MessageDto dto,
    [FromServices] IEncryptionService es)
{
    // Get user from JWT claims
    var user = HttpContext.User.Claims
        .FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
    
    if (string.IsNullOrEmpty(user))
    {
        return BadRequest("User required");
    }
    
    // Create message with encrypted text
    var message = new Message
    {
        Text = es.Encrypt(dto.Text), // Encrypt before saving
        User = user
    };
    
    await _dbContext.Messages.AddAsync(message);
    await _dbContext.SaveChangesAsync();
    
    // Return the original unencrypted text to the user
    return Ok(new { Text = dto.Text, User = user });
}
```

## Implementing Message Decryption

### GET Route - Retrieving a Single Decrypted Message

```csharp
[HttpGet("{id}")]
[Authorize]
public async Task<IActionResult> GetMessage(
    int id,
    [FromServices] IEncryptionService es)
{
    // Get user from JWT
    var user = HttpContext.User.Claims
        .FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
    
    if (string.IsNullOrEmpty(user))
    {
        return BadRequest("User required");
    }
    
    // Find the message
    var message = await _dbContext.Messages.FindAsync(id);
    
    if (message == null)
    {
        return NotFound("Message does not exist");
    }
    
    // Verify the user owns this message
    if (user != message.User)
    {
        return Forbid();
    }
    
    // Decrypt and return the message
    return Ok(new 
    { 
        Id = message.Id,
        Text = es.Decrypt(message.Text),
        User = message.User 
    });
}
```

## Implementing Role-Based Authorization

### Setting Up Admin Policy

```csharp
// In Program.cs or Startup.cs
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("Admin", policy =>
    {
        policy.RequireRole("Admin");
    });
});
```

### Admin-Only Route - Get All Messages

```csharp
[HttpGet]
[Authorize(Policy = "Admin")]
public async Task<IActionResult> GetAllMessages()
{
    var messages = await _dbContext.Messages.ToListAsync();
    
    // Return encrypted messages (only admins can see all messages)
    return Ok(messages);
}
```

## Complete Controller Example

```csharp
[ApiController]
[Route("api/[controller]")]
public class MessagesController : ControllerBase
{
    private readonly ApplicationDbContext _dbContext;

    public MessagesController(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    // GET: api/messages
    [HttpGet]
    [Authorize(Policy = "Admin")]
    public async Task<IActionResult> GetAllMessages()
    {
        var messages = await _dbContext.Messages.ToListAsync();
        return Ok(messages);
    }

    // GET: api/messages/5
    [HttpGet("{id}")]
    [Authorize]
    public async Task<IActionResult> GetMessage(
        int id,
        [FromServices] IEncryptionService es)
    {
        var user = HttpContext.User.Claims
            .FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        
        if (string.IsNullOrEmpty(user))
        {
            return BadRequest("User required");
        }
        
        var message = await _dbContext.Messages.FindAsync(id);
        
        if (message == null)
        {
            return NotFound("Message does not exist");
        }
        
        if (user != message.User)
        {
            return Forbid();
        }
        
        return Ok(new 
        { 
            Id = message.Id,
            Text = es.Decrypt(message.Text),
            User = message.User 
        });
    }

    // POST: api/messages
    [HttpPost]
    [Authorize]
    public async Task<IActionResult> PostMessage(
        [FromBody] MessageDto dto,
        [FromServices] IEncryptionService es)
    {
        var user = HttpContext.User.Claims
            .FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        
        if (string.IsNullOrEmpty(user))
        {
            return BadRequest("User required");
        }
        
        var message = new Message
        {
            Text = es.Encrypt(dto.Text),
            User = user
        };
        
        await _dbContext.Messages.AddAsync(message);
        await _dbContext.SaveChangesAsync();
        
        return Ok(new { Text = dto.Text, User = user });
    }
}
```

## Security Features Implemented

### 1. **Encryption at Rest**
Messages are encrypted before being stored in the database, protecting data if the database is compromised.

### 2. **Role-Based Access Control**
Only users with the "Admin" role can retrieve all messages.

### 3. **User-Specific Access**
Users can only retrieve their own messages, verified through JWT claims.

### 4. **JWT Authentication**
All routes require valid JWT tokens with appropriate claims.

## Key Security Benefits

- **Data at Rest**: Messages are encrypted in the database
- **Authorization**: Only authorized users can access specific endpoints
- **User Isolation**: Users can only access their own messages
- **Admin Oversight**: Administrators can view all messages when necessary
- **Decryption on Demand**: Messages are only decrypted when retrieved by authorized users

## Testing the Application

### Create a Message (Returns Decrypted)
```http
POST /api/messages
Authorization: Bearer {jwt_token}
Content-Type: application/json

{
    "text": "Hello, this is a secret message!"
}
```

### Get All Messages (Admin Only - Returns Encrypted)
```http
GET /api/messages
Authorization: Bearer {admin_jwt_token}
```

### Get Specific Message (Returns Decrypted if User Matches)
```http
GET /api/messages/1
Authorization: Bearer {jwt_token}
```

## Conclusion

This implementation provides a solid foundation for a secure, production-ready application by ensuring that:
- Data is encrypted at rest
- Only users with correct permissions can access data through the API
- User authentication and authorization are properly enforced
- Messages remain private and secure throughout their lifecycle