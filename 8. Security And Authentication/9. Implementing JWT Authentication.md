# Implementing JWT Authentication in ASP.NET Core

## Overview

This guide walks through the process of implementing basic JWT authentication in a .NET application. We'll cover installation, configuration, and usage with practical examples.

## Step 1: Install Required Package

First, add the JWT Bearer authentication package to your project:

```bash
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

## Step 2: Configure JWT Authentication

### Basic Configuration

Add JWT Bearer authentication to your application in `Program.cs`:

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes("dont-ever-leave-a-key-like-this-123456789")
            ),
            ValidateIssuerSigningKey = true,
            ValidateIssuer = false,        // Set to true in production
            ValidateAudience = false,      // Set to true in production
            ValidateLifetime = false       // Set to true in production
        };
    });

builder.Services.AddAuthorization();

var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();

app.MapGet("/", () => "Root route - public access");

app.MapGet("/secure", () => "This is a secure route")
    .RequireAuthorization();

app.Run();
```

### Production-Ready Configuration

⚠️ **IMPORTANT:** Never hardcode secrets in your code! Use configuration files instead.

**appsettings.json:**
```json
{
  "Jwt": {
    "SecretKey": "your-super-secret-key-at-least-32-characters-long",
    "Issuer": "your-app-name",
    "Audience": "your-app-audience"
  }
}
```

**Program.cs (Production):**
```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        var jwtSettings = builder.Configuration.GetSection("Jwt");
        var secretKey = jwtSettings["SecretKey"];

        options.TokenValidationParameters = new TokenValidationParameters
        {
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(secretKey)
            ),
            ValidateIssuerSigningKey = true,
            ValidIssuer = jwtSettings["Issuer"],
            ValidateIssuer = true,
            ValidAudience = jwtSettings["Audience"],
            ValidateAudience = true,
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
    });
```

## Step 3: Understanding Token Validation Parameters

### Key Configuration Properties

| Property                   | Purpose                                            | Production Setting                   |
| -------------------------- | -------------------------------------------------- | ------------------------------------ |
| `IssuerSigningKey`         | The secret key used to verify token signatures     | **Required** - Minimum 32 characters |
| `ValidateIssuerSigningKey` | Ensures the token was signed with your key         | `true`                               |
| `ValidateIssuer`           | Verifies the token was issued by a trusted source  | `true`                               |
| `ValidateAudience`         | Ensures the token is intended for your application | `true`                               |
| `ValidateLifetime`         | Checks if the token has expired                    | `true`                               |

### Simplified Configuration (Development Only)

```csharp
options.TokenValidationParameters = new TokenValidationParameters
{
    IssuerSigningKey = new SymmetricSecurityKey(
        Encoding.UTF8.GetBytes("your-secret-key-here")
    ),
    ValidateIssuerSigningKey = true,
    ValidateIssuer = false,      // ⚠️ Only for testing!
    ValidateAudience = false,    // ⚠️ Only for testing!
    ValidateLifetime = false     // ⚠️ Only for testing!
};
```

## Step 4: Creating Protected Routes

### Minimal API Example

```csharp
// Public route - no authentication required
app.MapGet("/", () => "Welcome to the public API");

// Protected route - requires authentication
app.MapGet("/secure", () => "This is a secure route")
    .RequireAuthorization();

// Protected route with user information
app.MapGet("/profile", (HttpContext context) =>
{
    var userId = context.User.FindFirst("sub")?.Value;
    var userName = context.User.FindFirst("name")?.Value;
    
    return Results.Ok(new { userId, userName });
})
.RequireAuthorization();
```

### Controller Example

```csharp
[ApiController]
[Route("api/[controller]")]
public class DataController : ControllerBase
{
    // Public endpoint
    [HttpGet("public")]
    public IActionResult Public()
    {
        return Ok("This is public data");
    }

    // Protected endpoint
    [Authorize]
    [HttpGet("secure")]
    public IActionResult Secure()
    {
        var userId = User.FindFirst("sub")?.Value;
        return Ok($"Secure data for user: {userId}");
    }

    // Role-based authorization
    [Authorize(Roles = "Admin")]
    [HttpGet("admin")]
    public IActionResult Admin()
    {
        return Ok("Admin-only data");
    }
}
```

## Step 5: Making Authenticated Requests

### HTTP Request Format

To authenticate requests, include the JWT in the `Authorization` header with the `Bearer` prefix:

```http
GET https://localhost:5001/secure
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### Testing with .http Files

**requests.http:**
```http
### Public route (no auth required)
GET https://localhost:5001/
###

### Protected route (requires JWT)
GET https://localhost:5001/secure
Authorization: Bearer {{token}}
###
```

### C# HttpClient Example

```csharp
using System.Net.Http.Headers;

var client = new HttpClient();
var token = "your-jwt-token-here";

client.DefaultRequestHeaders.Authorization = 
    new AuthenticationHeaderValue("Bearer", token);

var response = await client.GetAsync("https://localhost:5001/secure");
var content = await response.Content.ReadAsStringAsync();
```

### JavaScript Fetch Example

```javascript
const token = "your-jwt-token-here";

fetch("https://localhost:5001/secure", {
    headers: {
        "Authorization": `Bearer ${token}`
    }
})
.then(response => response.text())
.then(data => console.log(data));
```

## Step 6: Generating JWTs

### Using JWT.io (Testing Only)

For testing purposes, you can generate tokens at [JWT.io](https://jwt.io):

1. Set the algorithm to HS256
2. Enter your payload data
3. Enter your secret key in the "Verify Signature" section
4. Copy the encoded token

**Example Payload:**
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "email": "john@example.com",
  "role": "Admin"
}
```

### Creating a Token Endpoint

```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IConfiguration _configuration;

    public AuthController(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    [HttpPost("login")]
    public IActionResult Login([FromBody] LoginRequest request)
    {
        // Validate credentials (simplified - use proper authentication!)
        if (!ValidateUser(request.Username, request.Password))
        {
            return Unauthorized("Invalid credentials");
        }

        var token = GenerateToken(request.Username);
        return Ok(new { token });
    }

    private string GenerateToken(string username)
    {
        var securityKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(_configuration["Jwt:SecretKey"])
        );
        var credentials = new SigningCredentials(
            securityKey, 
            SecurityAlgorithms.HmacSha256
        );

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, username),
            new Claim(JwtRegisteredClaimNames.Email, $"{username}@example.com"),
            new Claim(ClaimTypes.Role, "User")
        };

        var token = new JwtSecurityToken(
            issuer: _configuration["Jwt:Issuer"],
            audience: _configuration["Jwt:Audience"],
            claims: claims,
            expires: DateTime.UtcNow.AddHours(1),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    private bool ValidateUser(string username, string password)
    {
        // Implement proper user validation here
        // This is just a placeholder
        return username == "demo" && password == "password";
    }
}

public record LoginRequest(string Username, string Password);
```

## Step 7: Extracting Claims from Tokens

### Accessing User Information

```csharp
[Authorize]
[HttpGet("profile")]
public IActionResult GetProfile()
{
    // Access claims from the authenticated user
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var userName = User.FindFirst(ClaimTypes.Name)?.Value;
    var email = User.FindFirst(ClaimTypes.Email)?.Value;
    var roles = User.FindAll(ClaimTypes.Role).Select(c => c.Value);

    return Ok(new
    {
        UserId = userId,
        UserName = userName,
        Email = email,
        Roles = roles
    });
}
```

### Custom Claim Extraction

```csharp
public static class ClaimsExtensions
{
    public static string GetUserId(this ClaimsPrincipal user)
    {
        return user.FindFirst(ClaimTypes.NameIdentifier)?.Value 
            ?? user.FindFirst("sub")?.Value;
    }

    public static string GetEmail(this ClaimsPrincipal user)
    {
        return user.FindFirst(ClaimTypes.Email)?.Value;
    }

    public static bool HasRole(this ClaimsPrincipal user, string role)
    {
        return user.IsInRole(role);
    }
}

// Usage
[Authorize]
[HttpGet("data")]
public IActionResult GetData()
{
    var userId = User.GetUserId();
    return Ok($"Data for user: {userId}");
}
```

## How JWT Authentication Works

### The Authentication Flow

1. **Client sends request** with JWT in Authorization header
2. **Middleware intercepts** the request and extracts the token
3. **Token is decoded** into header and payload (Base64 URL decoding)
4. **Signature is verified** using the secret key
5. **Validation checks** are performed (issuer, audience, lifetime)
6. **Claims are extracted** and made available via `User` property
7. **Request proceeds** to the endpoint if valid, or returns 401 if invalid

### Token Tampering Protection

```
Original Token (Valid):
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.signature123

Modified Payload (Invalid):
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5ODc2NTQzMjEwIn0.signature123
                                        ↑ Changed data                  ↑ Old signature
                                        
Result: Authentication fails - signature doesn't match modified data
```

## Best Practices

### ✅ DO

- **Store secrets securely** in configuration files, environment variables, or key vaults
- **Use HTTPS** to prevent token interception
- **Set appropriate token expiration** (typically 15-60 minutes)
- **Implement refresh tokens** for longer sessions
- **Validate issuer and audience** in production
- **Use strong secret keys** (minimum 32 characters)
- **Enable lifetime validation** to reject expired tokens

### ❌ DON'T

- **Never hardcode secrets** in your source code
- **Don't store sensitive data** in JWT payload (it's not encrypted)
- **Don't commit secrets** to version control
- **Don't use weak secret keys** or short keys
- **Don't disable validation** in production (issuer, audience, lifetime)
- **Don't reuse tokens** after they've expired

## Working with External JWT Issuers

Your application can accept JWTs from external identity providers like:

- **Microsoft Identity Platform** (Azure AD)
- **Auth0**
- **Okta**
- **Google**
- **Custom authentication services**

As long as the token is signed with your secret key (or you configure your app to trust the external issuer's public key), the token will be valid.

### Example: Trusting Multiple Issuers

```csharp
options.TokenValidationParameters = new TokenValidationParameters
{
    ValidateIssuerSigningKey = true,
    IssuerSigningKey = new SymmetricSecurityKey(
        Encoding.UTF8.GetBytes(secretKey)
    ),
    ValidateIssuer = true,
    ValidIssuers = new[]
    {
        "https://your-app.com",
        "https://auth0.com/your-tenant",
        "https://login.microsoftonline.com/your-tenant"
    },
    ValidateAudience = true,
    ValidAudience = "your-app-api"
};
```

## Troubleshooting

### Common Issues

**401 Unauthorized:**
- Token is missing or malformed
- Token signature is invalid
- Token has expired
- Issuer/audience validation failed

**403 Forbidden:**
- User is authenticated but lacks required permissions/roles

**Invalid Signature:**
```csharp
// Check that your secret key matches the one used to sign the token
var key = Encoding.UTF8.GetBytes("your-secret-key");
// Key must be at least 32 characters for HS256
```

## Quick Recap

To implement JWT authentication in ASP.NET Core:

1. Install `Microsoft.AspNetCore.Authentication.JwtBearer`
2. Configure authentication with `AddJwtBearer()`
3. Set the `IssuerSigningKey` using a symmetric security key
4. Enable validation parameters (issuer, audience, lifetime)
5. Add `UseAuthentication()` and `UseAuthorization()` middleware
6. Protect routes with `[Authorize]` or `.RequireAuthorization()`
7. Pass tokens using `Authorization: Bearer {token}` header

JWTs are **stateless tokens** that can come from any issuer with your secret key, making them perfect for distributed systems and microservices architectures.