# JWT Security Best Practices in .NET

## Overview

This guide covers security best practices for implementing JSON Web Tokens (JWTs) in .NET applications. We'll explore how to properly store secret keys, validate token properties, and use built-in .NET tools for secure JWT management.

## Securing Your JWT Key

### Problem: Hard-coded Keys

Never store your JWT signing key directly in code:

```csharp
// ❌ BAD: Never do this
var key = "my-super-secret-key-12345";
```

If someone gains access to your codebase, they'll have both your code and your signing key, making your application vulnerable.

---

## Solution 1: App Settings (appsettings.json)

### Step 1: Move Key to Configuration

Add your key to `appsettings.json`:

```json
{
  "JWTKey": "your-secret-key-value-here"
}
```

### Step 2: Access from Configuration

```csharp
var jwtKey = builder.Configuration["JWTKey"];

// Use the key in your JWT configuration
var key = Encoding.UTF8.GetBytes(jwtKey);
```

**Important:** When using this approach, add `appsettings.json` to your `.gitignore` file to prevent committing secrets to version control.

---

## Solution 2: User Secrets (Recommended for Development)

User Secrets is a .NET feature that stores sensitive data outside your project directory.

### Initialize User Secrets

```bash
dotnet user-secrets init
```

This adds a `UserSecretsId` to your `.csproj` file:

```xml
<PropertyGroup>
  <UserSecretsId>generated-guid-here</UserSecretsId>
</PropertyGroup>
```

### Set a Secret

```bash
dotnet user-secrets set "MyOtherJWTKey" "your-secret-value-here"
```

### List All Secrets

```bash
dotnet user-secrets list
```

### Access in Code

```csharp
var jwtKey = builder.Configuration["MyOtherJWTKey"];
```

**Note:** User secrets are stored in:
- Windows: `%APPDATA%\Microsoft\UserSecrets\<user_secrets_id>\secrets.json`
- macOS/Linux: `~/.microsoft/usersecrets/<user_secrets_id>/secrets.json`

---

## JWT Validation Parameters

### Validate Lifetime (Critical)

Always validate token expiration to limit potential damage from stolen tokens.

```csharp
new TokenValidationParameters
{
    ValidateLifetime = true, // ✅ Enable this
    IssuerSigningKey = new SymmetricSecurityKey(key),
    ValidateIssuerSigningKey = true
};
```

### JWT Token with Expiration Claims

```csharp
var tokenDescriptor = new SecurityTokenDescriptor
{
    Subject = new ClaimsIdentity(new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, "user-id"),
        new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString()),
        new Claim(JwtRegisteredClaimNames.Exp, DateTimeOffset.UtcNow.AddMinutes(30).ToUnixTimeSeconds().ToString())
    }),
    SigningCredentials = new SigningCredentials(
        new SymmetricSecurityKey(key),
        SecurityAlgorithms.HmacSha256Signature
    )
};
```

**Best Practice:** Set short expiration times (15-60 minutes) and implement refresh tokens for longer sessions.

---

## Validate Issuer and Audience

These properties help prevent configuration errors and ensure tokens are used in the correct context.

### Configuration

```csharp
new TokenValidationParameters
{
    ValidateIssuer = true,
    ValidIssuer = "my-issuer",
    
    ValidateAudience = true,
    ValidAudience = "https://localhost:5030",
    
    ValidateLifetime = true,
    IssuerSigningKey = new SymmetricSecurityKey(key),
    ValidateIssuerSigningKey = true
};
```

### Creating Token with Issuer and Audience

```csharp
var tokenDescriptor = new SecurityTokenDescriptor
{
    Subject = new ClaimsIdentity(new[]
    {
        new Claim(JwtRegisteredClaimNames.Aud, "https://localhost:5030"),
        new Claim(JwtRegisteredClaimNames.Iss, "my-issuer")
    }),
    SigningCredentials = new SigningCredentials(
        new SymmetricSecurityKey(key),
        SecurityAlgorithms.HmacSha256Signature
    )
};
```

**Use Cases:**
- **Issuer:** Identifies who created the token (useful with multiple authentication providers)
- **Audience:** Specifies the intended recipient (typically your application's domain)

---

## .NET User-JWTs Tool

The `dotnet user-jwts` command provides convenient JWT generation for development and testing.

### Create a JWT

```bash
dotnet user-jwts create --audience "test-audience" --issuer "my-issuer"
```

### List All JWTs

```bash
dotnet user-jwts list
```

### Get the Signing Key

```bash
dotnet user-jwts key
```

### Using User-JWT Keys in Code

The key is stored Base64-encoded, so you need to decode it:

```csharp
var base64Key = builder.Configuration["Authentication:Schemes:Bearer:SigningKeys:0:Value"];
var key = Convert.FromBase64String(base64Key);

var validationParameters = new TokenValidationParameters
{
    ValidateIssuer = true,
    ValidIssuer = builder.Configuration["Authentication:Schemes:Bearer:ValidIssuer"],
    
    ValidateAudience = true,
    ValidAudience = builder.Configuration["Authentication:Schemes:Bearer:ValidAudience"],
    
    IssuerSigningKey = new SymmetricSecurityKey(key),
    ValidateIssuerSigningKey = true,
    ValidateLifetime = true
};
```

**Note:** The `dotnet user-jwts` tool automatically updates your `appsettings.json` and user secrets with the appropriate configuration.

---

## Complete Example

Here's a complete example of secure JWT configuration:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Get JWT key from user secrets
var jwtKey = builder.Configuration["JWTKey"] 
    ?? throw new InvalidOperationException("JWT Key not configured");

var key = Encoding.UTF8.GetBytes(jwtKey);

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidIssuer = "my-issuer",
            
            ValidateAudience = true,
            ValidAudience = "https://localhost:5030",
            
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero, // Optional: remove default 5-minute tolerance
            
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key)
        };
    });

var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();
```

---

## Security Checklist

- ✅ Never hard-code JWT keys in source code
- ✅ Use User Secrets for development, secure vault services for production
- ✅ Always validate token lifetime (`ValidateLifetime = true`)
- ✅ Set short expiration times (15-60 minutes recommended)
- ✅ Validate issuer and audience when appropriate
- ✅ Use `.gitignore` to exclude secrets from version control
- ✅ Implement refresh tokens for longer sessions
- ✅ Use HTTPS to prevent token interception

---

## Production Considerations

For production environments:

1. **Use Managed Secret Services:**
   - Azure Key Vault
   - AWS Secrets Manager
   - HashiCorp Vault

2. **Never commit secrets to version control**

3. **Implement token refresh mechanisms** to maintain user sessions securely

4. **Consider cookies over JWTs** when possible - cookies with `HttpOnly` and `Secure` flags offer better security in many scenarios

---

## Summary

JWTs are powerful authentication tools, but require careful implementation. Always:
- Store keys securely outside your codebase
- Validate token lifetimes and claims
- Use short expiration times with refresh tokens
- Follow the principle of least privilege

When possible, prefer secure cookies for authentication. Use JWTs when cookies aren't feasible (e.g., mobile apps, cross-domain scenarios).