# Automatic Access Token Refresh in C#

Yes! There are several ways to automatically refresh access tokens in C#. Here are the most common approaches:

---

## 1. JWT Bearer Events (Recommended for APIs)

ASP.NET Core provides `JwtBearerEvents` that allow you to intercept token validation and automatically refresh expired tokens.

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Text;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);
        
        var jwtSecret = builder.Configuration["JWT_SECRET"];
        var key = Encoding.UTF8.GetBytes(jwtSecret);
        
        builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =>
            {
                options.RequireHttpsMetadata = true;
                options.SaveToken = true;
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ValidateLifetime = true,
                    ClockSkew = TimeSpan.Zero
                };
                
                // Automatic token refresh on expiration
                options.Events = new JwtBearerEvents
                {
                    OnAuthenticationFailed = async context =>
                    {
                        // Check if token is expired
                        if (context.Exception is SecurityTokenExpiredException)
                        {
                            // Try to refresh the token
                            var refreshToken = context.Request.Cookies["refreshToken"];
                            
                            if (!string.IsNullOrEmpty(refreshToken))
                            {
                                var tokenService = context.HttpContext.RequestServices
                                    .GetRequiredService<ITokenService>();
                                
                                try
                                {
                                    var newAccessToken = await tokenService.RefreshAccessTokenAsync(refreshToken);
                                    
                                    // Add new token to response header
                                    context.Response.Headers.Add("X-New-Access-Token", newAccessToken);
                                    
                                    // Validate the new token
                                    var tokenHandler = new JwtSecurityTokenHandler();
                                    var principal = tokenHandler.ValidateToken(
                                        newAccessToken, 
                                        options.TokenValidationParameters, 
                                        out var validatedToken);
                                    
                                    context.Principal = principal;
                                    context.Success();
                                }
                                catch
                                {
                                    context.Fail("Token refresh failed");
                                }
                            }
                        }
                    },
                    
                    OnMessageReceived = context =>
                    {
                        // Check if token is about to expire (within 2 minutes)
                        var token = context.Request.Headers["Authorization"]
                            .FirstOrDefault()?.Split(" ").Last();
                        
                        if (!string.IsNullOrEmpty(token))
                        {
                            var tokenHandler = new JwtSecurityTokenHandler();
                            var jwtToken = tokenHandler.ReadJwtToken(token);
                            
                            var expirationTime = jwtToken.ValidTo;
                            var timeUntilExpiration = expirationTime - DateTime.UtcNow;
                            
                            // If token expires in less than 2 minutes, set flag
                            if (timeUntilExpiration.TotalMinutes < 2)
                            {
                                context.HttpContext.Items["TokenNearExpiration"] = true;
                            }
                        }
                        
                        return Task.CompletedTask;
                    },
                    
                    OnTokenValidated = async context =>
                    {
                        // Proactively refresh token if it's about to expire
                        if (context.HttpContext.Items["TokenNearExpiration"] as bool? == true)
                        {
                            var refreshToken = context.Request.Cookies["refreshToken"];
                            
                            if (!string.IsNullOrEmpty(refreshToken))
                            {
                                var tokenService = context.HttpContext.RequestServices
                                    .GetRequiredService<ITokenService>();
                                
                                try
                                {
                                    var newAccessToken = await tokenService.RefreshAccessTokenAsync(refreshToken);
                                    context.Response.Headers.Add("X-New-Access-Token", newAccessToken);
                                }
                                catch
                                {
                                    // Log error but don't fail the request
                                }
                            }
                        }
                    }
                };
            });
        
        builder.Services.AddScoped<ITokenService, TokenService>();
        builder.Services.AddControllers();
        
        var app = builder.Build();
        
        app.UseAuthentication();
        app.UseAuthorization();
        app.MapControllers();
        
        app.Run();
    }
}
```

---

## 2. Custom Middleware for Token Refresh

Create a dedicated middleware that checks token expiration and automatically refreshes it.

```csharp
using Microsoft.AspNetCore.Http;
using System.IdentityModel.Tokens.Jwt;
using System.Text;
using Microsoft.IdentityModel.Tokens;

public class TokenRefreshMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<TokenRefreshMiddleware> _logger;
    
    public TokenRefreshMiddleware(RequestDelegate next, ILogger<TokenRefreshMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context, ITokenService tokenService, IConfiguration configuration)
    {
        var token = context.Request.Headers["Authorization"].FirstOrDefault()?.Split(" ").Last();
        
        if (!string.IsNullOrEmpty(token))
        {
            try
            {
                var tokenHandler = new JwtSecurityTokenHandler();
                var jwtToken = tokenHandler.ReadJwtToken(token);
                
                var expirationTime = jwtToken.ValidTo;
                var timeUntilExpiration = expirationTime - DateTime.UtcNow;
                
                // If token expires in less than 5 minutes, refresh it
                if (timeUntilExpiration.TotalMinutes < 5 && timeUntilExpiration.TotalMinutes > 0)
                {
                    var refreshToken = context.Request.Cookies["refreshToken"];
                    
                    if (!string.IsNullOrEmpty(refreshToken))
                    {
                        try
                        {
                            var newAccessToken = await tokenService.RefreshAccessTokenAsync(refreshToken);
                            
                            // Add new token to response header
                            context.Response.Headers.Add("X-New-Access-Token", newAccessToken);
                            context.Response.Headers.Add("X-Token-Refreshed", "true");
                            
                            _logger.LogInformation("Access token refreshed proactively");
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(ex, "Failed to refresh access token");
                        }
                    }
                }
                // If token is already expired, try to refresh
                else if (timeUntilExpiration.TotalMinutes <= 0)
                {
                    var refreshToken = context.Request.Cookies["refreshToken"];
                    
                    if (!string.IsNullOrEmpty(refreshToken))
                    {
                        try
                        {
                            var newAccessToken = await tokenService.RefreshAccessTokenAsync(refreshToken);
                            
                            // Replace the Authorization header with new token
                            context.Request.Headers["Authorization"] = $"Bearer {newAccessToken}";
                            context.Response.Headers.Add("X-New-Access-Token", newAccessToken);
                            context.Response.Headers.Add("X-Token-Refreshed", "true");
                            
                            _logger.LogInformation("Expired access token refreshed automatically");
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(ex, "Failed to refresh expired token");
                            context.Response.StatusCode = 401;
                            await context.Response.WriteAsJsonAsync(new { error = "Token expired and refresh failed" });
                            return;
                        }
                    }
                    else
                    {
                        context.Response.StatusCode = 401;
                        await context.Response.WriteAsJsonAsync(new { error = "Token expired and no refresh token available" });
                        return;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in token refresh middleware");
            }
        }
        
        await _next(context);
    }
}

// Extension method for easy registration
public static class TokenRefreshMiddlewareExtensions
{
    public static IApplicationBuilder UseTokenRefresh(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<TokenRefreshMiddleware>();
    }
}

// Register in Program.cs
var app = builder.Build();

app.UseAuthentication();
app.UseTokenRefresh(); // Add before UseAuthorization
app.UseAuthorization();
app.MapControllers();
```

---

## 3. Token Service Interface and Implementation

```csharp
public interface ITokenService
{
    string GenerateAccessToken(User user);
    string GenerateRefreshToken(User user);
    Task<string> RefreshAccessTokenAsync(string refreshToken);
    ClaimsPrincipal ValidateToken(string token);
}

public class TokenService : ITokenService
{
    private readonly IConfiguration _configuration;
    private readonly IUserRepository _userRepository;
    private readonly ILogger<TokenService> _logger;
    
    public TokenService(
        IConfiguration configuration, 
        IUserRepository userRepository,
        ILogger<TokenService> logger)
    {
        _configuration = configuration;
        _userRepository = userRepository;
        _logger = logger;
    }
    
    public string GenerateAccessToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_configuration["JWT_SECRET"]);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id.ToString()),
                new Claim(ClaimTypes.Role, user.Role),
                new Claim(ClaimTypes.Email, user.Email)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    public string GenerateRefreshToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_configuration["REFRESH_TOKEN_SECRET"]);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id.ToString()),
                new Claim("tokenId", Guid.NewGuid().ToString()) // Unique identifier
            }),
            Expires = DateTime.UtcNow.AddDays(7),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    public async Task<string> RefreshAccessTokenAsync(string refreshToken)
    {
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_configuration["REFRESH_TOKEN_SECRET"]);
            
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = false,
                ValidateAudience = false,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };
            
            var principal = tokenHandler.ValidateToken(refreshToken, validationParameters, out _);
            var userId = principal.FindFirst("userId")?.Value;
            
            if (string.IsNullOrEmpty(userId))
            {
                throw new SecurityTokenException("Invalid refresh token");
            }
            
            // Get user from database
            var user = await _userRepository.GetUserByIdAsync(userId);
            
            if (user == null)
            {
                throw new SecurityTokenException("User not found");
            }
            
            // Generate new access token
            var newAccessToken = GenerateAccessToken(user);
            
            _logger.LogInformation("Access token refreshed for user {UserId}", userId);
            
            return newAccessToken;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to refresh access token");
            throw;
        }
    }
    
    public ClaimsPrincipal ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_configuration["JWT_SECRET"]);
        
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = false,
            ValidateAudience = false,
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
        
        return tokenHandler.ValidateToken(token, validationParameters, out _);
    }
}
```

---

## 4. Action Filter for Automatic Token Refresh

Create an action filter that runs before controller actions to check and refresh tokens.

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using System.IdentityModel.Tokens.Jwt;

public class AutoRefreshTokenAttribute : ActionFilterAttribute
{
    private readonly int _minutesBeforeExpiration;
    
    public AutoRefreshTokenAttribute(int minutesBeforeExpiration = 5)
    {
        _minutesBeforeExpiration = minutesBeforeExpiration;
    }
    
    public override async Task OnActionExecutionAsync(
        ActionExecutingContext context, 
        ActionExecutionDelegate next)
    {
        var token = context.HttpContext.Request.Headers["Authorization"]
            .FirstOrDefault()?.Split(" ").Last();
        
        if (!string.IsNullOrEmpty(token))
        {
            try
            {
                var tokenHandler = new JwtSecurityTokenHandler();
                var jwtToken = tokenHandler.ReadJwtToken(token);
                
                var expirationTime = jwtToken.ValidTo;
                var timeUntilExpiration = expirationTime - DateTime.UtcNow;
                
                // Check if token is about to expire
                if (timeUntilExpiration.TotalMinutes < _minutesBeforeExpiration)
                {
                    var refreshToken = context.HttpContext.Request.Cookies["refreshToken"];
                    
                    if (!string.IsNullOrEmpty(refreshToken))
                    {
                        var tokenService = context.HttpContext.RequestServices
                            .GetRequiredService<ITokenService>();
                        
                        try
                        {
                            var newAccessToken = await tokenService.RefreshAccessTokenAsync(refreshToken);
                            
                            context.HttpContext.Response.Headers.Add("X-New-Access-Token", newAccessToken);
                            context.HttpContext.Response.Headers.Add("X-Token-Refreshed", "true");
                        }
                        catch
                        {
                            // Log but don't fail the request
                        }
                    }
                }
            }
            catch
            {
                // Token validation failed, let authentication middleware handle it
            }
        }
        
        await next();
    }
}

// Usage in controllers
[ApiController]
[Route("api/[controller]")]
public class SecureController : ControllerBase
{
    [HttpGet]
    [Authorize]
    [AutoRefreshToken(minutesBeforeExpiration: 5)]
    public IActionResult GetData()
    {
        return Ok(new { message = "Success" });
    }
}

// Or apply globally
builder.Services.AddControllers(options =>
{
    options.Filters.Add(new AutoRefreshTokenAttribute(minutesBeforeExpiration: 5));
});
```

---

## 5. Background Service for Proactive Token Management

For long-running connections or SignalR, use a background service.

```csharp
using Microsoft.Extensions.Hosting;
using System.Collections.Concurrent;
using System.Threading;

public class ThreadSafeTokenRefreshBackgroundService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<ThreadSafeTokenRefreshBackgroundService> _logger;
    
    // ConcurrentDictionary is thread-safe for basic operations
    private readonly ConcurrentDictionary<string, TokenRefreshInfo> _tokenRegistry;
    
    // SemaphoreSlim for coordinating complex operations
    private readonly SemaphoreSlim _refreshLock = new SemaphoreSlim(1, 1);
    
    public ThreadSafeTokenRefreshBackgroundService(
        IServiceProvider serviceProvider,
        ILogger<ThreadSafeTokenRefreshBackgroundService> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
        _tokenRegistry = new ConcurrentDictionary<string, TokenRefreshInfo>();
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Token Refresh Background Service started");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await RefreshExpiringTokensAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
            }
            catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
            {
                // Normal shutdown
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in token refresh background service");
            }
        }
        
        _logger.LogInformation("Token Refresh Background Service stopped");
    }
    
    private async Task RefreshExpiringTokensAsync(CancellationToken cancellationToken)
    {
        // Prevent multiple simultaneous refresh operations
        if (!await _refreshLock.WaitAsync(0, cancellationToken))
        {
            _logger.LogDebug("Refresh already in progress, skipping");
            return;
        }
        
        try
        {
            using var scope = _serviceProvider.CreateScope();
            var tokenService = scope.ServiceProvider.GetRequiredService<ITokenService>();
            
            var now = DateTime.UtcNow;
            
            // Create a snapshot of tokens that need refresh
            // This avoids holding locks while doing I/O operations
            var tokensToRefresh = _tokenRegistry
                .Where(kvp => kvp.Value.ExpiresAt - now < TimeSpan.FromMinutes(5))
                .Select(kvp => new { UserId = kvp.Key, Info = kvp.Value })
                .ToList();
            
            foreach (var tokenInfo in tokensToRefresh)
            {
                if (cancellationToken.IsCancellationRequested)
                    break;
                
                try
                {
                    var newToken = await tokenService.RefreshAccessTokenAsync(
                        tokenInfo.Info.RefreshToken);
                    
                    var tokenHandler = new JwtSecurityTokenHandler();
                    var jwtToken = tokenHandler.ReadJwtToken(newToken);
                    
                    // Use AddOrUpdate for atomic update
                    _tokenRegistry.AddOrUpdate(
                        tokenInfo.UserId,
                        // Add factory - shouldn't happen as we're updating
                        new TokenRefreshInfo
                        {
                            AccessToken = newToken,
                            RefreshToken = tokenInfo.Info.RefreshToken,
                            ExpiresAt = jwtToken.ValidTo,
                            LastRefreshed = DateTime.UtcNow
                        },
                        // Update factory - atomic operation
                        (key, existingInfo) => new TokenRefreshInfo
                        {
                            AccessToken = newToken,
                            RefreshToken = tokenInfo.Info.RefreshToken,
                            ExpiresAt = jwtToken.ValidTo,
                            LastRefreshed = DateTime.UtcNow
                        });
                    
                    _logger.LogInformation(
                        "Token refreshed for user {UserId}", 
                        tokenInfo.UserId);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(
                        ex, 
                        "Failed to refresh token for user {UserId}", 
                        tokenInfo.UserId);
                    
                    // Remove failed token atomically
                    _tokenRegistry.TryRemove(tokenInfo.UserId, out _);
                }
            }
        }
        finally
        {
            _refreshLock.Release();
        }
    }
    
    /// <summary>
    /// Thread-safe token registration
    /// </summary>
    public void RegisterToken(string userId, string accessToken, string refreshToken)
    {
        if (string.IsNullOrEmpty(userId))
            throw new ArgumentNullException(nameof(userId));
        
        if (string.IsNullOrEmpty(accessToken))
            throw new ArgumentNullException(nameof(accessToken));
        
        if (string.IsNullOrEmpty(refreshToken))
            throw new ArgumentNullException(nameof(refreshToken));
        
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var jwtToken = tokenHandler.ReadJwtToken(accessToken);
            
            var newInfo = new TokenRefreshInfo
            {
                AccessToken = accessToken,
                RefreshToken = refreshToken,
                ExpiresAt = jwtToken.ValidTo,
                LastRefreshed = DateTime.UtcNow
            };
            
            // AddOrUpdate is atomic - thread-safe
            _tokenRegistry.AddOrUpdate(
                userId,
                newInfo,  // Add factory
                (key, oldValue) => newInfo  // Update factory
            );
            
            _logger.LogDebug("Token registered for user {UserId}", userId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to register token for user {UserId}", userId);
            throw;
        }
    }
    
    /// <summary>
    /// Thread-safe token retrieval
    /// </summary>
    public string GetCurrentToken(string userId)
    {
        if (string.IsNullOrEmpty(userId))
            return null;
        
        // TryGetValue is atomic and thread-safe
        if (_tokenRegistry.TryGetValue(userId, out var info))
        {
            // Check if token is still valid
            if (info.ExpiresAt > DateTime.UtcNow)
            {
                return info.AccessToken;
            }
            
            _logger.LogWarning(
                "Token for user {UserId} has expired", 
                userId);
            
            // Remove expired token
            _tokenRegistry.TryRemove(userId, out _);
        }
        
        return null;
    }
    
    /// <summary>
    /// Thread-safe token removal
    /// </summary>
    public bool UnregisterToken(string userId)
    {
        if (string.IsNullOrEmpty(userId))
            return false;
        
        return _tokenRegistry.TryRemove(userId, out _);
    }
    
    /// <summary>
    /// Get statistics (thread-safe snapshot)
    /// </summary>
    public TokenRegistryStats GetStatistics()
    {
        var now = DateTime.UtcNow;
        var snapshot = _tokenRegistry.ToArray(); // Create snapshot
        
        return new TokenRegistryStats
        {
            TotalTokens = snapshot.Length,
            ExpiringTokens = snapshot.Count(kvp => 
                kvp.Value.ExpiresAt - now < TimeSpan.FromMinutes(5)),
            ExpiredTokens = snapshot.Count(kvp => 
                kvp.Value.ExpiresAt <= now)
        };
    }
    
    public override void Dispose()
    {
        _refreshLock?.Dispose();
        base.Dispose();
    }
}

/// <summary>
/// Immutable token info - prevents modification after creation
/// </summary>
public class TokenRefreshInfo
{
    public string AccessToken { get; init; }
    public string RefreshToken { get; init; }
    public DateTime ExpiresAt { get; init; }
    public DateTime LastRefreshed { get; init; }
}

public class TokenRegistryStats
{
    public int TotalTokens { get; init; }
    public int ExpiringTokens { get; init; }
    public int ExpiredTokens { get; init; }
}

// Register in Program.cs
builder.Services.AddHostedService<TokenRefreshBackgroundService>();
builder.Services.AddSingleton<TokenRefreshBackgroundService>();
```

---

## Client-Side Handling (Important!)

The client must handle the new token from response headers:

```javascript
// JavaScript/TypeScript example
async function apiCall(url, options = {}) {
    const response = await fetch(url, {
        ...options,
        headers: {
            'Authorization': `Bearer ${getAccessToken()}`,
            ...options.headers
        },
        credentials: 'include' // Include cookies for refresh token
    });
    
    // Check if token was refreshed
    const newToken = response.headers.get('X-New-Access-Token');
    if (newToken) {
        console.log('Token refreshed automatically');
        saveAccessToken(newToken);
    }
    
    return response;
}
```

---

## Summary

**Best Approach:** Use **JWT Bearer Events** (#1) combined with **Custom Middleware** (#2) for the most robust solution:

- **JWT Bearer Events** handle authentication-level token refresh
- **Custom Middleware** handles proactive refresh before expiration
- **Action Filters** provide per-endpoint control
- **Background Services** are best for long-lived connections (WebSockets, SignalR)

The middleware approach is the most transparent to your application code and provides the best user experience!