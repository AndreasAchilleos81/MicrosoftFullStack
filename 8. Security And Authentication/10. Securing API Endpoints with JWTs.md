# JWT Authentication and Authorization in .NET

## Overview

JWTs (JSON Web Tokens) are useful for both **authentication** and **authorization**. They can carry credentials like roles and claims that enable you to implement authorization logic in your application.

This guide demonstrates how to extend basic JWT authentication to include role-based and claim-based authorization for specific routes.

## Setting Up Protected Routes

First, create routes that require specific roles or claims:

```csharp
// Route requiring admin role
app.MapGet("/admin-route", () => "This needs an admin role")
    .RequireAuthorization("AdminRole");

// Route requiring IT department claim
app.MapGet("/it-route", () => "This needs an IT claim")
    .RequireAuthorization("ITClaim");
```

## Configuring Authorization Policies

Add authorization policies to your application:

```csharp
builder.Services.AddAuthorization(options =>
{
    // Policy requiring admin role
    options.AddPolicy("AdminRole", policy =>
        policy.RequireRole("admin"));
    
    // Policy requiring IT department claim
    options.AddPolicy("ITClaim", policy =>
        policy.RequireClaim("department", "IT"));
});
```

### Key Differences

- **RequireRole**: Checks for a role value in the token
- **RequireClaim**: Checks for a specific key-value pair in the token

## Adding Roles to JWTs

Roles are added to the JWT payload by the issuer. The role is specified with the `role` key:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin",
  "iat": 1516239022
}
```

### Important Notes

- The role key is **case-sensitive** (use lowercase `role`)
- The role value matches what you specified in your policy (e.g., `"admin"`)

## Adding Claims to JWTs

Claims are key-value pairs added to the JWT payload:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin",
  "department": "IT",
  "iat": 1516239022
}
```

### Important Notes

- Claim keys and values are **case-sensitive**
- Must match exactly what's defined in your policy
- In this example: `"department": "IT"` matches `RequireClaim("department", "IT")`

## Testing Protected Routes

### Without Required Role/Claim
```http
GET /admin-route
Authorization: Bearer <token_without_admin_role>

Response: 403 Forbidden
```

### With Required Role
```http
GET /admin-route
Authorization: Bearer <token_with_admin_role>

Response: 200 OK
```

## Using Multiple Roles and Claims

A single token can contain multiple roles and claims:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin",
  "department": "IT",
  "iat": 1516239022
}
```

This token would grant access to both:
- Routes protected by the `AdminRole` policy
- Routes protected by the `ITClaim` policy

## How Authorization Works

When a request is made:

1. .NET extracts the JWT from the Authorization header
2. Validates the signature using the secret key
3. Checks if the required role or claim exists in the token payload
4. Grants or denies access based on the policy requirements

The application only looks for the specific keys and values defined in each policy. Any other information in the payload is ignored for that particular authorization check.

## Alternative Approach: Stateful Roles

Instead of embedding roles in JWTs, you can:

1. Use the JWT only for authentication (identifying the user)
2. Store roles in your backend database
3. Query the database for user roles after authentication
4. Make authorization decisions based on the database data

This hybrid approach combines JWT authentication with traditional stateful authorization.

## Security Considerations

- JWTs are trusted because they're **cryptographically signed**
- Anyone with your secret key can issue valid tokens
- Only issue tokens from trusted sources
- The issuer is responsible for adding correct roles and claims
- Always validate tokens before trusting the roles/claims within

## Summary

- **Roles**: Use `RequireRole()` and add `"role": "value"` to JWT payload
- **Claims**: Use `RequireClaim(key, value)` and add key-value pairs to JWT payload
- **Case Sensitivity**: All keys and values are case-sensitive
- **Multiple Policies**: A single token can satisfy multiple policies
- **Trust Model**: Trust is based on JWT signature validation