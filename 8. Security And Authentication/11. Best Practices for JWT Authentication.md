# JWT Authentication Best Practices (C#)

## Overview

JSON Web Tokens (JWTs) have become a popular solution for secure, stateless authentication and authorization across applications. Their effectiveness depends on proper management and implementation. This guide covers best practices for implementing secure and maintainable JWT authentication in C#.

---

## 1. Token Expiration

### Why It Matters
Token expiration limits how long a token remains valid, reducing security risks if compromised.

### Best Practice
- Set short expiration times: **15 minutes to 1 hour**
- Particularly important for high-security applications (e.g., banking apps)

### Code Example

```csharp
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;

public class JwtTokenService
{
    private readonly string _secretKey;
    
    public JwtTokenService(string secretKey)
    {
        _secretKey = secretKey;
    }
    
    // Create a token with 15-minute expiration
    public string GenerateAccessToken(string userId, string role)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_secretKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", userId),
                new Claim(ClaimTypes.Role, role)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    // Create a token with 1-hour expiration
    public string GenerateAccessTokenOneHour(string userId, string role)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_secretKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", userId),
                new Claim(ClaimTypes.Role, role)
            }),
            Expires = DateTime.UtcNow.AddHours(1),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
```

---

## 2. Refresh Tokens

### Purpose
Refresh tokens allow applications to issue new access tokens without requiring users to log in repeatedly, balancing security and convenience.

### Best Practices
- Store refresh tokens in **HTTP-only cookies** to prevent XSS attacks
- Grant refresh tokens **minimum permissions** (limited to issuing new access tokens)
- Use longer expiration times for refresh tokens (e.g., 7 days)

### Code Example

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;

public class TokenService
{
    private readonly string _jwtSecret;
    private readonly string _refreshTokenSecret;
    
    public TokenService(IConfiguration configuration)
    {
        _jwtSecret = configuration["JWT_SECRET"];
        _refreshTokenSecret = configuration["REFRESH_TOKEN_SECRET"];
    }
    
    public TokenResponse GenerateTokens(User user)
    {
        var accessToken = GenerateAccessToken(user);
        var refreshToken = GenerateRefreshToken(user);
        
        return new TokenResponse
        {
            AccessToken = accessToken,
            RefreshToken = refreshToken
        };
    }
    
    private string GenerateAccessToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_jwtSecret);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id.ToString()),
                new Claim(ClaimTypes.Role, user.Role)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    private string GenerateRefreshToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_refreshTokenSecret);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id.ToString())
            }),
            Expires = DateTime.UtcNow.AddDays(7),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    public ClaimsPrincipal ValidateRefreshToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_refreshTokenSecret);
        
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = false,
            ValidateAudience = false,
            ClockSkew = TimeSpan.Zero
        };
        
        return tokenHandler.ValidateToken(token, validationParameters, out _);
    }
}

[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly TokenService _tokenService;
    private readonly IUserService _userService;
    
    public AuthController(TokenService tokenService, IUserService userService)
    {
        _tokenService = tokenService;
        _userService = userService;
    }
    
    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        var user = await _userService.AuthenticateAsync(request.Username, request.Password);
        
        if (user == null)
        {
            return Unauthorized(new { error = "Invalid credentials" });
        }
        
        var tokens = _tokenService.GenerateTokens(user);
        
        // Store refresh token in HTTP-only cookie
        Response.Cookies.Append("refreshToken", tokens.RefreshToken, new CookieOptions
        {
            HttpOnly = true,
            Secure = true, // Use HTTPS in production
            SameSite = SameSiteMode.Strict,
            Expires = DateTimeOffset.UtcNow.AddDays(7)
        });
        
        return Ok(new { accessToken = tokens.AccessToken });
    }
    
    [HttpPost("refresh")]
    public IActionResult Refresh()
    {
        var refreshToken = Request.Cookies["refreshToken"];
        
        if (string.IsNullOrEmpty(refreshToken))
        {
            return Unauthorized(new { error = "Refresh token required" });
        }
        
        try
        {
            var principal = _tokenService.ValidateRefreshToken(refreshToken);
            var userId = principal.FindFirst("userId")?.Value;
            
            var user = _userService.GetUserById(userId);
            var newAccessToken = _tokenService.GenerateTokens(user).AccessToken;
            
            return Ok(new { accessToken = newAccessToken });
        }
        catch (Exception)
        {
            return Forbid();
        }
    }
}

public class TokenResponse
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
}

public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}
```

---

## 3. HTTP-Only Cookies

### What Are They?
HTTP-only cookies are browser cookies that cannot be accessed by client-side scripts (like JavaScript), enhancing security by limiting access to the server only.

### Benefits
- Prevents XSS attacks
- Keeps sensitive data safe from potentially harmful scripts

### Implementation Example

```csharp
// Setting HTTP-only cookie in ASP.NET Core
Response.Cookies.Append("refreshToken", token, new CookieOptions
{
    HttpOnly = true,        // Prevents JavaScript access
    Secure = true,          // Only sent over HTTPS
    SameSite = SameSiteMode.Strict,    // CSRF protection
    Expires = DateTimeOffset.UtcNow.AddDays(7)
});

// Reading HTTP-only cookie
var refreshToken = Request.Cookies["refreshToken"];

// Deleting HTTP-only cookie
Response.Cookies.Delete("refreshToken");
```

---

## 4. Secure Signing Algorithms

### Best Practice
Use strong signing algorithms to make tokens tamper-proof, ensuring they can only be modified by the original issuer.

### Recommended Algorithms
- **HS256** (HMAC with SHA-256) - Symmetric
- **RS256** (RSA with SHA-256) - Asymmetric (recommended for microservices)

### Code Example

```csharp
using System.Security.Cryptography;
using Microsoft.IdentityModel.Tokens;

public class TokenServiceWithAlgorithms
{
    // Using HS256 (symmetric)
    public string GenerateTokenHS256(string userId, string secretKey)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(secretKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", userId)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    // Using RS256 (asymmetric) - more secure for distributed systems
    public string GenerateTokenRS256(string userId, RSA privateKey)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var rsaSecurityKey = new RsaSecurityKey(privateKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", userId)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                rsaSecurityKey,
                SecurityAlgorithms.RsaSha256)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    // Verifying RS256 token
    public ClaimsPrincipal ValidateTokenRS256(string token, RSA publicKey)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var rsaSecurityKey = new RsaSecurityKey(publicKey);
        
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = rsaSecurityKey,
            ValidateIssuer = false,
            ValidateAudience = false,
            ClockSkew = TimeSpan.Zero
        };
        
        return tokenHandler.ValidateToken(token, validationParameters, out _);
    }
    
    // Loading RSA keys from files
    public static RSA LoadPrivateKey(string path)
    {
        var privateKeyText = File.ReadAllText(path);
        var rsa = RSA.Create();
        rsa.ImportFromPem(privateKeyText);
        return rsa;
    }
    
    public static RSA LoadPublicKey(string path)
    {
        var publicKeyText = File.ReadAllText(path);
        var rsa = RSA.Create();
        rsa.ImportFromPem(publicKeyText);
        return rsa;
    }
}
```

---

## 5. Secure Key Management

### Critical Rules
- **Never hardcode** secret keys in application code
- **Never store** keys in publicly accessible files
- Use **configuration files** or **environment variables** for secure storage

### Implementation Example

```csharp
// ❌ BAD - Never do this
public class BadTokenService
{
    private const string SECRET_KEY = "my-secret-key-12345";
}

// ✅ GOOD - Use configuration
public class GoodTokenService
{
    private readonly string _secretKey;
    
    public GoodTokenService(IConfiguration configuration)
    {
        _secretKey = configuration["JWT_SECRET"] 
            ?? throw new InvalidOperationException("JWT_SECRET is not configured");
    }
}

// Program.cs configuration
public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);
        
        // Verify required configuration exists
        var jwtSecret = builder.Configuration["JWT_SECRET"];
        if (string.IsNullOrEmpty(jwtSecret))
        {
            throw new InvalidOperationException("JWT_SECRET environment variable is not set");
        }
        
        builder.Services.AddSingleton<TokenService>();
        
        var app = builder.Build();
        app.Run();
    }
}
```

### appsettings.json Example

```json
{
  "JWT_SECRET": "your-super-secret-key-here-use-strong-random-string",
  "REFRESH_TOKEN_SECRET": "another-strong-secret-for-refresh-tokens"
}
```

### Environment Variables (User Secrets in Development)

```bash
# Using dotnet user-secrets (development)
dotnet user-secrets set "JWT_SECRET" "your-secret-key"
dotnet user-secrets set "REFRESH_TOKEN_SECRET" "your-refresh-secret"

# Using environment variables (production)
export JWT_SECRET=your-secret-key
export REFRESH_TOKEN_SECRET=your-refresh-secret
```

---

## 6. Token Encryption

### When to Use
Encrypt JWTs when they contain sensitive data (e.g., patient information in healthcare apps).

### Difference
- **Signing**: Confirms identity and prevents tampering
- **Encryption**: Ensures only intended users can read the data

### Code Example

```csharp
using System.Security.Cryptography;
using System.Text;

public class EncryptedTokenService
{
    private readonly byte[] _encryptionKey;
    
    public EncryptedTokenService(string encryptionKey)
    {
        // Key should be 32 bytes for AES-256
        _encryptionKey = Encoding.UTF8.GetBytes(encryptionKey.PadRight(32).Substring(0, 32));
    }
    
    // Encrypt JWT payload
    public string CreateEncryptedToken(object payload)
    {
        var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
        var payloadBytes = Encoding.UTF8.GetBytes(jsonPayload);
        
        using (var aes = Aes.Create())
        {
            aes.Key = _encryptionKey;
            aes.GenerateIV();
            
            using (var encryptor = aes.CreateEncryptor(aes.Key, aes.IV))
            using (var ms = new MemoryStream())
            {
                // Write IV to the beginning of the stream
                ms.Write(aes.IV, 0, aes.IV.Length);
                
                using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    cs.Write(payloadBytes, 0, payloadBytes.Length);
                    cs.FlushFinalBlock();
                }
                
                return Convert.ToBase64String(ms.ToArray());
            }
        }
    }
    
    // Decrypt JWT
    public T DecryptToken<T>(string encryptedToken)
    {
        var encryptedBytes = Convert.FromBase64String(encryptedToken);
        
        using (var aes = Aes.Create())
        {
            aes.Key = _encryptionKey;
            
            // Extract IV from the beginning
            var iv = new byte[aes.IV.Length];
            Array.Copy(encryptedBytes, 0, iv, 0, iv.Length);
            aes.IV = iv;
            
            using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
            using (var ms = new MemoryStream(encryptedBytes, iv.Length, encryptedBytes.Length - iv.Length))
            using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
            using (var reader = new StreamReader(cs))
            {
                var jsonPayload = reader.ReadToEnd();
                return System.Text.Json.JsonSerializer.Deserialize<T>(jsonPayload);
            }
        }
    }
}

// Usage example
public class EncryptedTokenExample
{
    public void Example()
    {
        var tokenService = new EncryptedTokenService("your-encryption-key-here");
        
        var sensitiveData = new
        {
            UserId = "12345",
            PatientId = "P-9876",
            MedicalRecord = "Confidential data"
        };
        
        // Encrypt
        var encryptedToken = tokenService.CreateEncryptedToken(sensitiveData);
        
        // Decrypt
        var decryptedData = tokenService.DecryptToken<dynamic>(encryptedToken);
    }
}
```

---

## 7. Performance Optimization

### Caching Validated Tokens
Temporarily store recent token validations to avoid repeated database checks.

```csharp
using Microsoft.Extensions.Caching.Memory;
using System;

public class CachedTokenService
{
    private readonly IMemoryCache _cache;
    private readonly TokenService _tokenService;
    
    public CachedTokenService(IMemoryCache cache, TokenService tokenService)
    {
        _cache = cache;
        _tokenService = tokenService;
    }
    
    public ClaimsPrincipal VerifyTokenWithCache(string token)
    {
        // Check cache first
        if (_cache.TryGetValue(token, out ClaimsPrincipal cachedPrincipal))
        {
            return cachedPrincipal;
        }
        
        // Verify token
        try
        {
            var principal = _tokenService.ValidateToken(token);
            
            // Cache for 10 minutes
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
            };
            
            _cache.Set(token, principal, cacheOptions);
            
            return principal;
        }
        catch (Exception)
        {
            throw;
        }
    }
}

// Register in Program.cs
builder.Services.AddMemoryCache();
builder.Services.AddScoped<CachedTokenService>();
```

### Reducing Token Size
Include only essential data (e.g., user ID, role) to speed up processing.

```csharp
public class OptimizedTokenService
{
    // ❌ BAD - Too much data
    public string GenerateBadToken(User user, string secretKey)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(secretKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id.ToString()),
                new Claim("email", user.Email),
                new Claim("firstName", user.FirstName),
                new Claim("lastName", user.LastName),
                new Claim("address", user.Address),
                new Claim("phoneNumber", user.PhoneNumber),
                new Claim("preferences", user.Preferences)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    // ✅ GOOD - Only essential data
    public string GenerateOptimizedToken(User user, string secretKey)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(secretKey);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("userId", user.Id.ToString()),
                new Claim(ClaimTypes.Role, user.Role)
            }),
            Expires = DateTime.UtcNow.AddMinutes(15),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
```

---

## Complete Authentication Middleware Example

```csharp
using Microsoft.AspNetCore.Http;
using System.IdentityModel.Tokens.Jwt;
using System.Text;
using Microsoft.IdentityModel.Tokens;

public class JwtMiddleware
{
    private readonly RequestDelegate _next;
    private readonly string _secretKey;
    
    public JwtMiddleware(RequestDelegate next, IConfiguration configuration)
    {
        _next = next;
        _secretKey = configuration["JWT_SECRET"];
    }
    
    public async Task Invoke(HttpContext context)
    {
        var token = context.Request.Headers["Authorization"].FirstOrDefault()?.Split(" ").Last();
        
        if (token != null)
        {
            AttachUserToContext(context, token);
        }
        
        await _next(context);
    }
    
    private void AttachUserToContext(HttpContext context, string token)
    {
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_secretKey);
            
            tokenHandler.ValidateToken(token, new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = false,
                ValidateAudience = false,
                ClockSkew = TimeSpan.Zero
            }, out SecurityToken validatedToken);
            
            var jwtToken = (JwtSecurityToken)validatedToken;
            var userId = jwtToken.Claims.First(x => x.Type == "userId").Value;
            
            context.Items["UserId"] = userId;
        }
        catch (SecurityTokenExpiredException)
        {
            context.Response.StatusCode = 401;
            context.Items["TokenError"] = "Token expired";
        }
        catch (Exception)
        {
            context.Response.StatusCode = 403;
            context.Items["TokenError"] = "Invalid token";
        }
    }
}

// Authorization attribute
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class AuthorizeAttribute : Attribute, IAuthorizationFilter
{
    public void OnAuthorization(AuthorizationFilterContext context)
    {
        var userId = context.HttpContext.Items["UserId"];
        
        if (userId == null)
        {
            var error = context.HttpContext.Items["TokenError"]?.ToString() ?? "Unauthorized";
            context.Result = new JsonResult(new { error }) 
            { 
                StatusCode = StatusCodes.Status401Unauthorized 
            };
        }
    }
}

// Register middleware in Program.cs
app.UseMiddleware<JwtMiddleware>();

// Protected controller example
[ApiController]
[Route("api/[controller]")]
public class ProtectedController : ControllerBase
{
    [Authorize]
    [HttpGet]
    public IActionResult Get()
    {
        var userId = HttpContext.Items["UserId"]?.ToString();
        
        return Ok(new
        {
            message = "Access granted",
            userId = userId
        });
    }
}
```

---

## ASP.NET Core JWT Authentication Configuration

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);
        
        // Configure JWT Authentication
        var jwtSecret = builder.Configuration["JWT_SECRET"];
        var key = Encoding.UTF8.GetBytes(jwtSecret);
        
        builder.Services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(options =>
        {
            options.RequireHttpsMetadata = true;
            options.SaveToken = true;
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = false,
                ValidateAudience = false,
                ClockSkew = TimeSpan.Zero,
                ValidateLifetime = true
            };
            
            // Custom error handling
            options.Events = new JwtBearerEvents
            {
                OnAuthenticationFailed = context =>
                {
                    if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
                    {
                        context.Response.Headers.Add("Token-Expired", "true");
                    }
                    return Task.CompletedTask;
                }
            };
        });
        
        builder.Services.AddAuthorization();
        builder.Services.AddControllers();
        
        var app = builder.Build();
        
        app.UseAuthentication();
        app.UseAuthorization();
        
        app.MapControllers();
        
        app.Run();
    }
}

// Using built-in authorization
[ApiController]
[Route("api/[controller]")]
public class SecureController : ControllerBase
{
    [Authorize]
    [HttpGet]
    public IActionResult GetSecureData()
    {
        var userId = User.FindFirst("userId")?.Value;
        var role = User.FindFirst(ClaimTypes.Role)?.Value;
        
        return Ok(new
        {
            message = "Access granted",
            userId = userId,
            role = role
        });
    }
    
    [Authorize(Roles = "Admin")]
    [HttpGet("admin")]
    public IActionResult GetAdminData()
    {
        return Ok(new { message = "Admin access granted" });
    }
}
```

---

## Summary of Best Practices

1. ✅ Set short expiration times (15m-1h) for access tokens
2. ✅ Use refresh tokens for seamless re-authentication
3. ✅ Store refresh tokens in HTTP-only cookies
4. ✅ Use secure signing algorithms (HS256 or RS256)
5. ✅ Never hardcode secret keys - use configuration/environment variables
6. ✅ Encrypt tokens containing sensitive data
7. ✅ Cache validated tokens for better performance
8. ✅ Keep tokens small - include only essential data

By implementing these practices, you build a foundation of trust and security that your users can rely on.