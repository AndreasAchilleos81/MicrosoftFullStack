# Using Microsoft Copilot to Write Secure Code

## Introduction

Even a small vulnerability in your code can lead to serious security risks. This guide demonstrates how to use Microsoft Copilot to generate secure code that helps prevent common vulnerabilities like SQL injection and XSS (Cross-Site Scripting) attacks.

## Input Validation - The First Line of Defense

Validation is a crucial first step in securing code. It ensures that only safe characters such as letters and numbers can enter the system, preventing potentially harmful data from reaching your database or web page.

### Creating a Validation Helper Class

Functions like validation helpers are typically part of a utility class to keep code modular and scalable. Start by creating a folder called `Helpers` or `Utilities` and define the function in a class such as `ValidationHelpers`.

**Why use static functions for validation?**
- **Efficient**: Doesn't require instantiating the class
- **Reduces memory usage**: Can be called directly without creating an object
- **Thread-safe**: No instance state to manage

### Basic Validation Function

```csharp
using System;
using System.Linq;
using System.Collections.Generic;

namespace YourApp.Helpers
{
    public static class ValidationHelpers
    {
        /// <summary>
        /// Validates user input allowing only letters, digits, and specified special characters
        /// </summary>
        /// <param name="input">The input string to validate</param>
        /// <param name="allowedSpecialCharacters">Optional special characters to allow (e.g., "@#$")</param>
        /// <returns>True if input is valid, false otherwise</returns>
        public static bool IsValidInput(string input, string allowedSpecialCharacters = "")
        {
            // Check if input is null or empty
            if (string.IsNullOrEmpty(input))
            {
                return false;
            }

            // Convert allowed special characters to HashSet for efficient lookup
            var validCharacters = new HashSet<char>(allowedSpecialCharacters);

            // Validate that every character is either alphanumeric or in the allowed set
            return input.All(c => char.IsLetterOrDigit(c) || validCharacters.Contains(c));
        }
    }
}
```

#### How the Validation Works

1. **Null/Empty Check**: `string.IsNullOrEmpty(input)` ensures invalid inputs are caught early
2. **HashSet for Performance**: Converting allowed characters to a `HashSet<char>` enables O(1) lookup time
3. **Core Validation Logic**: The `All()` method ensures every character satisfies one of two conditions:
   - `char.IsLetterOrDigit(c)` - checks if the character is alphanumeric
   - `validCharacters.Contains(c)` - checks if it's an explicitly allowed special character

## Implementing Secure Authentication

### Secure Login with Parameterized Queries

To prevent SQL injection attacks, we combine input validation with parameterized queries. This ensures user input is always treated as data, not executable SQL.

```csharp
using System;
using System.Data.SqlClient;

namespace YourApp.Services
{
    public class AuthService
    {
        private readonly string _connectionString;

        public AuthService(string connectionString)
        {
            _connectionString = connectionString;
        }

        /// <summary>
        /// Authenticates a user with secure parameterized queries
        /// </summary>
        /// <param name="username">Username to authenticate</param>
        /// <param name="password">Password to verify</param>
        /// <returns>True if login successful, false otherwise</returns>
        public bool LoginUser(string username, string password)
        {
            // Define allowed special characters for passwords
            string allowedSpecialCharactersForPassword = "!@#$%^&*";

            // Validate username (only alphanumeric)
            if (!ValidationHelpers.IsValidInput(username))
            {
                return false;
            }

            // Validate password (alphanumeric + special characters)
            if (!ValidationHelpers.IsValidInput(password, allowedSpecialCharactersForPassword))
            {
                return false;
            }

            // SQL query with placeholders (parameterized)
            string query = "SELECT COUNT(*) FROM Users WHERE Username = @Username AND Password = @Password";

            using (SqlConnection connection = new SqlConnection(_connectionString))
            {
                connection.Open();

                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Add parameters securely - prevents SQL injection
                    command.Parameters.AddWithValue("@Username", username);
                    command.Parameters.AddWithValue("@Password", password);

                    // Execute query and get count
                    int count = (int)command.ExecuteScalar();

                    // Return true if user exists, false otherwise
                    return count > 0;
                }
            }
        }
    }
}
```

#### Key Security Features

1. **Input Validation**: Both username and password are validated before processing
2. **Parameterized Queries**: Using `@Username` and `@Password` placeholders
3. **SqlCommand.Parameters**: Ensures values are treated as data, not SQL code
4. **Using Statements**: Automatically dispose of connections and commands

## Testing Security Protections

### SQL Injection Test

```csharp
public class SecurityTests
{
    /// <summary>
    /// Tests that the application blocks SQL injection attempts
    /// </summary>
    public static void TestSqlInjection()
    {
        var authService = new AuthService("YourConnectionString");

        // Simulate SQL injection attack
        string maliciousInput = "admin' OR '1'='1";
        string dummyPassword = "password";

        // Attempt login with malicious input
        bool result = authService.LoginUser(maliciousInput, dummyPassword);

        if (result)
        {
            Console.WriteLine("❌ TEST FAILED: Application is vulnerable to SQL injection!");
        }
        else
        {
            Console.WriteLine("✅ TEST PASSED: SQL injection blocked successfully.");
        }
    }
}
```

**How it works:**
- The malicious input `admin' OR '1'='1` attempts to manipulate the SQL query
- If vulnerable, this would bypass authentication by making the query always return true
- A secure implementation will reject this input during validation

### XSS (Cross-Site Scripting) Test

```csharp
public class SecurityTests
{
    /// <summary>
    /// Tests that the application blocks XSS attack attempts
    /// </summary>
    public static void TestXSSInput()
    {
        // Simulate XSS attack with malicious script
        string maliciousInput = "<script>alert('XSS')</script>";

        // Test validation
        bool isValid = ValidationHelpers.IsValidInput(maliciousInput);

        if (isValid)
        {
            Console.WriteLine("❌ TEST FAILED: Validation accepted harmful script!");
        }
        else
        {
            Console.WriteLine("✅ TEST PASSED: XSS attack blocked successfully.");
        }
    }
}
```

**How it works:**
- The malicious input contains a `<script>` tag that could execute JavaScript in a browser
- Proper validation will reject this input as it contains invalid characters
- This prevents the script from being stored or rendered on web pages

## Complete Example with All Tests

```csharp
using System;

namespace YourApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Running Security Tests...\n");

            // Test SQL Injection Protection
            SecurityTests.TestSqlInjection();

            // Test XSS Protection
            SecurityTests.TestXSSInput();

            // Test Valid Input
            TestValidInput();

            Console.WriteLine("\nAll security tests completed.");
        }

        static void TestValidInput()
        {
            string validUsername = "john_doe123";
            string validPassword = "SecureP@ss123!";

            bool usernameValid = ValidationHelpers.IsValidInput(validUsername);
            bool passwordValid = ValidationHelpers.IsValidInput(validPassword, "!@#$%^&*");

            Console.WriteLine($"Valid username test: {(usernameValid ? "✅ PASSED" : "❌ FAILED")}");
            Console.WriteLine($"Valid password test: {(passwordValid ? "✅ PASSED" : "❌ FAILED")}");
        }
    }
}
```

## Best Practices Summary

1. **Always Validate Input**: Check all user input before processing
2. **Use Parameterized Queries**: Never concatenate user input into SQL queries
3. **Static Helper Methods**: Efficient for stateless validation logic
4. **HashSet for Character Validation**: O(1) lookup performance
5. **Test Security Features**: Write tests for SQL injection and XSS protection
6. **Fail Early**: Return false immediately when validation fails
7. **Define Allowed Characters**: Be explicit about what special characters are acceptable

## Performance Considerations

**Why static methods are efficient for validation:**
- No object allocation overhead per request
- No garbage collection pressure
- Direct method invocation without virtual dispatch
- Thread-safe when implemented without shared mutable state

This approach is particularly well-suited for ASP.NET Core applications where validation may occur on every incoming request.

---

*With Microsoft Copilot's guidance, secure coding becomes more accessible, empowering you to protect your applications against common vulnerabilities.*